(一)顺序表: 就是结构体
######################################################################################

######################################################################################
(二)栈:
1.先进后出
2.如何实现栈的操作: 人为的实现先进后出
	1.用顺序表实现
		class stack
		{
		public:
			stack(int size) : size(size)
			{   this->top = -1;   // 表示栈是空的
				pstack = new int[size];
				memset(pstack, 0, sizeof(4*size));
			}
		void push(int val)  // 压栈
		{   if(top+1 > size-1) {    // 超出了边界
				cerr<<"stack full\n";
				return;
			}
			pstack[++top] = val; // 第0,1,2
		}
		int pop()  // 出栈
		{	if(top == -1){    //栈是空的
				cerr<<"stack empty\n";
				return -1;
			}
			if(top >= 0){
				int tmp = pstack[top--];
				return tmp;
			}
		}
		~stack() {delete pstack;}
		private:
			int top;    // 栈顶位置
			int size;   // 栈大小
			int *pstack;// 栈空间指针
		};
	2.用链表实现栈: 新数据放在链表尾部, 取数据时从尾部取。
		typedef list<int> list_int;
		class stack
		{
		public:
			stack(){list.clear();}
			void push(int val)				// 压栈
			{	list.push_back(val);}
			int pop()						// 出栈
			{	if(list.empty()){
					cout<<"stack empty\n";
					return -1;
				}
				int tmp = list.back();
				list.pop_back();
				return tmp;
			}
		private:
			list_int list;  // 链表容器
		};
######################################################################################
(三)队列
1.跟栈的唯一区别是先进先出: 出队, 入队

######################################################################################
(四)树:(每一个节点都可以分成若干接点)
①基本概念: 
	1.根(根节点): 是一个相对的概念, 只要有分叉, 那么这个节点就是根节点(父节点)
	2.叉(叉节点): 也是一个相对概念, 只要是分叉生成的节点都是叶子节点(孩子节点)

######################################################################################
(五)二叉树(每一个根节点分的叉数不超过2个(也可以是一个或者没有))
					1
			2 		 		   3	
	   4  		 5	      6   	 	7	
	8	  9	  10   11  12   13	 14  15
  
①基本概念: 
	1.满二叉树: 每个根节点都有两个叉
	2.左节点(左孩子), 右节点(右孩子)
	3.数的深度: 就是树的层数
	4.满二叉树的的高低为h, 节点数为n:
		有 n=2^-1
②二叉树的遍历
	1.前序: 根->左->右 		
		1.最开始的根节点一定是最顶层的根
		2.如果根是递归的,也要遵循:根->左->右
		3.示例: 1 2, 4 8 9, 5 10 11, 3, 6 12 13, 7 14 15
		
	2.中序: 左->根->右 		
		1.最开始的左节点是最下层,最左边的那个左节点
		2.如果根节点是上一层根节点的左节点,那么也满足左->根->右
		3.示例: 849, 5 10 11, 2, 6 12 13, 14 15 7, 3, 1,
		
	3.后序: 左->右->根
		894, 10 11 5, 12 13 6, 14 15 7, 3, 1
	4.按层: 从上到下, 从左到右
		1,2,3,4.....15









