yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy
				一、 排序算法
yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy
【一】冒泡排序算法
	//例子: 输入一个数据集, 然后进行冒泡排序
	int main()
	{
		char input[255];
		char str[255];
		char *tokon;
		int i = 0;
		vector<int> vec;

		cin>>input; // "A={13,5,26,50,23,816,2,3,516,6,64,9,651,2,54,61,6}"
		int len = strlen(input);
		strncpy(str, input+3, len-3-1);
		char *token = strtok(str, ",");
		vec.push_back(atoi(token));
		while(token) {
			token = strtok(NULL, ",");	// 分割字符串
			if (token)
				vec.push_back(atoi(token));
		}
		qDebug()<<vec;
		qDebug()<<vec.size();
		for(i=0; i < vec.size();i++)
			for(int j=i+1; j<(vec.size()); j++){
				if (vec[i] > vec[j]) {
					vec[i] += vec[j];	// 交换值
					vec[j] = vec[i] - vec[j];
					vec[i] = vec[i] - vec[j];
				}
			}
		qDebug()<<vec;
		return 0;
	}
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
【二】快速排序算法
	1.从左往右依次选取一个参考值
	2.选定参考之后，L下标从左往右遍历, R下标从右往左遍历（优先移动）。
	3.L和R交替遍历。 如果R=L,遍历结束。并将参考值置于重合位置上
	4.L遍历时：
		1.如果L下标的值 < 参考值:  那么L继续向前遍历
		2.如果L下标的值 > 参考值:  那么将L下标指向的值赋值R下标指向的位置, 同时R向左一步
	5.R遍历时：
		1.如果R下标的值 < 参考值:  那么将R下标指向的值赋值L下标指向的位置, 同时L向右一步
		2.如果R下标的值 > 参考值:  那么R继续向左遍历
	6.对排序后的两个部分再进行排序。
	7.
		void sort(int arry[], int low, int high)
		{
			if (high <= low)
				return;
			int i=low, j = high;
			int key = arry[low];
			while (1) {
				while(arry[++i] < key) {
					if (i == high)
						break;
				}
				while(arry[--j] > key) {
					if (j == low)
						break;
				}
				if (i >= j)
					break;
				// 交换i,j下标对应的值（i对应的值 > key > j对应的值）
				arry[i] += arry[j];
				arry[j] = arry[i] - arry[j];
				arry[i] -= arry[j];
			}
			// 到这儿的情况是,i>j或者i=j。（j对应的值 <= key <= i对应的值）
			// 交换key和j的值
			int temp = arry[low];
			arry[low] = arry[j];
			arry[j] = temp;
			sort(arry, low, j-1);
			sort(arry, j+1, high);
		}
		int main()
		{
			int a[] = {57, 68, 59, 52, 72, 28, 96, 33, 24};
			//int a[] = {3,5,1,4};
			sort(a, 0, sizeof(a) / sizeof(a[0]));/*这里原文第三个参数要减1否则内存越界*/
			for(int i = 0; i < sizeof(a) / sizeof(a[0]); i++)
				cout << a[i] << " ";

			return 0;
		}
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
【二】插入排序算法
	// 顺序地把待排序的各个记录按其关键字插入到已排序后的适当位置处。
	int a[] = {23,34,56,78,65,90,88,92,18,21};
		int i,j;
		  for( i=1;i<a.length;i++) {
			 int temp=a[i];
			 for(  j=i-1;j>=0&&temp<a[j];j--) 
					a[j+1]=a[j]; 
			 a[j+1]=temp;
			 System.out.print("第 "+i+" 次排序结果：");
			 showData(a);
	 }	
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
【三】手写strcat,
	char str1[100];
	char str2[10];
	gets(str1);
	gets(str2);
	char *p1 = str1;
	char *p2 = str2;
	int k =strlen(str1);
	p1 = p1 + k;
	while (*p2)
		*(p1++)= *(p2++);
	
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
【四】手写strstr,
	char *strstr(const char *src, const char *sub)
	{
		const char *t1;
		const char *t2;
		while(src) 
		{
			t1 = src;
			t2 = sub;
			do {
				if (!*t2)
				return src;
			}while(*t1++ == *t2++);
			src++
		}
		return NULL;
	}
	
	
	
	
	
	
	
	
	
		