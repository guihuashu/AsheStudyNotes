●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●
						Linux环境高级编程
●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●
##################################################################################
总结:
	进程间的通信:
		1.管道
		2.FIFO
		3.SYSTEM V: 共享内存 消息队列 信号量
		4.POSIX 共享内存 消息队列 信号量
		5.unix域套接字
	网络通信:
		tcp
		udp
		广播
		点播
		异步IO(多线程,多进程)
		信号驱动IO
		IO多路复用select/accpt
		unix域套接字
		
######################################################################################################################################################
						第1章 文件、文件I/O、目录
(0)基础知识
	1.文件的读写操作都是从当前文件的偏移处开始的。
	2.文件偏移量保存在文件表中。
	3.每个进程都有一个文件表。
	4.同步IO与异步IO
		在同步文件IO中，线程启动一个IO操作然后就立即进入等待状态，直到IO操作完成后才醒来继续执行。
		在异步文件IO中，线程发送一个IO请求到内核，然后继续处理其他的事情，内核完成IO请求后，将会通知线程IO操作完成了。
	5.链接: 硬链接, 符号链接
		硬链接:
			1.默认情况下，ln产生硬链接。
			2.建立硬链接时，链接文件和被链接文件必须位于同一个文件系统中。
			3.不能建立指向目录的硬链接。
		符号链接:
			1.ln命令加上- s选项，则建立符号链接。
			2.可以链接任意一个文件或者目录
			3.可以在不同的文件系统中链接
			
(1)打开文件
	int open(const char *pathname, int flags);
	int open(const char *pathname, int flags, mode_t mode);
		・pathname ：表示要打开的文件相对路径。
		・mode ：只在创建文件时需要，用于指定所创建文件的权限位
		・flags ：用于指示打开文件的选项，常用的有 O_RDONLY 、 O_WRONLY 和 O_RDWR 。
			注意:  O_RDWR ！ =O_RDONLY|O_WRONLY		//  O_RDONLY 被定义为 0 ， O_WRONLY 被定义为 1 ，而 O_RDWR 却被定义为 2 。
			1.open 是 glibc 的一个变参函数。
			・O_APPEND ：每次进行写操作时，内核都会先定位到文件尾，再执行写操作。
			・O_ASYNC ：使用异步 I/O 模式。
			・O_CLOEXEC ：在打开文件的时候，就为文件描述符设置 FD_CLOEXEC 标志。
				// 这里设置为FD_CLOEXEC表示当程序执行exec函数时本fd将被系统自动关闭,表示不传递给exec创建的新进程, 如果设置为fcntl(fd, F_SETFD, 0);
					那么本fd将保持打开状态复制到exec创建的新进程中。
			・O_CREAT ：当文件不存在时，就创建文件。
			・O_DIRECT ：对该文件进行直接 I/O ，不使用 VFS Cache 。
			・O_DIRECTORY ：要求打开的路径必须是目录。
			・O_EXCL ：该标志用于确保是此次调用创建的文件，需要与 O_CREAT 同时使用；当文件已经存在时， open 函数会返回失败。
			・O_LARGEFILE ：表明文件为大文件。
			・O_NOATIME ：读取文件时，不更新文件最后的访问时间。
			・O_NONBLOCK 、 O_NDELAY ：将该文件描述符设置为非阻塞的（默认都是阻塞的）。
			・O_SYNC ：设置为 I/O 同步模式，每次进行写操作时都会将数据同步到磁盘，然后 write 才能返回。
			・O_TRUNC ：在打开文件的时候，将文件长度截断为 0 ，需要与 O_RDWR 或 O_WRONLY 同时使用。			
	int openat(int dirfd, const char *pathname, int flags);
	int openat(int dirfd, const char *pathname, int flags, mode_t mode);
		1.如果pathname是绝对路径，则dirfd参数没用。
		2.如果pathname是相对路径，并且dirfd的值不是AT_FDCWD，则pathname的参照物是相对于dirfd指向的目录，而不是进程的当前工作目录；
		3.如果pathname是相对路径，并且dirfd的值是AT_FDCWD，pathname则是相对于进程当前工作目录的相对路径，此时等同于open。
(2)创建文件
	int creat(const char *pathname, mode_t mode);
		1.若成功返回为只写打开的文件描述符; 若出错,返回-1
		2.等效于open(path, O_WRONLY | O_CREATE | O_TRUNC, mode);
(3)关闭文件描述符
	int close(int fd);
	1.close 用于关闭文件描述符。而文件描述符可以是普通文件，也可以是设备，还可以是 socket 。
	2.遗忘 close 造成的问题
		・ 文件描述符始终没有被释放。
		・ 用于文件管理的某些内存结构没有被释放。
		・对于普通进程来说，即使应用忘记了关闭文件，当进程退出时， Linux 内核也会自动关闭文件，释放内存（详细过程见后文）。
		・但是对于一个常驻进程来说，问题就变得严重了。	
	3.lsof查看打开了,但是尚未关闭的文件
	
	
(4)文件偏移
	off_t lseek(int fd, off_t offset, int whence);
	0.如果fd是指向一个管道,FIFO或者网络套接字, lseek返回-1,置errno为ESPIPE
	1.该函数用于将 fd 的文件偏移量设置为以 whence 为起点，偏移为 offset 的位置。
	2. whence 可以为三个值： SEEK_SET 、 SEEK_CUR 和 SEEK_END ，分别表示为 “ 文件的起始位置 ” 、
		“ 文件的当前位置 ” 和 “ 文件的末尾 ” ，而 offset 的取值正负均可。
	3. lseek 执行成功后，会返回新的文件偏移量。出错返回-1。
	4.确定打开文件的当前偏移量
		off_t curpos;
		curpos = lseek(fd, 0, SEEK_CUR);
	5.文件偏移量可以大于文件的当前长度, 在这种情况下, 对该文件的下一次写将加长该文件。并在文件中
		构建一个空洞，这一点是允许的。位于文件中没有学过的直接都被设为0
	6.lseek函数只修改文件表项中的当前文件偏移量， 不进行任何IO操作
	7.文件空洞不占用磁盘空间

(5)读
	ssize_t read(int fd, void *buf, size_t count);
	1.返回读取到的字节数。 若已经到文件尾部,再次调用read时返回0; 若出错返回-1。
	2.有很多情况可使实际读到的字节数少于要求读的字节数：
		1.文件中的当前偏移位置到文件结尾 < 要读取的字节数, 返回实际读取的字节数
		2.文件当前偏移位置已经在文件尾部, 返回0。（不阻塞）
		3.从网络读时， 网络中的缓冲机制可能造成返回值小于所要求读的字节数
		4.读管道或者FIFO时。 如果包含的字节数 < 要读取的字节数, 那么read将只返回实际可用的字节数。
		5.某些面向记录的设备（如磁带）一次最多返回一个记录。
		6.读取过程中被信号中断时， 返回实际读取的字节数
		
(6)写
	ssize_t write(int fd, const void *buf, size_t count); 
	1.write 尝试从 buf 指向的地址，写入 count 个字节到文件描述符 fd 中，并返回成功写入的字节数，同时
		将文件偏移向前移动相同的字节数。 write 有可能写入比指定 count 少的字节数。	
	2.当多个进程同时写一个文件时，即使对 write 进行了锁保护，在进行串行写操作时，文件依然不可避免地会被写乱。根本原因就在于文件偏移量是进程级别的。				
(7)文件共享
	  -------------------		--------------	   -----------		-----------
		进程表项				文件表项		    v节点表项		i节点
	  -------------------		--------------	   -----------		-----------
		 标志	文件指针	    文件状态标志		v节点信息		i节点信息
	  fd0						当前文件偏移量		v_data			当前文件长度
	  fd1						v节点指针							i_vnode
	  -------------------		--------------	   -----------		-----------
		1.文件指针指向文件表项
		2.v节点指针指向v节点表项
		3.v_data指向i节点。
	  
	1.每个进程在进程表中都有一个打开文件描述符表
	2.内核为所有打开的文件维持一种文件表
	3.每个打开的文件(设备)都有一个v节点
	4.unix环境编程60页图
	注意:
		1.可能有多个文件描述符指向同一文件表项
			1.dup
			2.fork后, 父进程打开的所有"文件描述符"都被复制到子进程中,父子进程每个相同的打开描述符
			   共享一个文件表项
(8)文件的原子读写
	ssize_t pread(int fd, void *buf, size_t count, off_t offset);
    ssize_t pwrite(int fd, const void *buf, size_t count, off_t offset);
						
	1.pread 不会从文件表中获取当前偏移，而是直接使用用户传递的偏移量，并且在读取完毕后，不会更改当前文件的偏移量。
	2.pwrite 的实现与 pread 类似
(9)复制文件描述符	
	int dup(int oldfd);
		1.dup（）系统调用使用编号最小的文件描述符创建文件描述符oldfd的副本。
		2.在成功返回之后，旧的和新的文件描述符可以互换使用。
		3.两个文件描述符共用同一个文件表，但是不共享文件描述符标志
			例如：如果通过在其中一个描述符上使用lseek修改文件偏移量，则另一个描述符的偏移量也会更改。
				  关闭重复描述符的close-on-exec标志	
		4.调用close关闭文件描述符时, oldfd和拷贝的newfd都需要手动关闭。
	int dup2(int oldfd, int newfd);
		1.dup2与dup执行同样的操作，newfd是用户传入的
		2.如果newfd和已经是另外一个文件打开的描述符， 那么会先将newfd所在的文件描述符关闭，然后执行拷贝工作
		3.如果newfd与oldfd相同， 那么dup2函数不执行任何操作，且返回newfd
	int dup3(int oldfd, int newfd, int flags);
		dup3与dup2不同点在于：
		1. 调用者仅仅可以通过在flags中指定O_CLOEXEC来强制为新文件描述符设置close-on-exec标志。
		2. 如果oldfd等于newfd，则dup3（）将失败并显示错误EINVAL。
(10)文件数据同步
	void sync(void);
		1.只是将所有修改过的块缓冲区排入写队列, 然后就返回, 他并不等待实际写磁盘操作结束
		2.updata系统守护进程周期性的调用sync函数(30s)
	int fsync(int fd);
		1.fsync 只同步 fd 指定的文件，并且等待写磁盘操作结束才返回。
		2.同步更新文件数据
	int fdatasync(int fd);
		1.类似于fsync但他只影响文件的数据部分
		2.不会同步更新文件的属性
		
		
(11)获取文件的元数据
	int stat(const char *path, struct stat *buf);
	int fstat(int fd, struct stat *buf);
	int lstat(const char *path, struct stat *buf);
	int fstatat(int dirfd, const char *pathname, struct stat *statbuf,  int flags);
					 
		这三个函数都可用于得到文件的基本信息。
		1.stat 得到路径 path 所指定的文件基本信息。
		2.fstat得到文件描述符 fd 指定文件的基本信息。
		3.如果path指向的是链接文件，lstat得到的是链接文件自己本身的基本信息而不是其指向文件的信息。
		struct stat {
			dev_t st_dev; 			// 设备ID
			ino_t st_ino; 			// 节点号
			mode_t st_mode; 		// 包含
			nlink_t st_nlink; 		// 硬链接数
			uid_t st_uid; 			// 所有者用户ID
			gid_t st_gid; 			// 所有者组ID
			dev_t st_rdev; 			// 设备ID(如果是特殊的文件)
			off_t st_size; 			// 文件总大小, 以字节为单位
			blksize_t st_blksize;   // 文件系统I/O的块大小
			blkcnt_t st_blocks; 	// 分配了512B的块数
			time_t st_atime; 		// 上次访问时间
			time_t st_mtime; 		// 最后修改时间
			time_t st_ctime; 		// 上次状态变更时间
		};
		
(12)改变已经打开文件的属性(fcntl)
①基本概念
	(1)文件描述符标志	
	    定义: 每个进程为所有打开的文件维护对应的fd flag。当前只定义了种文件描述符标志：FD_CLOEXEC：
	  若设置某个文件的fd flag（即为1），则进程fork出子进程时，执行exec前要关闭这个文件描述符。
		1.close_on_exec标志是一个进程所有文件描述符的位图标志，每个比特位代表一个打开的文件描述符，用于确定该打开文件的FD_CLOEXEC状态（1，设置；0，清除）。
		2.FD_CLOEXEC默认为0，因此默认情况下子进程继承的文件描述符都处于打开状态。（“越权”安全问题）
		3.设置某个文件的close on exec标志：fcntl(fd, F_SETFD, flags | FD_CLOEXEC)来进行设置（flags可先通过F_GETFD获得）
		4.FD_CLOSEEXEC带来的安全问题父进程打开了某些文件并fork子进程，子进程就会默认有这些文件的读取权限，但很多时候并不想让子进程有这么多的权限。
		  ――解决办法：设置FD_CLOSEEXEC标志，exec新程序之前关闭继承的打开文件。

	(2)文件状态标志
		定义: 指明文件的状态属性，它们由open的flags参数初始化。可能由fcntl（F_SETFL）修改。
			1.由dup（2），fcntl（F_DUPFD），fork（）等生成的新文件描述符指向的都是同一个打开文件, 因此共享相同的文件状态标志。
			2.进程跟文件相关的结构式struct file, 对于fork,子进程仅拷贝了父进程的struct file指针, 还是和父亲共用
		文件状态标志分类: 
			1.访问方式标志：指明允许文件标志符用于读、写或两者兼之，包括O_RDONLY、O_WRONLY和O_RDWR。
			2.打开时标志：指明打开文件时影响open行为的一些选项。
				这些选项除了O_NONBLOCK其他的一旦文件打开就不再保留，因为O_NONBLOCK同时也是一个I/O操作方式，故此标志被保留。
				O_CREAT：若设置，当该文件不存在时创建并打开此文件。
				O_EXCL：若O_CREAT和O_EXCL同时设置，当指定的文件已经存在时open失败。保证不破坏已存在的文件。
				O_TRUNC：截断文件为零长度，这一选项只对普通文件有用，对诸如目录或FIFO之类的特殊文件无用。
				O_NONBLOCK：防止为打开文件而阻塞很长时间。这通常仅对设备、网络、管道文件才有意义。此标志同时也作为I/O操作方式标志，这意味着在open中指明O_NONBLOCK就同时设置了非阻塞I/O方式。因此要非阻塞地打开一个文件且不影响正常的阻塞I/O，必须先设置O_NONBLOCK调用open，然后调用fcntl关闭此位。
			3.I/O操作方式标志：使用fd读/写的工作方式。这些标志由open()设置，之后可以用fcntl()获取和改变。
				O_APPEND：用于追加写。
				O_NONBLOCK
				O_ASYNC
				O_SYNC
				O_DSYNC
				O_RSYNC
				
②int fcntl(int fd, int cmd, ... /* arg */ );	
	(1)功能(5种)
	1.提供了以下5个功能
		1.复制一个文件描述符	 (F_DUPFD、F_DUPFD_CLOEXEC )
		2.获取设置文件描述符标志（F_GETFD、F_SETFD）
			仅能设置文件描述符标志: FD_CLOEXEC
			
		3.获取设置文件状态标志  （F_GETFL、F_SETFL）
			能设置被允许修改的所有文件状态标志
			// 仅能够设置O_APPEND, O_ASYNC, O_DIRECT, O_NOATIME, O_NONBLOCK 
		4.获取设置异步I/O所有权 （F_GETOWN、F_SETOWN ）
		5.获取设置记录锁		（F_SETLK、F_SETLKW、F_GETLK）
	2.fcntl的设置文件描述符方法
		1.先获取描述符原来的属性
		2.将设置的属性 = 原来的属性 | 想设置的属性
		3.设置将设置的属性。
		  例子： 
			int flags = fcntl (fd, F_GETFD, 0);
			flags |= FD_CLOEXEC;
			flags = fcntl (fd, F_SETFD, flags);
	3.fcntl的设置文件状态标志的方法
		1.先获取描述符原来的属性
		2.将设置的属性 = 原来的属性 | 想设置的属性
		3.设置将设置的属性。
		  例子： 
			int flags = fcntl (fd, F_GETFL, 0);
			flags |= O_NOOBLOCK;
			flags = fcntl (fd, F_SETFL, flags);
	4.设置套接字描述符: 开启SIGIO信号驱动IO功能
		1.设置套接字描述符sfd接收SIGIO和SIGURG信号的进程ID或进程组ID。 // 一个套接字可能在多个进程中都有描述符, 他们都有可能接收信号
			fcntl(sfd, F_SETOWN, getpid());
		2.设置套接字: 启用信号驱动的I/O (文件状态标志)
			// 当在此文件描述符上输入或输出成为可能时，生成一个信号（默认情况下为SIGIO，但可以通过fcntl（2）更改）。 
			int val = fcntl(sfd, F_GETFL);
			val |= O_ASYNC;
			fcntl(sfd, F_SETFL, val);
		3.在信号函数里面收发数据
	
	  
(13)文件截断
	int truncate(const char *path, off_t length);
	int ftruncate(int fd, off_t length);
		1. truncate 截断的是路径 path 指定的文件， ftruncate 截断的是 fd 引用的文件。
		2. length 可以大于文件本身的大小，这时文件长度将变为 length 的大小，扩充的内容均被填充为 0 。
		3.尽管 ftruncate使用的是文件描述符，但是其并不会更新当前文件的偏移。
	1.为什么需要文件截断?
		如果某个文件已经存在有5个字节12345, 这时我打开文件(偏移量为0), 写入33, 结束后文件为33345,这个结果显然不是我们想要的
	2.文件截断为0长度的方法。
		1.打开文件的同时，指定 O_TRUNC标志。
		2.truncate(path, 0)   ftruncate(fd,0)
		
		
##################################################################################
								第4章 进程的一生
##################################################################################
	典型的进程的生命周期:
						wait()
		→→父进程---------------------------→父进程→→→→→
			  ↓								 ↑
		fork()↓								 ↑
			  ↓								 ↑
			子进程----------→子进程--------→子进程(僵尸进程)
					exec()			  wait()
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx					
【4.1】进程ID
	1.Linux 下每个进程都会有一个非负整数表示的唯一进程 ID				
	2.Linux 提供了 getpid 函数来获取进程的 pid ，同时还提供了 getppid 函数来获取父进程的 pid ，				
		pid_t getpid(void);
		pid_t getppid(void);
	3.每个进程都有自己的父进程，父进程又会有自己的父进程，最终都会追溯到 1 号进程即 init 进程
	4.可以通过 pstree 的命令来查看进程的家族树。
	5.procfs 文件系统会在 /proc 下为每个进程创建一个目录，名字是该进程的 pid 。
	6.虽然进程 ID 是唯一的，但是进程 ID 可以重用。	
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx					
【4.2】进程的层次
①层次
	1.每个进程都有父进程，父进程也有父进程，这就形成了一个以 init 进程为根的家族树。除此以外，进程还有其他层次关系：进程、进程组和会话。
	2.进程组：是一组相关进程的集合
	3.会话是一组相关进程组的集合
	// 用人来打比方，会话如同一个公司，进程组如同公司里的部门，进程则如同部门里的员工。
	4.进程会有如下 ID：
		・PID ：进程的唯一标识。对于多线程的进程而言，所有线程调用 getpid 函数会返回相同的值。
		・PGID ：进程组 ID 。每个进程都会有进程组 ID ，表示该进程所属的进程组。默认情况下新创建的进程会继承父进程的进程组 ID 。
		・SID ：会话 ID 。每个进程也都有会话 ID 。默认情况下，新创建的进程会继承父进程的会话 ID 。	
	5.查看所有进程的层次关系：
		ps -ejH
		ps axjf	
	6.获取其进程组 ID 和会话 ID 
		pid_t getpgrp(void);
		pid_t getsid(pid_t pid);	
	7.进程组和会话是为了支持 shell 作业控制而引入的概念。
		1.当有新的用户登录 Linux 时，登录进程会为这个用户创建一个会话。用户的登录 shell 就是会话的首
			进程。会话的首进程 ID 会作为整个会话的 ID 。会话是一个或多个进程组的集合，囊括了登录用户的所有活动。
		2.在登录 shell 时，用户可能会使用管道，让多个进程互相配合完成一项工作，这一组进程属于同一个进程组。
		3.当用户通过 SSH 客户端工具（ putty 、 xshell 等）连入 Linux 时，与上述登录的情景是类似的。
②进程组
	1.修改进程组 ID 的接口
		int setpgid(pid_t pid, pid_t pgid);
	2.会话
		1.会话是一个或多个进程组的集合，以用户登录系统为例，可能存在如图 4-3 所示的情况
			会话首进程			后台进程组			前台进程组
			登录shell			proc1→proc2		proc5→proc6
								→proc3→proc4		
		2.setsid 函数来创建会话
			pid_t setsid(void);
			1）创建一个新会话，会话 ID 等于进程 ID ，调用进程成为会话的首进程。
			2）创建一个进程组，进程组 ID 等于进程 ID ，调用进程成为进程组的组长。
			3）该进程没有控制终端，如果调用 setsid 前，该进程有控制终端，这种联系就会断掉。
			调用 setsid 函数的进程不能是进程组的组长，否则调用会失败，返回 -1 ，并置 errno 为 EPERM 。
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx					
【4.3】进程的创建之 fork（）
	pid_t fork(void);
		1.进程可以调用 fork 函数来创建新的进程。调用进程为父进程，被创建的进程为子进程。
		2.与普通函数不同， fork 函数会返回两次。 fork 函数向子进程返回 0 ，并将子进程的进程 ID 返给父进程。当然了，如果 fork 失败，该函数则返回 -1 ，并设置 errno 。
		3.注意：POSIX 标准和 Linux 都没有保证会优先调度父进程。因此在应用中，决不能对父子进程的执行顺序做任何的假设。如果确实需要某一特定执行的顺序，那么需要使用进程间同步的手段。 
		4.多线程与 fork （）
			多线程和 fork 函数的协作性非常差。对于多线程和 fork ，最重要的建议就是永远不要在多线程程序
		  里面调用 fork 。Linux 的 fork 函数，会复制一个进程，对于多线程程序而言， fork 函数复制的是调用 fork 的那个线
		  程，而并不复制其他的线程。 fork 之后其他线程都不见了。
		
		
①fork 之后父子进程的内存关系
	1.fork 之后的子进程完全拷贝了父进程的地址空间，包括栈、堆、代码段等。 // 如全局变量, 局部变量, malloc分配的变量
	2.如果父子进程对相应的数据进行修改，那么两个进程是并行不悖、互不影响的。
	3. fork 时子进程完全拷贝父进程的数据段、栈和堆的做法是不明智的，因为接下来的子进程可能指向 exec 系列函数会毫不留情地抛弃刚刚辛苦拷贝的内存。
		==> Linux 引入了写时拷贝（ copy-on-write ）的技术
	4.写时拷贝技术:
		写时拷贝是指子进程的页表项指向与父进程相同的物理内存页，这样只拷贝父进程的页表项就可以了，当然要把这些页面标记成
		只读（如图 4-4 所示）。如果父子进程都不修改内存的内容，大家便相安无事，共用一份物理内存页。但是一旦父子进程中有任何一方
		尝试修改，就会引发缺页异常（ page fault ）。此时，内核会尝试为该页面创建一个新的物理页面，并将内容真正地复制到新的物理页面中，
		让父子进程真正地各自拥有自己的物理内存页，然后将页表中相应的表项标记为可写。
		//说明: 对于没有修改的页面，内核并没有真正地复制物理内存页，仅仅是复制了父进程的页表。这种机制的引入提升了 fork 的性能，从而使内核可以快速地创建一个新的进程。

②fork 之后父子进程的内存关系
	1.执行 fork 函数，内核会复制父进程所有的文件描述符。对于父进程打开的所有文件，子进程也是可以操作的。父子进程同时操作同一个文件是互相影响的。
	2.无论父进程还是子进程调用 read 函数导致文件偏移量后移都会被对方获知，这表明父子进程共用了一套文件偏移量。
	3.对于fork的子进程，在执行exec函数时没有关闭子进程的文件描述符， 任可操作， 这带来了权限安全问题
	  Linux 引入了 close on exec 机制。设置了 FD_CLOSEXEC 标志位的文件，在子进程调用 exec 家族函数时会将相应的文件关闭。
    4.设置了 FD_CLOSEXEC 标志位的方法：
		・open 时，带上 O_CLOSEXEC 标志位。	// 推荐
		・open 时如果未设置，那就在后面调用 fcntl 函数的 F_SETFD 操作来设置
		
③fork 之后父子进程的内存关系
	1.在内核的进程描述符 task_struct 结构体中，与打开文件相关的变量如下所示：
		struct task_struct {
		...struct files_struct *files;...
		}
	2.不难看出，父子进程之间拷贝的是 struct file 的指针，而不是 struct file 的实例，父子进程的 struct file 类型指针，都指向同一个 struct file 实例。 
	3. struct file 成员变量
		struct file{
			loff_t f_pos; ...  /* 文件位置指针的当前值，即文件偏移量 */
		}
		==》因为父子进程的指针都指向了同一个 struct file 结构体。所以父子进程是如何共享文件偏移量。
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx					
【4.4】进程的创建之 vfork（）
	在早期的实现中， fork 没有实现写时拷贝机制，而是直接对父进程的数据段、堆和栈进行完全拷贝，效率十分低下。很多程序在 fork 一个子进程后，会紧接着执行 exec 家族函数，这更是一种浪费。所
	以 BSD 引入了 vfork 。既然 fork 之后会执行 exec 函数，拷贝父进程的内存数据就变成了一种无意义的行为，所以引入的 vfork 压根就不会拷贝父进程的内存数据，而是直接共享。再后来 Linux 引入了写时拷贝
	的机制，其效率提高了很多，这样一来， vfork 其实就可以退出历史舞台了。除了一些需要将性能优化到极致的场景，大部分情况下不需要再使用 vfork 函数了。
	1.vfork 会创建一个子进程，该子进程会共享父进程的内存数据，而且系统将保证子进程先于父进程获得调度。
	2.子进程也会共享父进程的地址空间，而父进程将被一直挂起，直到子进程退出或执行 exec 。
	3.vfork 之后，子进程如果返回，则不要调用 return ，而应该使用 _exit 函数。如果使用 return 返回，就意味着 main 函数返回了，因为栈是父子进程共享的，所以程
	  序的函数栈发生了变化。
	4.一般来说， vfork 创建的子进程会执行 exec ，执行完 exec 后应该调用 _exit 返回。注意是 _exit 而不是exit 。
	  因为 exit 会导致父进程 stdio 缓冲区的冲刷和关闭。
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx					
【4.5】daemon 进程的创建
	1.daemon 进程又被称为守护进程，一般来说它有以下两个特点：
		1.生命周期很长，一旦启动，正常情况下不会终止，一直运行到系统退出。
		2. 在后台执行，并且不与任何控制终端相关联。
	2.创建一个 daemon 进程的步骤被概括地称为 double-fork magic 。
		（1）执行 fork （）函数，父进程退出，子进程继续
		（2）子进程执行如下三个步骤，以摆脱与环境的关系
			1）修改进程的当前目录为根目录（ / ）。
			2）调用 setsid 函数。这个函数的目的是切断与控制终端的所有关系，并且创建一个新的会话。
			3）设置文件模式创建掩码为 0 。		
		（3）再次执行 fork ，父进程退出，子进程继续		
		（4）关闭标准输入（ stdin ）、标准输出（ stdout ）和标准错误（ stderr ）		
	3.glibc 提供了 daemon 函数，从而帮我们将程序转化成 daemon 进程。
		int daemon(int nochdir, int noclose);
			其中的 nochdir ，用来控制是否将当前工作目录切换到根目录。
			・0 ：将当前工作目录切换到 / 。
			・1 ：保持当前工作目录不变。		
			而 noclose ，用来控制是否将标准输入、标准输出和标准错误重定向到 /dev/null 。
			・0 ：将标准输入、标准输出和标准错误重定向到 /dev/null 。
			・1 ：保持标准输入、标准输出和标准错误不变。		
			一般情况下，这两个入参都要为 0 。	//ret = daemon(0,0)	
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx					
【4.6】进程的终止
	在不考虑线程的情况下，进程的退出有以下 5 种方式。
	正常退出有 3 种：
		・ 从 main 函数 return 返回
		・ 调用 exit
		・ 调用 _exit
	异常退出有两种：
		・ 调用 abort
		・ 接收到信号，由信号终止
①_exit 函数
	void _exit(int status);
		1. status 参数定义了进程的终止状态，父进程可以通过 wait （）来获取该状态值。需要注意的是返回值，虽然 status 是 int 型，但是仅有低 8 位可以被父进程所用。所以写 exit （ -1 ）结束进程时，在终端执行 “$ ？ ” 会发现返回值是 255 。

②exit 函数
	(1)void exit(int status);
	   exit（）函数的最后也会调用 _exit （）函数，但是 exit 在调用 _exit 之前，还做了其他工作：	
		1）执行用户通过调用 atexit 函数或 on_exit 定义的清理函数。
		2）关闭所有打开的流（ stream ），所有缓冲的数据均被写入（ flush ），通过 tmpfile 创建的临时文件		都会被删除。
		3）调用 _exit 。	
	(2)exit 函数和 _exit 函数的不同之处：
		1.首先是 exit 函数会执行用户注册的清理函数。用户可以通过调用 atexit （）函数或 on_exit （）函数来
		  定义清理函数。这些清理函数在调用 return 或调用 exit 时会被执行。执行顺序与函数注册的顺序相反。
		  当进程收到致命信号而退出时，注册的清理函数不会被执行；当进程调用 _exit 退出时，注册的清理函数不会被执行；
		  当执行到某个清理函数时，若收到致命信号或清理函数调用了 _exit （）函数，那么该清理函数不会返回，从而导致排在后面的需要执行的清理函数都会被丢弃。
		2.其次是 exit 函数会冲刷（ flush ）标准 I/O 库的缓冲并关闭流。 glibc 提供的很多与 I/O 相关的函数都提供了缓冲区，用于缓存大块数据。
		  缓冲有三种方式：无缓冲（ _IONBF ）、行缓冲（ _IOLBF ）和全缓冲（ _IOFBF ）。
			・ 无缓冲：就是没有缓冲区，每次调用 stdio 库函数都会立刻调用 read/write 系统调用。
			・ 行缓冲：对于输出流，收到换行符之前，一律缓冲数据，除非缓冲区满了。对于输入流，每次读取一行数据。
			・ 全缓冲：就是缓冲区满之前，不会调用 read/write 系统调用来进行读写操作。
		  如果不冲刷缓冲区，缓冲区的数据就会丢失。exit 函数在关闭流之前，会冲刷缓冲区的数据，确保缓冲区里的数据不会丢失。	
		3.存在临时文件， exit 函数会负责将临时文件删除
		4.exit 函数的最后调用了 _exit （）函数，最终殊途同归，走向内核清理。
	
③return 退出
	return 是一种更常见的终止进程的方法。执行 return（ n ）等同于执行 exit（ n ），因为调用 main（）的运行时函数会将 main 的返回值当作 exit 的参数。

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx					
【4.7】等待子进程
①僵尸进程
	(1)说明
		1.进程退出时会进行内核清理，基本就是释放进程所有的资源，这些资源包括内存资源、文件资源、信号量资源、共享内存资源，
		  或者引用计数减一，或者彻底释放。不过，进程的退出其实并没有将所有的资源完全释放，仍保留了少量的资源，比如进程的 PID 依然被占用着，不可被系统分配。
		  此时的进程不可运行，事实上也没有地址空间让其运行，进程进入僵尸状态。
		2.僵尸进程依然保留的资源有进程控制块 task_struct 、内核栈等。这些资源不释放是为了提供一些重要的信息，比如进程为何退出，
		  是收到信号退出还是正常退出，进程退出码是多少，进程一共消耗了多少系统 CPU 时间，多少用户 CPU 时间，收到了多少信号，
		  发生了多少次上下文切换，最大内存驻留集是多少，产生多少缺页中断？等等。这些信息，就像墓志铭，总结了进程的一生。
		3.一旦父进程收集了这些信息之后（通过调用下面提到的wait/waitpid 等函数），这些残存的资源完成了它的使命，就可以释放了，
		  进程就脱离僵尸状态，彻底消失了。
	(2)查看僵尸进程
		1.ps 命令输出的进程状态 Z ，就表示进程处于僵尸状态，
		2.procfs 提供的 status 信息中的 State 给出的值是 Z （ zombie ），也表明进程处于僵尸状态。
	(3)清理僵尸进程
	   进程一旦进入僵尸状态，就进入了一种刀枪不入的状态，“ 杀人不眨眼 ” 的 kill-9 也无能为力，因为谁也没有办法杀死一个已经死去的进程。
	   清除僵尸进程有以下两种方法：
		・ 父进程调用 wait 函数，为子进程 “ 收尸 ” 。
		・ 父进程退出， init 进程会为子进程 “ 收尸 ” 。
	(4)防范僵尸进程的操作
		1.应该将父进程对 SIGCHLD 的处理函数设置为 SIG_IGN 。		
		2.或者在调用 sigaction 函数时设置 SA_NOCLDWAIT 标志位。
		 说明:
			1.这两者都会明确告诉子进程，不会为子进程 “ 收尸 ” 。
			2.子进程退出的时候，内核会检查父进程的 SIGCHLD 信号处理结构体是否设置了 SA_NOCLDWAIT 标志位，
			  或者是否将信号处理函数显式地设为 SIG_IGN 。
			3.如果显示的设置了SIGCHLD为SIG_IGN, 或者SIGCHLD带SA_NOCLDWAIT标志, 那么子进程退出时会"自行了断",
			  不会变为僵尸进程。

②等待子进程之wait（）
	pid_t wait(int *status);
		成功时，返回已退出子进程的进程 ID ；失败时，则返回 -1 并设置 errno ，
	(1)说明:
		1.wait（）函数等待的是任意一个子进程，任何一个子进程退出，都可以让其返回。
		2.如果没有子进程处于僵尸状态,wait（）的调用进程会陷入阻塞。 
		3.当多个子进程都处于僵尸状态， wait（）函数获取到其中一个子进程的信息后立刻返回(不遵循编程僵尸进程时间先后顺序)。
		4.由于 wait （）函数不会接受 pid_t 类型的入参，所以它无法明确地等待特定的子进程。
	(2)wait（）函数返回有三种可能性：
		・等到了子进程退出，获取其退出信息，返回子进程的进程 ID 。
		・等待过程中，收到了信号，信号打断了系统调用，并且注册信号处理函数时并没有设置 SA_RESTART 标志位，系统调用不会被重
		  启， wait （）函数返回 -1 ，并且将 errno 设置为 EINTR 。
		・已经成功地等待了所有子进程，没有子进程的退出信息需要接收，在这种情况下， wait（）函数返回 -1 ， errno 为 ECHILD 。		
	(3)wait（）的局限性
		1.不能等待特定的子进程。
		2.如果不存在子进程退出， wait（）只能阻塞。
		3.wait（）函数只能发现子进程的终止事件，不能发现信号停止和信号继续事件
		// 由于上述三个缺点的存在，所以 Linux 又引入了 waitpid （）函数。
	(4)用宏处理status, 来判断子进程退出时的状态, 请参考wait_pid
	
③等待子进程之waitpid（）
	pid_t waitpid(pid_t pid, int *status, int options);	
	   pid:		
		・pid ＞ 0 ：表示等待进程 ID 为 pid 的子进程，也就是上文提到的精确打击的对象。
		・pid ＝ 0 ：表示等待与调用进程同一个进程组的任意子进程；因为子进程可以设置自己的进程组，所以某些子进程不一定和父进程归属于同一个进程组，这样的子进程， waitpid 函数就毫不关心了。
		・pid ＝ -1 ：表示等待任意子进程，同 wait 类似。 waitpid（ -1，&status，0 ）与 wait（&status）完全等价。
		・pid ＜ -1 ：等待所有子进程中，进程组 ID 与 pid 绝对值相等的所有子进程。	
	   status: 与wait（）相同，都是用来记录子进程的相关事件
	   options:
		  WUNTRACE ：除了关心终止子进程的信息，也关心那些因信号而停止的子进程信息。
		  WCONTINUED ：除了关心终止子进程的信息，也关心那些因收到信号而恢复执行的子进程的状态信息。
		  WNOHANG ：指定的子进程并未发生状态变化，立刻返回，不会阻塞。这种情况下返回值是 0 。如果调用进程并没有与 pid 匹配的子进程，则返回 -1 ，并设置 errno 为 ECHILD 
	   返回值: 与wait（）相同，都是终止子进程或因信号停止或因信号恢复而执行的子进程的进程 ID 。
	(1)waitpid的致命缺陷
		当 waitpid 返回时，可能是因为子进程终止，也可能是因为子进程停止。这是 waitpid 和 wait 的致命缺陷。
		==>为了解决这个缺陷， wait 家族的最重要成员， waitid （）函数就要闪亮登场了。
		
④等待子进程之等待状态值
	无论是 wait （）函数还是 waitpid （）函数，都有一个 status 变量。这个变量是一个 int 型指针。可以传递 NULL ，表示不关心子进程的状态信息。
	如果不为空，则根据填充的 status 值，可以获取到子进程的很多信息。
	(1)进程是正常退出的
		WIFEXITED(status)		// 如果子进程正常退出, 返回ture,反之false
		WEXITSTATUS(status)		// 如果子进程正常退出, 该宏获取进程的退出状态
	(2)进程收到信号，导致退出	
		WIFSIGNALED(status)		// 如果子进程被信号杀死, 返回ture,反之false
		WTERMSIG(status)		// 如果子进程被信号杀死, 该宏获取进程的退出状态
		WCOREDUMP(status)		// 如果子进程产生了core dump,  返回ture,反之false
	(3)进程收到信号，被停止
		WIFSTOPPED(status)		// 如果子进程被信号暂停, 返回ture,反之false
		WSTOPSIG(status)		// 如果子进程处于暂停状态, 该宏返回信号值
	(4)子进程恢复执行
		WIFCONTINUED(status)	// 如果子进程收到SIG_CONT信号而恢复运行, 返回ture,反之false
	使用示例:
		printf("status = %d\n",status);
		if(WIFEXITED(status))
			printf("normal termination,exit status = %d\n",WEXITSTATUS(status));
	(5)如果用户不关心子进程的终止事件，只关心子进程的停止事件，能否使用 waitpid （）明确做到？答案是不行。当 waitpid 返回时，可能是因
       为子进程终止，也可能是因为子进程停止。这是 waitpid 和 wait 的致命缺陷。
⑤等待子进程之waittid（）
	说明:
		waitpid 函数是 wait 函数的超集， wait 函数能干的事情， waitpid 函数都能做到。但是 waitpid 函数的控制还是不太精确，无论用户
		是否关心相关子进程的终止事件，终止事件都可能会返回给用户。 glibc 封装了 waitid 系统调用从而实现了waitid 函数。
		尽管目前普遍使用的是 wait 和 waitpid 两个函数，但是 waitid 函数的设计显然更加合理。

	int waitid(idtype_t idtype, id_t id,siginfo_t *infop, int options);
	  idtype:	
		・idtype==P_PID ：精确打击，等待进程 ID 等于 id 的进程。
		・idtype==P_PGID ：在所有子进程中等待进程组 ID 等于 id 的进程。
		・idtype==P_ALL ：等待任意子进程，第二个参数 id 被忽略。	
	  options:
		・WEXITED ：等待子进程的终止事件。
		・WSTOPPED ：等待被信号暂停的子进程事件。
		・WCONTINUED ：等待先前被暂停，但是被 SIGCONT 信号恢复执行的子进程。	
	 infop: 本质是个返回值，系统调用负责将子进程的相关信息填充到 infop 指向的结构体中。如果成功获取到信息，下面的字段将会被填充：
		・si_pid ：子进程的进程 ID ，相当于 wait 和 waitpid 成功时的返回值。
		・si_uid ：子进程真正的用户 ID 。
		・si_signo ：该字段总被填成 SIGCHLD 。
		・si_code ：指示子进程发生的事件，该字段可能的取值是：	
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx					
【4.8】exec家族
	1.整个 exec 家族有 6 个函数，这些函数都是构建在 execve 系统调用之上的。该系统调用的作用是，将
      新程序加载到进程的地址空间，丢弃旧有的程序，进程的栈、数据段、堆栈等会被新程序替换。	
	2.接口虽然各异，实现的功能却是相同的。
		// 带 p 的表示可以使用环境变量 PATH ，带 e 的表示必须要自己维护环境变量，而不使用当前环境变量
		// 采用列表，它们会罗列所有的参数（l，表示list）
		int execl(const char *path, const char *arg, ...)
		int execlp(const char *file, const char *arg, ...)
		int execle(const char *path, const char *arg,..., char * const envp[])
		
		// 采用数组罗列所有的参数（v，表示vector）
		int execv(const char *path, char *const argv[])
		int execvp(const char *file, char *const argv[])
		int execve(const char *path, char *const argv[],char *const envp[])
	3.使用范例
		char *const ps_argv[] = {"ps","-ax",NULL};
		char *const ps_envp[] = {"PATH=/bin:/usr/bin","TERM=console",NULL};
		
		execl("/bin/ps","ps","-ax",NULL);
		execlp("ps","ps","-ax",NULL);			   /* 带p 的，可以使用环境变量PATH ，无须写全路径*/
		execle("/bin/ps","ps","-ax",NULL,ps_envp); /* 带e 的需要自己组拼环境变量*/
		execv("/bin/ps",ps_argv);			
		execvp("ps",ps_argv);				/* 带p 的，可以使用环境变量PATH ，无须写全路径*/
		execve("/bin/ps",ps_argv,ps_envp);	/* 带e 的需要自己组拼环境变量*/	
	4.执行 exec 之后进程继承的属性	
		1.执行 exec 的进程，其个性虽然叛逆，与过去做了决裂，但是也继承了过去的一些属性。 
		2.exec 运行之后，与进程相关的 ID 都保持不变。如果进程在执行 exec 之前，设置了告警（如调用了 alarm 函数），
		  那么在告警时间到时，它仍然会产生一个信号。在执行 exec 后，挂起信号依然保留。
		3.创建文件时，掩码 umask 和执行 exec 之前一样。

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx					
【4.9】system 函数
①接口
	int system(const char *command);
		command: 需要执行的命令 
		返回值:
			1.当 command 为 NULL 时，返回 0 或 1
			2.创建进程（ fork ）失败，或者获取子进程终止状态（ waitpid ）失败，则返回 -1
			3.如果子进程不能执行 shell ，那么 system 返回值会与 _exit （ 127 ）终止时一样
			4.如果所有的系统调用都执行成功， system 函数就会返回执行 command 的子 shell 的终止状态
	1.程序可以通过调用 system 函数，来执行任意的 shell 命令。
	2.system的效率低
		使用 system 运行命令时，一般要创建两个进程，一个是 shell 进程，另外一个或多个是用于 shell 所执行的命令。
②system 函数与信号
	1.就是调用 system 函数，在 system 返回之前会忽略 SIGINT 和 SIGQUIT ，无论是调用采用终端的操作（ ctrl+c 或 ctrl+\ ），
	  还是采用 kill 来发送 SIGINT 或 SIGQUIT 信号，调用 system 函数的进程都会不动如山。
    2.但是 system 内部创建的执行 command 的子进程，对 SIGINT 和 SIGQUIT 的响应是默认值，也就是说会杀掉响应的子进程而导致 system 函数的返回。
	
##################################################################################
								第5章 进程控制: 状态调度优先级
##################################################################################
	  
进程状态

		 (EXIT_HWAD)			(wait/witpid)			
			死亡态<---父进程回收<--僵尸态(EXIT_ZOMBLE)
									 ↑				|←←1.在main中调用return	
								内核调用do_exit()←-|←←2.执行exit/Exit/_exit()
									 ↑ 			|←←3.最后一个线程执行pthread_exit
	fork/vfork						 ↑				|←←4.被信号杀死(ctrl+c)
		↓	  内核调用sched(调度)	CPU	
		↓	↑→→→→→→→→→→→→执行态
	TASK_RUNING						↓	↓
	(可运行状态)						↓	↓   
		↑	时间片耗光/被强占		↓	↓
		↑←←←←←←←←←-←←←←↓	↓
		↑  睡眠态.挂起态			↓	↓
		↑←←←←←-←←←-←←←←←	↓
		↑							收到停止信号(SIGSTOP/SIGTSTP)
		↑								↓
		↑	收到继续信号(SIGCONT)	  暂停态
		↑←←←←←←←←←←←←←←-←↓
		
##################################################################################
再看书...........
进程间的通讯方式(本地通信,不能联网)
二.无名管道PIPE
	1.在 shell 中执行命令，经常会将上一个命令的输出作为下一个命令的输入，
	  由多个命令配合完成一件事情。而这就是通过管道来实现的
	2. 管道的作用是在有亲缘关系的进程之间传递消息 
		因为, 只有靠世代相传的文件描述符进行通信
	3.只要共同的祖先曾经调用了 pipe 函数，打开的管道文件就会在 fork 之后，被各个后代进程所共享。  
	4.管道中的内容是阅后即焚的, 一个进程读取了管道内的一些内容之后，这些内容就不会继续在管道之中了 
	5.一般来讲管道是单向的。一个进程负责往管道里面写内容，另外一个进程读取管道里的内容  
	6.管道是一种文件，可以调用 read 、 write 和 close 等操作文件的接口来操作管道
	7.成功调用 pipe 函数之后，会返回两个打开的文件描述符，一个是管道的读取端描述符 pipefd[0] ，另一个是管道的写入端描述符 pipefd[1] 
	8. fork 以后，子进程复制了父进程打开的文件描述符两条通信的通道就建立起来了。此时，可以是父进程往管道里写，子进程从管道里面读；也可以是子进程往管道里写，父进程从管道
		里面读。这两条通路都是可选的，但是不能都选。
	9.父进程如何放弃读，子进程又如何放弃写:父进程把读端口 pipefd[0] 这个文件描述符关闭掉，子进程把写端口 pipefd[1] 这个文
		件描述符关闭掉就可以了
##################################################################################
再看书...........
进程间的通讯方式(本地通信,不能联网)
三.有名管道FIFO
	保证原子性操作:
		
	1.基础
		1.无名管道: 这种管道因为没有实体文件与之关联，靠的是世代相传的文件描述符，所以只能应用在有共同祖先的各个进程之间。
		    对于没有亲缘关系的任意两个进程之间，无名管道就爱莫能助了。
		2.FIFO 与管道类似，最大的差别就是有实体文件与之关联。由于存在实体文件，不相关的没有亲缘关系的进程也可以通过使用 FIFO
			来实现进程之间的通信。
		3.与无名管道相比，命名管道仅仅是披了一件马甲，其核心与无名管道是一模一样的。内核的
			fs/fifo.c 文件仅有 153 行，说白了，这简短的代码只干了两件事：
			・ 从外表看，我是一个 FIFO 文件，有文件名，任何进程通过文件名都可以打开我。
			・ 我的内心与无名管道是一样的，支持的文件操作与无名管道也是一样的。
	2.创建FIFO文件
		1.int mkfifo(const char *pathname, mode_t mode); // 管道文件名,权限(777)
		2.mkfifo [-m mode] pathname
		3.mknod [-m mode] pathname p
		创建出来的 FIFO 文件，用 lsCl 来查看，第一个字母是 p ，表示这是命名管道文件。
	3.打开 FIFO 文件
		1.一般的文件操作函数如 open 、 read 、 write 、 close 、 unlink 等都可以用在 FIFO 文件上。
		2.FIFO 文件和普通文件相比，有一个明显的不同：程序不应该以 O_RDWR 模式打开 FIFO 文件。
			POSIX 标准规定，以 O_RDWR 模式打开 FIFO 文件，结果是未定义的。
		3.对 FIFO 文件推荐的使用方法是，两个进程一个以只读模式（ O_RDONLY ）打开 FIFO 文件，另一个以只写模式（ O_WRONLY ）
		    打开 FIFO 文件。这样负责写入的进程写入 FIFO 的内容就可以被负责读取的进程读到，从而达到通信的目的。
		4.在没有进程以写模式（ O_RDWR 或 O_WRONLY ）打开 FIFO 文件的情况下，以
			O_RDONLY 模式打开一个 FIFO 文件时，调用进程会陷入阻塞，直到另一进程以 O_WRONY （或者 O_RDWR ）的标志位打开该 FIFO 文件为止。同
			样的道理，在没有进程以读模式（ O_RDONLY 或 O_RDWR ）打开 FIFO 文件的情况下，如果一个进程以 O_WRONLY 的标志位打开一个 FIFO 文
			件，调用进程也会阻塞，直到另一个进程以 O_RDONLY （或者 O_RDWR ）的标志位打开该 FIFO 文件为止。也就是说，打开 FIFO 文件会同步读取
			进程和写入进程。
		5.FIFO 文件提供了 O_NONBLOCK 标志位，该标志位会显著影响 open 的行为模式。
				当open FIFO 文件的不同情况
			-------------------------------------------------------------------------------
			O_RDONLY			  :当存在以写方式打开这个FIFO的进程时,成功返回;
									当不存在时,一直阻塞
			-------------------------------------------------------------------------------
			O_RDONLY | O_NONBLOCK :当存在以写方式打开这个FIFO的进程时,成功返回;
									当不存在时,不阻塞,返回0
			-------------------------------------------------------------------------------
			O_WRONLY			  :当存在以读方式打开这个FIFO的进程时,成功返回;
									当不存在时,一直阻塞	
			-------------------------------------------------------------------------------
			O_WRONLY | O_NONBLOCK :当存在以读方式打开这个FIFO的进程时,成功返回;
									当不存在时,不阻塞,返回-1
			-------------------------------------------------------------------------------
	4.读写管道文件
		・ 当前管道中存在的字节数 p 。
		・ 是否有 O_NONBLOCK 标志位。
		・ 管道的最大容量 PIPE_BUF(4096) 和要读写的字节数 n 的关系。
				//#define PIPE_BUF        4096
		・ 读写端是否都存在。
		(1)从一个包含p字节的FIFO读取n字节:
		-------------------------------------------------------------------------------
							p=0且存在写入	p=0且所有写入	 	
							端描述符未关闭  端描述都关闭	p<n		   p>=n
		-------------------------------------------------------------------------------
		未启用O_NONBLOCK	阻塞			返回0(EOF)		读取p字节  读取n字节
		-------------------------------------------------------------------------------
		  启用O_NONBLOCK 	失败(EAGAIN)	返回0EOF)		读取p字节  读取n字节
		-------------------------------------------------------------------------------
		
		(2)向FIFO写入n字节	
		-------------------------------------------------------------------------------
								n<=PIPE_BUF				n>PIPE_BUF
		-------------------------------------------------------------------------------
		未启用O_NONBLOCK		空闲区域不足n时阻塞	   空闲区域不足时阻塞,
								等待管道字节流被读走   等待管道字节流被读走,成功是写入n字节
		-------------------------------------------------------------------------------
		  启用O_NONBLOCK 		空闲区域不足n时,		能写多少就多少(<n)
								立刻返回错误			返回实际写入字节数
		-------------------------------------------------------------------------------
特点: 
	1.只能在纯粹的linux环境下创建
	2.与pipe最大的区别是:有实体的管道文件,没有亲缘关系的进程使用FIFO文件来通信
	3.程序退出时创建的管道不会自动删除
	
	
##################################################################################
						第6章  信号
##################################################################################
						
(1)概述
　　1.信号是一种软件中断，用来处理异步事件
　　2.信号的本质是一种进程间的通信，一个进程向另一个进程发送信号
　　3.执行kill -l可查看系统所有的信号
　　4.作用：ctl+c时用来做一些收尾工作:
　　　　　1.删除管道.删除共享内存.删除信号量.删除消息队列..
　　　　　2.进程间通信
(2)信号的生命周期
　　进程之间约定好：如果发生了某件事情T （ trigger ），就向目标进程（ destination　　 process ）
　　发送某特定信号 X ，而目标进程看到 X ，就意识到 T 事件发生了，目标进程就会执行相应的动作 A （ action ）
　　1.Linux 内核收到了产生的信号，然后就在目标进程的进程描述符里记录了一笔：收到信号一枚。
	2.Linux 内核会在适当的时机，将信号递送（ deliver ）给进程。
　　3.在内核收到信号，但是还没有递送给目标进程的这一段时间里，信号处于挂起状态，也称为未决信号。
　　4.内核将信号递送给进程，进程就会暂停当前的控制流，转而去执行信号处理函数。
　　5.实际情况还应该考虑的问题
　　　　1.目标进程正在执行关键代码，不能被信号中断，需要阻塞某些信号
　　　　2.如何处理重复的信号，排队还是丢弃？
　　　　3.已有多个不同的信号被挂起，应该优先递送哪个信号？
　　　　4.对于多线程的进程，如果向该进程发送信号，应该由哪个线程来负责响应？
(3)信号的产生
　　[1] 硬件异常
　　　　1.硬件检测到了错误并通知内核，由内核发送相应的信号给相关进程
　　　　2.常见硬件异常的信号
　　　　　　SIGBUS: 总线异常
　　　　　　SIGFPE:	算数错误
　　　　　　SIGILL: 非法及其指令
　　　　　　SIGSEGV: 段错误
　　　　　　　　进程访问未初始化的指针或 NULL 指针指向的地址
　　　　　　　　进程在用户态访问内核部分的地址	
　　　　　　　　进程修改只读的内存地址
　　[2] 终端相关的信号
　　　　・Ctrl+C ：产生 SIGINT 信号。
　　　　・Ctrl+\ ：产生 SIGQUIT 信号。
　　　　・Ctrl+Z ：产生 SIGTSTP 信号。
　　　　键入这些信号生成字符，相当于向前台进程组发送了对应的信号。
　　[3] 软件事件相关的信号
　　　　・ 子进程退出，内核可能会向父进程发送 SIGCHLD 信号。
　　　　・ 父进程退出，内核可能会给子进程发送信号。
　　　　・ 定时器到期，给进程发送信号。
(4)信号默认处理函数
　　[1]信号的默认操作
　　　　・ 显式地忽略信号:ignore
　　　　・ 终止进程:terminate
　　　　・ 生成核心转储文件并终止进程(用于调试):core
　　　　・ 停止进程(暂停进程):stop
　　　　・ 恢复进程的执行: continue
(5)信号的分类
　　[1]不可靠信号	
		1.信号值在 [1，31] 之间的所有信号，都被称为不可靠信号
		2.不可靠信号是从传统的 Unix 继承而来的
		3.如果收到某不可靠信号，内核发现已经存在该信号处于未决状态，
		  就会简单地丢弃该信号。因此发送不可靠信号，信号可能会丢失，
　　[2]可靠信号
　　　　1.在 [SIGRTMIN，SIGRTMAX] 之间的信号，被称为可靠信号
　　　　2.内核内部有队列来维护，如果多次收到可靠信号，内核会将信号挂到相应的队列中，因此不会丢失。
(6)传统信号(System V风格)
　　[1]在相同的 Linux 平台上，由于 glibc 版本的差异，提供的 signal 函数的语义也有差异。
　　　　	在早期的 libc4 和 libc5 中， signal 函数的语义是 Syetem V 风格的。因此，从可移植的角度来看，不应该使用 signal 函数。
　　[2]信号执行时屏蔽自身的特性
　　　　1.对于传统的 System V 信号机制，在信号处理期间，不会屏蔽对应的信号，而这就会引起信号处理函
　　　　　数的重入。
　　　　2.System V 风格的信号，在其信号处理期间没有屏蔽任何信号，换句话说，执行信号处理函数期间，
　　　　　处理流程可以被任意信号中断，包括正在处理的信号。
　　[3]信号中断系统调用的重启特性
　　　　1.系统调用在执行期间，很可能会收到信号，此时进程可能不得不从系统调用中返回，去执行信号处理函数
　　　　2.对于执行时间比较久的系统调用（如 wait 、 read 等）被信号中断的可能性会大大增加。
　　　　3.系统调用被中断后，一般会返回失败，并置错误码为 EINTR
　　　　4.如果程序员希望处理完信号之后，被中断的系统调用能够重启，则需要通过判断 errno 的值来解决，
　　　　　即如果发现错误码是 EINTR ，就重新调用系统调用。
(7)signal---kill.raise.alarm(信号安装和发送)
　　[1]signal函数(安装信号)
　　　　typedef void (*sighandler_t)(int);
　　　　sighandler_t signal(int signum, sighandler_t handler);
　　　　返回值: sighandler_t类型的函数指针
　　　　形参:   int, sighandler_t类型函数指针
　　　　　　void (*signal(int signum, sighandler_t handler))(int);
　　　　使用例子１：
	　　　　int sig_int(int sig) {printf("sig_int");}
	　　　　signal(SIGINT, sig_int);
　　　　使用例子2：
　　　　　	 signal(SIGINT, SIG_IGN);	// 忽略SIGINT信号
	 　　　　signal(SIGINT, SIG_DFL);	// 对于SIGINT信号,使用默认处理函数
　　　　==>写法二: void (*signal(int signum, void (*handler)(int)))(int);		
　　[2]kill函数(和signal搭配)
	　　int kill(pid_t pid, int sig);
	　　　・pid ＞ 0 ：发送信号给进程 ID 等于 pid 的进程。
	　　　・pid ＝ 0 ：发送信号给调用进程所在的同一个进程组的每一个进程。
	　　　・pid ＝ -1 ：有权限向调用进程发送信号的所有进程发出信号， init 进程和进程自身除外。
	　　　・pid ＜ -1 ：向进程组 -pid 发送信号。
	　　　当函数成功时，返回 0 ，失败时，返回 -1 ，并置 errno
	　　　1. kill 函数不仅可以向特定进程发送信号，也可以向特进程组发送信号
	　　　2. 所有信号值都是>0的。 若第二个参数 signo的值为0，这种情况下，来检测目标进程或进程组是否存在，
	　　　　如果 kill 函数返回 -1 且 errno 为 ESRCH ，则可以断定我们关注的进程或进程组并不存在
	[3]raise函数
		int raise(int sig);
	　　　向进程自身发送信号的接口
	　　int raise(int sig);
	　　1.单线程的程序而言
	　　　　相当于:kill(getpid(),sig)
	　　2.对于多线程的程序而言
	　　　相当于:pthread_kill(pthread_self(),sig) // 给当前线程发信号
	[4]alarm函数(闹钟)
		unsigned int alarm（unsigned int seconds);
		描述: 每隔5s给当前进程发送一个SIGALRM信号。
			alarm也称为闹钟函数，它可以在进程中设置一个定时器，当定时器指定的时间到时，它向进程发送SIGALRM信号。
			可以设置忽略或者不捕获此信号，默认动作是终止调用该alarm函数的进程。
		成功：如果调用此alarm（）前，进程已经设置了闹钟时间，则返回上一个闹钟时间的剩余时间，否则返回0。
		出错：-1
(8)sigaction---sigqueue(信号的发送和安装)
	[1]sigqueue(发送信号)
		int sigqueue(pid_t pid, int sig, const union sigval value);
		参数: pid:	 要发送信号的进程ID
			  sig: 	 要发送的信号
			  value: 发送的伴随数据,该参数的数据类型是联合体
				union sigval {
					int sival_int;
					void *sival_ptr;	// 几乎不用(每个进程都有独立的地址空间)
				};
			//考虑到不同的进程有各自独立的地址空间，传递指针到另一个进程几乎没有任何意义。因此 sigqueue 函数很少传递指针（ sival_ptr ），大多是传递整型（ sival_int ）。	
		1.传统的信号多用 signal/kill 这两个函数搭配
		2.signal函数的表达力有限，控制不够精准;所以引入了sigqueue函数来完成实时信号的发送
		3.sigqueue函数也可以发送空信号（信号0）来检查进程是否存在。
		4.和 kill 函数不同的地方在于，它不能通过将pid指定为负值而向整个进程组发送信号。
	[2]	sigaction(安装信号)
		int sigaction(int signum, const struct sigaction *act,struct sigaction *oldact);
		1.参数: signum: 信号编号
			1.struct sigaction {	// 第二个参数
				union {
					void (*sa_handler)(int);//sa_flags里没有设置SA_SIGINFO标记的信号处理函数
					//sa_flags里设置了SA_SIGINFO标志, 的信号处理函数
					void handle(int signum, siginfo_t *info, void *ucontext);
					// 收到的额外数据保存在info->si_value中的si_int和si_ptr中
				}
				sigset_t sa_mask;			// 阻塞信号集
				int sa_flags;				// 标志
				void (*sa_restorer)(void);	// 恢复处理程序
			};		
			2.siginfo_t {	 // handle信号处理函数的第二个参数	
				int si_signo; // 信号的值
				int si_code;  // 信号来源:SI_USER.SI_TKILL.SI_QUEUE.. 
				pid_t si_pid;	// 信号发送进程的进程 ID 。
				uid_t si_uid;   //信号发送进程的真实用户 ID 。
				union sigval si_value; //sigqueue 函数发送信号时所带的伴随数据。
				...
			}
			3.ucontext是 void* 类型的，其实它是一个 ucontext_t 类型的变量。
				这个结构体提供了进程上下文的信息，用于描述进程执行信号处理函数之前进程所处的状态。
				通常情况下信号处理函数很少会用到这个变量
			4. sa_flags的含义
				1.SA_NOCLDSTOP
					一旦父进程为SIGCHLD信号设置了这个标志位，那么子进程停止和子进程恢复这两件事情，就不会向父进程发送SIGCHLD信号了
						但是子进程切换为SIGCONT时还是会给父进程发送SIGCHLD信号。
				2.SA_NOCLDWAIT
					如果父进程为SIGCHLD设置了SA_NOCLDWAIT 标志位，那么子进程退出时，就不会进入僵尸状态，而是直接自行了断。
					对于Linux而言，子进程转换切换为SIGSTOP.SIGCONT.SIGKILL时都会给父进程发送SIGCHLD信号。这点和上面的 SA_NOCLDSTOP 略有不同。
				3.SA_ONESHOT 和 SA_RESETHAND
					这两个标志位的本质是一样的，表示信号处理函数是一次性的，信号递送出去之后，信号处理函数便恢复成默认值 SIG_DFL 。
				4.SA_NODEFER 和 SA_NOMASK
					这两个标志位的作用是一样的，在信号处理函数执行期间，不阻塞当前信号。
				5.SA_RESTART
					这个标志位表示，如果系统调用被信号中断，则不返回错误，而是自动重启系统调用
				6.SA_SIGINFO
					没有设置SA_SIGINFO:
						跟signal使用方法相同, 使用一个参数的信号处理函数
						void (*sa_handler)(int);
					设置了SA_SIGINFO:
						1.这个标志位表示信号发送者会提供伴随数据。这时使用带3个参数的信号处理函数
							void handle(int, siginfo_t *info, void *ucontext);	
						2.能获取到发送进程的PID、UID.信号来源.及发送的额外信息...
		2.注意
			1.对SIGKILL 和 SIGSTOP，不可以为它们安装信号处理函数，也不能屏蔽掉这些信号。
				若通过 sigaction 强行给 SIGKILL 或 SIGSTOP 注册信号处理函数，则会返回-1，并置errno为EINVAL。	
(10)线程的阻塞信号集　　　　　　
	[1]概述
		1.信号集: 数据类型为 sigset_t,sigset_t 的类型是位掩码，每一个比特代表一个信号。	
		2.SIGKILL 信号和 SIGSTOP 信号不能被阻塞。(设置信号集时会被内核剔除)（避免出现神仙进程）
		3.对于多线程：
			// 信号与线程的关系
			POSIX 标准: 
			0.给线程发送信号用pthread_kill()
			1.信号处理函数必须在多线程进程的所有线程之间共享，但是每个线程要有自己的挂起信号集合和阻塞信号掩码。
			2.POSIX 函数 kill/sigqueue 必须面向进程，而不是进程下的某个特定的线程。
			3.每个发给多线程应用的信号仅递送给一个线程，这个线程是由内核从不会阻塞该信号的线程中随意选出来的。
			4. 如果发送一个致命信号到多线程，那么内核将杀死该应用的所有线程，而不仅仅是接收信号的那个线程。
		
	[2]常用API
		int sigemptyset(sigset_t *set);	// 初始化信号集set中的信号为空
		int sigfillset(sigset_t *set);  // 将所有信号添加进信号集set
		int sigaddset(sigset_t *set, int signum); // 在信号集中添加signum信号
		int sigdelset(sigset_t *set, int signum); // 在信号集中删除signum信号
		int sigismember(const sigset_t *set, int signum); // 判断signum是否存在于set信号集中
		int sigprocmask(int how, const sigset_t *set, sigset_t *oldset); // 设置调用进程的阻塞信号集
			oldset: 如果oldset为非NULL，则信号掩码的先前值存储在oldset中,故一般设置为NULL。
			how的选项:
				SIG_BLOCK:   在当前阻塞信号集中增加set信号集中的信号
				SIG_UNBLOCK：在当前阻塞信号集中删除set信号集中的信号
				SIG_SETMASK：阻塞信号集被设置为set信号集。
	[3]pthread_sigmask(int how, const sigset_t *set, sigset_t *oldset);
		1.为了更显式地设置线程的阻塞信号掩码，线程库提供了 pthread_sigmask 函数来设置线程的阻塞信号掩码。
		2.事实上 pthread_sigmask 函数和 sigprocmask 函数的行为是一样的。
			pthread_sigmask函数将调用sigprocmask函数（内核源码）
	[4]注意
		1.如果阻塞了某个信号A, 然后调用pause。在程序的执行过程中如果一直给进程发送信号A,
			pause函数将不会返回， 因为线程收不到信号A。
		2.对于信号集中阻塞的不可靠信号a, 在阻塞过程中, 发送多个信号a时,之前挂起的信号a会被抛弃;
		   解除阻塞后, 最终发送到目标进程的信号a只有一个。
		3.对于信号集中阻塞的可靠信号b,在阻塞过程中, 发送多个信号a时,会创建一个队列来管理阻塞的信号;
		   解除阻塞后, 最终发送到目标进程的信号b = 信号b的发送次数。
		4.SIGKILL 信号和 SIGSTOP 信号不能被阻塞。(设置信号集时会被内核剔除)
(1)线程的阻塞信号集　
　　int pthread_sigmask(int how, const sigset_t *set, sigset_t *oldset);
			oldset: 如果oldset为非NULL，则信号掩码的先前值存储在oldset中,故一般设置为NULL。
			how的选项:
				SIG_BLOCK:   在当前阻塞信号集中增加set信号集中的信号
				SIG_UNBLOCK：在当前阻塞信号集中删除set信号集中的信号
				SIG_SETMASK：阻塞信号集被设置为set信号集。
(11)SIGCHID信号
	1.父进程可以监测子进程的以下三种事件; 每次状态改变,子进程会发SIGCHID给父进程
		・ 子进程终止（即子进程死亡）
		・ 子进程停止（即子进程暂停）
		・ 子进程恢复（即子进程从暂停中恢复执行）
	2.若使用sigaction---sigqueue(信号的发送和安装)
		1.sigaction使用了宏SA_NOCLDSTOP:
			一旦父进程为SIGCHLD信号设置了这个标志位，那么子进程停止和子进程恢复这两件事情，就不会向父进程发送SIGCHLD信号了。
				但是子进程切换为SIGCONT时还是会给父进程发送SIGCHLD信号。
		2.sigaction使用了宏SA_NOCLDWAIT:
			如果父进程为设置了SA_NOCLDWAIT 标志位，或者显示的忽略SIGCHLD信号。那么子进程退出时，就不会进入僵尸状态，而是直接自行了断。
			对于Linux而言，子进程转换切换为SIGSTOP.SIGCONT.SIGKILL时都会给父进程发送SIGCHLD信号。
(12)信号的练习
    信号示例: (通过信号模拟 <司机--售票员>)
	1.平常司机在车上休息,售票员在观察上车人数
	2.售票员发现车上人满了就提醒司机发车
	3.中途停两个站: 9km. 15km处, 这时售票员要提醒司机
	6.总里程20公里
	7.到终点站后司机提醒售票员让所有乘客下车
	8.售票员退出后, 司机才能退出
(13)信号与线程的关系
	POSIX 标准: 
	0.给线程发送信号用pthread_kill()
	1.信号处理函数必须在多线程进程的所有线程之间共享，但是每个线程要有自己的挂起信号集合和阻塞信号掩码。
	2.POSIX 函数 kill/sigqueue 必须面向进程，而不是进程下的某个特定的线程。
	3.每个发给多线程应用的信号仅递送给一个线程，这个线程是由内核从不会阻塞该信号的线程中随意选出来的。
	4. 如果发送一个致命信号到多线程，那么内核将杀死该应用的所有线程，而不仅仅是接收信号的那个线程。
(14)定时器与信号(glibc定时器timer)
	(0)注意:
		alarm()函数和setitimer()函数都不能用于多线程中对子线程定时。因为即使信号函数在子线程中
		安装，即使定时器在子线程中初始化；当信号产生时，并不能保证子线程一定能捕捉到这个信号。
	(1)unsigned int alarm（unsigned int seconds);
		0.成功：如果调用此alarm（）前，进程已经设置了闹钟时间，则返回上一个闹钟时间的剩余时间，否则返回0。
		1.在进程中设置一个定时器，当定时器指定的时间到时，它向进程发送SIGALRM信号
		2.默认方式其动作是终止调用该alarm函数的进程。
		3.一个进程只能有一个闹钟时间，如果在调用alarm之前已设置过闹钟时间，则任何以前的闹钟时间都被新值所代替。
		4.需要注意的是，经过指定的秒数后，信号由内核产生，由于进程调度的延迟，所以进程得到控制从而能够处理该信号还需要一些时间。
	(2)int setitimer(int which, const struct itimerval *value, struct itimerval *ovalue);
		which为定时器类型:
			ITIMER_REAL: 以系统真实的时间来计算，它送出SIGALRM信号。
			ITIMER_VIRTUAL: -以该进程在用户态下花费的时间来计算，它送出SIGVTALRM信号。
			ITIMER_PROF: 以该进程在用户态下和内核态下所费的时间来计算，它送出SIGPROF信号。
		value:  是结构itimerval的一个实例
			struct timeval {
				long tv_sec;	// tv_sec提供秒级精度
				long tv_usec;	// tv_usec提供微秒级精度，以值大的为先，注意1s = 1000000us。
			};		
			struct itimerval {
				struct timeval it_interval; // 指定间隔时间。
				struct timeval it_value;	// 指定初始定时时间
			};	
			1.如果只指定it_value，就是实现一次定时；		
			2.如果同时指定 it_interval，则超时后，系统会重新初始化it_value为it_interval，实现重复定时；
			3.两者都清零，则会清除定时器。
			4.如果用ITIMER_REAL宏, 将覆盖alarm函数设置的定时器
		ovalue: 用来保存先前的值，常设为NULL。
		
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx		
【15】等待信号
①等待任意信号到来
	pause函数
	　　作用：使调用进程（线程）进入休眠状态（就是挂起）；直到接收到信号且信号函数成功返回
②等待某个特定的信号
	int sigsuspend(const sigset_t *mask);
	int sigwait(const sigset_t *set, int *sig);
	int sigwaitinfo(const sigset_t *set, siginfo_t *info);
	int sigtimedwait(const sigset_t *set, siginfo_t *info,	const struct timespec *timeout);	
	使用示例：
		sigset_t mask = 0;
		int sig;
		sigemptyset(&mask);
		sigaddset(&mask,SIGUSR1);
		sigprocmask(SIG_SETMASK,&mask,NULL);
		sigwait(&mask, &sig);
		
yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy
						第7章.理解Linux线程(1)
yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy
【1】线程与进程的区别与优缺点
	[1]进程
		1.每创建一个进程,内核都会给这个进程分配资源（内存.cpu...）。
		2.进程是系统分配资源的最小单位。
		3.进程之间，彼此的地址空间是独立的(每个进程都有自己独立的虚拟地址空间)
	[2]线程	
		1.同一个进程的多个线程共享一份全局内存区域(多个线程同属于同一个进程)
		2.线程是系统调度的最小单位
		3.线程是轻量级的进程（因为每个线程都存在一个进程描述符task_struct）
	[3]线程和进程的关系
			 [ 线 ]		|			[ 线 线 线 ]	
			 [ 程 ]		|			[ 程 程 程 ]
			 [ 0  ]		|			[ 0  1  2  ]
			单线程进程  	|			  多线程进程
	--------------------------------------------------------fork()/vfork()	
		 [ 线 ]	[ 线 ]	| 	[ 线 线 线 ]	 	[ 线 线 线 ]	 	
		 [ 程 ]	[ 程 ]	|	[ 程 程 程 ]		[ 程 程 程 ]
		 [ 0  ] [ 0  ]	|	[ 0  1  2  ]		[ 0  1  2  ]
		 多个单线程进程	|		 	多个多线程进程
						|	
	[4]为什么需要多线程
		1.好比去银行办理业务,你一定希望，办理业务的窗口越多越好。如果把整个营业大厅当成一个进程的话，那么每一个窗口就是一个工作线程。
		2.  Master-worker并发模型
			---------------------------------------------------------------------
			Master线程→创建线程		[请求] [请求] [请求]...	// 排队等待区
						  ↓	
						worker线程 	[请求] 
						  ↓
						worker线程	[请求]
						  ↓
						worker线程	[请求]
			---------------------------------------------------------------------
	[5]多线程共享资源带来的优势
		1.创建线程花费的时间要少于创建进程。
		2.终止线程花费的时间要少于终止进程。
		3.线程之间上下文切换的开销，要小于进程之间的上下文切换 。// 上下文: 不同线程/进程之间
		4.线程之间数据的共享比进程之间的共享要简单。
		5.线程之间通信的代价低于进程之间通信的代价。 //部门内的协作总是要比跨部门的协作来得顺溜
		6.发挥多核优势，充分利用CPU资源 // 单进程的排队模式可能导致CPU资源浪费,而任务还不能快速处理
		7.更自然的编程模型:将工作切分成多个模块，并为每个模块分配一个或多个执行单元。
	[6]多线程的缺点
		1.要有一个线程不够健壮存在bug,就会导致进程内的所有线程一起完蛋。
		2.线程模型作为一种并发的编程模型，效率并没有想象的那么高，会出现复杂度高、易出错、难以测试和定位的问题
		3.多个线程之间需要同步：
			・比如： 一个公寓，当你朋友正在使用卫生间的时候，你就无法使用了。
			・若存在多个线程操作共享资源，则需要同步，否则可能会出现结果错误、数据结构遭到破坏甚至是程序崩溃等后果。
			・因此多线程编程中存在临界区的概念，临界区的代码只允许一个线程执行，线程提供了锁机制来保护临界区。
			・当其他线程来到临界区却无法申请到锁时，就可能陷入阻塞，不再处于可执行状态，线程可能不得不让出 CPU 资源。
		4.多线程的四大陷阱
			・ 死锁（Dead Lock）
			・ 饿死（Starvation）
			・ 活锁（Live Lock）
			・ 竞态条件（Race Condition）
	[7]总结
		多进程属于立体交通系统，虽然造价高，上坡下坡比较耗油，但是堵车少；
		多线程属于平面交通系统，造价低，但是红绿灯太多，老堵车。
			立体:	进程间地址空间互相独立
			造价高: fork后copy父进程资源
			耗油:	通行前创建: 管道.FIFO.共享内存.消息队列.信号量
			堵车少: 通信顺畅, 不受其他进程影响
			平面:   多个线程共享该进程所有资源
			造价低: 不用去拷贝资源, 仅共享
			灯太多: 各种锁, 访问控制
			老堵车: 多个资源抢夺锁去访问临界资源, 难获得锁。
##################################################################################
【2】线程ID与线程ID(进程调度范畴的标识)		
	[1]NPTL标准
		1.目前的线程实现是 Native POSIX Thread Library，简称NPTL 。
		2.线程又被称为轻量级进程。
		3.每一个用户态的线程，在内核之中都对应一个调度实体也拥有自己的进程描述符（task_struct结构体）
		4.进程内的所有线程调用 getpid 函数时返回相同的进程ID。
	[2]线程组
		struct task_struct {...	// 线程组中线程的进程描述符
			pid_t pid;							// 线程ID
			pid_t tgid;							// 进程ID
			struct task_struct *group_leader;	// 主线程的进程描述符
			struct list_head thread_group;		// 线程的进程描述符链表
		1.多线程的进程，被称为线程组。
		2.线程组内的每一个线程在内核之中都存在一个进程描述符task_struct与之对应。
		3.获取线程ID和进程ID
			1.gettid()	// 获取线程ID	
			2.getpid()  // 获取进程ID
			3.ps -eLf	// 查看系统的所有进程和线程
				LWP:线程ID,  NLWP:线程组内线程的个数。
			4.通过/proc/PID/task查看
			5.glibc没有实现gettid(), 若需进程ID,可采用:
				int TID = syscall(SYS_gettid)	// 系统调用
			6.线程组ID = 主线程ID = 进程ID	
	[3]强调
		1.线程和进程不一样，进程有父进程的概念，但在线程组里面，所有的线程都是对等的关系
		2.并不是只有主线程才能创建线程，被创建出来的线程同样可以创建线程。
		3.不存在类似于fork函数那样的父子关系，大家都归属于同一个线程组，进程ID都相等，group_leade 都指向主线程，而且各有各的线程 ID 。
		4.并非只有主线程才能调用 pthread_join 连接其他线程，同一线程组内的任意线程都可以对某线程执行pthread_join函数
		5. 并非只有主线程才能调用 pthread_detach 函数，其实任意线程都可以对同一线程组内的线程执行分离操作
##################################################################################
【3】pthread库接口介绍
	----------------------------------------------------------------------
	POSIX函数						功能
	----------------------------------------------------------------------
	pthread_create				 创建一个线程	
	pthread_exit				 退出线程				
	pthread_self				 获取线程ID				
	pthread_equal				 检查两个线程ID是否相等						
	pthread_join				 等待线程退出			
	pthread_detach				 设置线程状态为分离状态						
	pthread_cancel				 线程的取消									
	pthread_cleanup_push		 线程退出, 注册清理函数							
	pthread_cleanup_pop			 线程退出, 执行清理函数		
	----------------------------------------------------------------------
##################################################################################
【4】线程的创建、标识ID
	[1]int pthread_create(pthread_t *restrict thread,
			const pthread_attr_t *restrict attr,
			void *(*start_routine)(void*),
			void *restrict arg);
	  thread: 线程创建成功的话，会将分配的线程ID填入该指针指向的地址。
			线程的后续操作将使用该值作为线程的唯一标识。
	  attr:   定制线程的属性, 如果创建线程无特殊的要求，该值也可以是 NULL ，表示采用默认属性。
	  start_routine: 子线程执行函数
	  arg:    创建线程传给新建线程得我参数, 可以是任意结构的指针
	  如果成功，返回0 ；如果不成功，错误码(可能>0)。
	[2]多线程进程的地址空间
			|--------------------|	
		|	|	内核空间			 |	
		|	|--------------------|	
		|	|--------------------|	
		|	| 主线程的栈(statck) |	
		从	|--------------------|
			|					 |		 |-------→共享内存库			
		高	|--------------------|		 |		   线程栈1
		地	|	mmap区域		 |-------|		   线程栈2
		址	|--------------------| 		 |-------→线程栈3
		到	|	空白区			 |		 
		低	|--------------------|
		地	|	堆(heap)		 |			
		址	|--------------------| 
		|	|--------------------|
		|	|	bss				 |	
		|	|--------------------|
		|	|	data			 |	
		|	|--------------------| 
		|	|	text			 |
		↓	|--------------------|
		1.调用 pthread_create函数时，glibc首先要为线程分配线程栈，而线程栈的位置就落在mmap区域。
		2.glibc会调用mmap函数为线程分配栈空间。
		3.pthread_create函数分配的线程标识ID, 是分配出来的空间里的一个结构体的指针。
			==》线程 ID 的本质是内存地址
			pthread_t tid---→ struct pthread {
							     线程局部存储
							     线程栈
								};
	[3]线程标识ID(pid_t)与线程ID(pthread_t)
		1.pthread_t pthread_self(void); //获取到线程自身的标识ID
		2.线程的标识ID与线程ID(pid_t)不同
			1.线程ID,属于进程调度的范畴。用来唯一标识该线程。
			2.线程的标识ID属于NPTL线程库范畴。 线程库的后续操作，将根据线程标识ID来操作线程。
		3.int pthread_equal(pthread_t t1, pthread_t t2); // 判断两个线程的标识符ID是否对应着同一个线程
			返回值是 0 的时候，表示两个线程是同一个线程，非零值则表示不是同一个线程。
		4.不同线程组内的两个线程，哪怕两者的 pthread_t值是一样的，也不是同一个线程，这是显而易见的。
		5.在满足下列条件时，线程ID就有可能会被复用：
			1.线程退出。
			2.程组的其他线程对该线程执行了 pthread_join，或者线程退出前将分离状态设置为已分离
			3.再次调用 pthread_create创建线程。
		6.如果要设计调试日志，用 pthread_t 类型的线程 ID 来标识进程就不太合适了。用pid_t类型的线程ID则是一个比较不错的选择。
			int TID = syscall(SYS_gettid);
			
	[4]pid_t类型的线程ID来唯一标识进程有以下优势:
		1.进程之间不会存在重复的线程 ID ，而且不同线程之间也不会重复，在任意时刻都是全局唯一的值。
		2.可以方便地查看 /proc/pid/task/tid 来获取线程对应的信息。
		3.ps 命令提供了查看线程信息的 -L 选项，可以通过输出中的 LWP 和 NLWP ，来查看同一个线程组的线程个数及线程 ID 的信息。
		4.可以给线程起一个有意义的名字，命名以后，既可以从procfs中获取到线程的名字，也可以从ps命令中得到线程的名字，这样就可以更好地辨识不同的线程。
			int prctl(int option, ul arg2,ul arg3 , ul arg4,ul arg5)   //ul: unsigned long
				1.将 option 设为 PR_SET_NAME ，		
				2.将线程的名字作为arg2传递给prctl系统调用
				3.其余参数为NULL
				4.用ps命令来查看线程的名字: ps -L -p pid
				5.在系统中查看线程名字
					cat /proc/pid/task/tid/status
			//这是一个很有用的技巧。给线程命了名，就可以很直观地区分各个线程，尤其是在线程比较多，且其分工不同的情况下。
##################################################################################
【5】线程的属性
	①线程创建的默认属性
		-------------------------------------------------------------------------------------------------------------
			属性					默认值							说明
		-------------------------------------------------------------------------------------------------------------
			contentionscope		PTHREAD_SCOPE_SYSTEM		进程调度相关, NPTL中,线程只支持在操作系统范围内竞争CPU资源
		-------------------------------------------------------------------------------------------------------------
			detachstate			PTHREAD_CREATE_JOINABLE		可分离状态
		-------------------------------------------------------------------------------------------------------------
			stachaddr			NULL						不指定线程栈的基址, 由系统决定栈基址
		-------------------------------------------------------------------------------------------------------------
			statcksize			8196(KB)					默认线程栈大小8M(ulimit -s查看)
		-------------------------------------------------------------------------------------------------------------
			guardsize			PAGESIZE					警戒缓冲区
		-------------------------------------------------------------------------------------------------------------
			pripority			0							进程调度相关, 优先级为0
		-------------------------------------------------------------------------------------------------------------
			policy				SCHED_OTHER					进程调度相关, 策略为SCHED_OTHER
		-------------------------------------------------------------------------------------------------------------
			inheritsched		PTHREAD_INHERIT_SCHED		进程调度相关,继承启动进程的调度策略
		-------------------------------------------------------------------------------------------------------------
			1.默认情况下，线程栈的大小为 8MB (ulimit -s)
			2.调用 pthread_attr_getstack 函数可以返回线程栈的基地址和栈的大小。	
			3.出于可移植性的考虑不建议指定线程栈的基地址。
			4.可以调用接口来调整线程栈的大小：
				int pthread_attr_setstacksize(pthread_attr_t *attr,size_t stacksize);
				int pthread_attr_getstacksize(pthread_attr_t *attr,size_t *stacksize);
	②线程的调度属性
			[1]优先级介绍
				1.静态优先级：0～99。0用于非实时线程， 1～99用于实时线程。
					1.数值越大优先级越高
					2.只要你不强行使用相关函数修改他，他不会随着线程的执行而发生改变。
				2.动态优先级（nice）：跟静态优先级是0的非实时线程有关，-20到19。数值越大，优先级越低。
					1.它会随着线程的运行，根据线程的表现而发生改变。
					2.“CPU 消耗型”线程的动态优先级会被慢慢地降级，nice值会下降。（比如视频解码器）
					3.“IO消耗型”线程，这类线程绝大部分的时间都在睡眠，他的nice值会不断的增加。（比如编辑器）
					4.“爱叫的孩子有奶喝”：越是不nice的进程越有CPU优先使用权(也就是优先级高咯)。
			[2]实时线程的调度: (静态优先级 + 调度策略)
				调度策略:
					SCHED_FIFO：即先进先出，它没有时间片的概念，只要没有更高优先级的线程程就绪，使用该调度策略的进程就会一直执行。
					SCHED_RR ：情况跟 SCHED_FIFO 是一样的，区别在于：每一个 SHCED_RR 策略下的线程都将会被分配一个额度的时间片，当时间片耗光时，他
								会被放入其所在优先级队列的队尾的位置。
			[3]非实时普通线程的调度: (动态优先级（nice） + 调度策略)
				动态优先级：-20到19。数值越大，优先级越低。“爱叫的孩子有奶喝”。
				调度策略：
					SCHED_OTHER：隶属于完全公平调度，大多数进程都是属于 SCHED_OTHER 的调度策略。
						1.nice 值在 -20~19 范围内的进程，都是属于 SCHED_OTHER 的调度策略。
						2.当线程的调度策略为 SCHED_OTHER 时，其静态优先级（static priority）必须设置为 0。该调度策略是 Linux 系统调度的默认策略。
					SCHED_BATCH：隶属于完全公平调度，指定内核不需要根据休眠时间更改优先级。
					SCHED_IDLE： 隶属于完全公平调度，比nice值为 19 的进程的优先级还要低。
			[4]常用API
				1.获取、设置线程是否继承创建者的调度策略。
					int pthread_attr_setinheritsched(pthread_attr_t *attr,int inheritsched);
					int pthread_attr_getinheritsched(pthread_attr_t *attr,int *inheritsched);
						attr: 线程属性变量。
						inheritsched:
							PTHREAD_INHERIT_SCHED 继承创建者的调度策略。
							PTHREAD_EXPLICIT_SCHED 使用属性变量中的调度策略。
				2.获取、设置线程的调度策略
					int pthread_attr_setschedpolicy(pthread_attr_t *attr, int policy);
					int pthread_attr_getschedpolicy(pthread_attr_t *attr, int *policy);
						attr: 线程属性变量。
						policy:
						SCHED_FIFO: 以先进先出的排队方式调度。
						SCHED_RR:   以轮转的方式调度。
						SCHED_OTHER: 非实时调度的普通线程。	
				3.获取、设置线程静态优先级	
					int pthread_attr_setschedparam(pthread_attr_t *attr,const struct sched_param *param);
					int pthread_attr_getschedparam(pthread_attr_t *attr,struct sched_param *param);		
						attr: 线程属性变量
						param: 静态优先级：0 到 99。
				4.获取、设置线程动态优先级
					int nice(int inc);
					inc： 动态优先级，-20 到 19。
	③线程的可分离属性设置
		创建线程时, 将线程的属性设定为已分离(创建已分离线程) // 线程退出后, 系统自动回收资源
		pthread_attr_setdetachstate(&attr,PTHREAD_CREATE_DETACHED);
		// 获取.设置线程分离状态
		int pthread_attr_setdetachstate(pthread_attr_t *attr,int detachstate);
		int pthread_attr_getdetachstate(pthread_attr_t *attr,int *detachstate);	
	④线程属性变量的使用步骤是：	
			1，定义线程属性变量，并且使用 pthread_attr_init( )初始化。
			2，使用 pthread_attr_setXXX( )来设置相关的属性。
			3，使用该线程属性变量创建相应的线程。
			4，使用 pthread_attr_destroy( )销毁该线程属性变量。
	⑤线程还有一些其他属性, 日常开发很少设置, 如果要设置,设置步骤跟上面套路一样
##################################################################################
【6】线程的退出
	①线程退出的方法:
		1.创建线程时的tart_routine()函数内执行了return()，并且返回指定值。
		2.线程调用 pthread_exit()
		3.其他线程调用了pthread_cancel()函数取消了该线程(详见第8章)
		注意: 线程组中的任何一个线程调用了exit()函数，或者主线程在main()函数中执行了 return 语句，
			那么整个线程组内的所有线程都会终止。
			
	②pthread_exit(void *value_ptr)
		value_ptr: 存放线程的“临终遗言”,线程组内的其他线程可以通过调用pthread_join()函数接收这个地址,可以直接传递NULL指针	
		1.线程却调用pthread_exit函数退出了那么主线程将进入僵尸状态.
	③安全的传递线程退出的返回值
		1.不能将遗言存放到线程的局部变量里，因为如果用户写的线程函数退出了，线程函数栈上的局部变量可能就不复存在了
		2.如果是 int 型的变量，则可以使用“pthread_exit （（ int* ） ret ）； ”
		3.使用全局变量返回
		4.将返回值填入到用malloc()在堆上分配的空间里
		5.使用字符串常量，如pthread_exit（“hello，world”）// 字符串常保存在今天存储区(数据段), 字符串数组变量保存在栈中
	④注意:
		1.子线程执行完毕后, 会自动退出线程, 不会陷入僵尸状态。但是资源任然在进程中没有得到释放， 
			并且这块资源并不会复用。
		2.子线程也可以return退出并返回给主线程参数
##################################################################################
【7】线程的连接和分离
	①线程连接
		[1]int pthread_join(pthread_t thread, void **retval);
		pthread_t:  等待的线程尚未退出，那么 pthread_join 的调用线程就会陷入阻塞。
		retval:     接收返回值
			・ 等待的线程尚未退出，那么pthread_join 的调用线程就会陷入阻塞。
			・ 等待的线程已经退出，那么pthread_join 函数会将线程的退出值（void* 类型存放到retval)指针指向的位置。
			1.pthread_join 函数之所以能够判断是否死锁和连接操作是否被其他线程捷足先登，是因为目标线程的控制结构体 struct pthread 中，存在如下成
				员变量，记录了该线程的连接者。
			2.直接连接自己, 或者A连接B, B又连接A
		[2]线程连接(join)与进程等待(wait)的不同点
			1.进程之间的等待只能是父进程等待子进程, 
			2.线程组内的成员是对等的关系，线程组内的任一线程都可其他线程进行连接(join)
			3.进程等待可以等待一个进程组内的所有线程(waipid)
			4.线程的连接操作只能单独连接某个具体的线程: 当库函数尝试连接（ join ）私自创建的线程时，发现已经被连接过了，就会返回EINVAL 错误。
		[3]为什么要连接退出的线程?
			1.已经退出的线程，其空间没有被释放，仍然在进程的地址空间之内。
			2.新创建的线程，没有复用刚才退出的线程的地址空间。
			==> 造成资源泄漏
			3.当线程组内的其他线程调用pthread_join连接退出线程时，内部会调用__free_tcb函数，该函数会负责释放退出线程的资源。
			4.纵然调用了pthread_join，也并没有立即调用munmap来释放掉退出线程的栈，它们是被后建的线程复用了。（再次反复创建线程,分配线程栈会影响性能）
	②线程分离(新建线程默认为不可分离)
		[1]设置线程为可分离状态
		int pthread_detach(pthread_t thread);
			thread: 要分离的线程标识ID
			1.如果其他线程并不关心线程的返回值,连接操作就会变成一种负担: 不连接会造成线程资源不释放(泄漏内存)
			2.被设置为分离的线程: 线程退出时，系统自动将线程相关的资源释放掉，无须等待连接。
			3.可以是线程组内其他线程对目标线程进行分离，也可以是线程自己执行 pthread_detach 函数,将自身设置成已分离的状态
				pthread_detach(pthread_self()) // 将本线程设置为可分离状态
			4.如果线程处于已分离的状态，其他线程尝试连接线程时，会返回 EINVAL 错误。
			5.所谓已分离: 是指线程退出后，系统会自动释放线程资源。
		[2]创建线程时, 将线程的属性设定为已分离(创建已分离线程) // 线程退出后, 系统自动回收资源
			pthread_attr_t attr;
			pthread_attr_init(&attr);
			pthread_attr_setdetachstate(&attr,PTHREAD_CREATE_DETACHED);
			thread_create(&tid, &attr, func,arg);
			// 获取.设置线程分离状态
			int pthread_attr_setdetachstate(pthread_attr_t *attr,int detachstate);
			int pthread_attr_getdetachstate(pthread_attr_t *attr,int *detachstate);	
##################################################################################
【8】互斥量
	①为什么需要互斥量
		1.共享变量（shared variable）: 多个线程共享的变量
		2.多个线程访问共享变量所带来的问题
			线程A	线程B	global_cnt
			L					
			U		 L			5
			S		 S			6
					 U			6
			当A将寄存器的值+1=6后还未写入全局变量时,线程B读全局变量5到寄存器;这项两个线程操作完后
			全局变量的值为6,而分别执行了两次加操作
				・Load ：将共享变量 global_cnt 从内存加载进寄存器，简称 L 。
				・Update ：更新寄存器里面的 global_cnt 值，执行加 1 操作，简称 U 。
				・Store ：将新的值，从寄存器写回到共享变量 global_cnt 的内存地址，简称为 S 。	
		3.所以要求
			临界区内,在同一时间只允许一个线程执行
	②互斥量的接口
		[1]互斥量初始化
			pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
			int pthread_mutex_init(pthread_mutex_t *restrict mutex,const pthread_mutexattr_t *restrict attr);		
				1.如果互斥量是动态分配的，或者需要设定互斥量的属性，那么使用宏初始化的方法就不适用了，
				2.调用pthread_mutex_init（）之后，互斥量处于没有加锁的状态。
			
		[2]互斥量的销毁
			int pthread_mutex_destroy(pthread_mutex_t *mutex);	
			・ 使用 PTHREAD_MUTEX_INITIALIZER 初始化的互斥量无须销毁。
			・ 不要销毁一个已加锁的互斥量，或者是真正配合条件变量使用的互斥量。
			・ 已经销毁的互斥量，要确保后面不会有线程再尝试加锁。
		[3]互斥量的加锁和解锁(对于一把锁: 加锁的线程必定是解锁的线程)
			int pthread_mutex_lock(pthread_mutex_t *mutex);
				(1)调用 pthread_lock（）的时候,可能会发生如下事件
					・ 互斥量处于未锁定的状态，该函数会将互斥量锁定，同时返回成功。
					・ 发起函数调用时，其他线程已锁定互斥量，或者存在其他线程同时申请互斥量，但没有竞争到互斥量，
						那么 pthread_lock （）调用会陷入阻塞，等待互斥量解锁。
				(2)等待的过程中，如果互斥量持有线程解锁互斥量，可能会发生如下事件:
					・ 函数调用线程是唯一等待者，获得互斥量，成功返回。
					・ 函数调用线程不是唯一等待者，但成功获得互斥量，返回。
					・ 函数调用线程不是唯一等待者，没能获得互斥量，继续阻塞，等待下一轮。
				(3) 如果在调用 pthread_lock （）线程时，之前已经调用过 pthread_lock （）且已经持有了互斥量，则根据互斥锁的类型，
					存在以下三种可能:
					・PTHREAD_MUTEX_NORMAL ：这是默认类型的互斥锁，这种情况下会发生死锁，调用线程永久阻塞，线程组的其他线程也无法申请到该互斥量。
					・PTHREAD_MUTEX_ERRORCHECK ：第二次调用 pthread_mutex_lock 函数时返回 EDEADLK 。
					・PTHREAD_MUTEX_RECURSIVE ：这种类型的互斥锁内部维护有引用计数，允许锁的持有者再次调用加锁操作。			
			int pthread_mutex_trylock(pthread_mutex_t *mutex);
			  如果互斥量已然被锁定，那么当即返回 EBUSY 错误，而不像pthread_mutex_lock （）接口一样陷入阻塞。
			int pthread_mutex_timedlock(pthread_mutex_t?*restrict mutex, const struct timespec *restrict abs_timeout);
			  如果申请互斥量的时候，互斥量已被锁定，那么等待；如果到了 abs_timeout 指定的时间，仍然没有申请到互斥量，那么返回ETIMEOUT 错误		
	int pthread_mutex_unlock(pthread_mutex_t *mutex);	
	③临界区的大小
		・临界区的范围不能太小，如果太小，可能起不到保护的目的。
		・临界区也不能太大，临界区的代码不能并发，如果临界区太大，就无法充分利用多处理器发挥多线程的优势。
		・不要将不相干的（特别是可能陷入阻塞的）代码放入临界区内执行。	
	④互斥量的性能
		如果临界区非常小，线程之间对临界区的竞争并不激烈，只会偶尔发生，这种情况下，忙 - 等待的策略要优于互斥量的 “ 让出 CPU ，陷入阻塞，等待唤醒 ” 的策略。
		采用忙 - 等待策略的锁为自旋锁。
	⑤互斥锁的公平性
		1.公平: 如果A在B之前调用 lock（）方法，那么A应该先于B获得锁，进入临界区。
		2.互斥锁不是一把公平的锁,并没有做到先来先服务。
	⑥互斥锁的类型
		(1)类型
		・PTHREAD_MUTEX_TIMED_NP
		・PTHREAD_MUTEX_RECURSIVE
		・PTHREAD_MUTEX_ERRORCHECK
		・PTHREAD_MUTEX_ADAPTIVE_NP
		(2)查询和设置互斥锁的类型
			int pthread_mutexattr_gettype(const pthread_mutexattr_t *restrict attr,int *restrict type);
			int pthread_mutexattr_settype(pthread_mutexattr_t *attr,int type);
	⑦死锁和活锁
		(1)死锁
			线程1已经成功拿到了互斥量1，正在申请互斥量2，而同时在另一个CPU上，线程2已经拿到了互
			斥量2，正在申请互斥量1。彼此占有对方正在申请的互斥量，结局就是谁也没办法拿到想要的互斥
			量，于是死锁就发生了。线程1和线程2都会陷入阻塞。
		(2)活锁
			1.trylock 不行就回退的思想有可能会引发活锁（ live lock ）。
				线程 1 首先申请锁 mutex_a 后，之后尝试申请 mutex_b ，失败以后，释放 mutex_a
				进入下一轮循环，同时线程 2 会因为尝试申请 mutex_a 失败，而释放 mutex_b ，
			2.如果两个线程恰好一直保持这种节奏，就可能在很长的时间内两者都一次次地擦肩而过。
				线程1		线程2
				有锁a		有锁b
				获锁b		获锁a
				trylock		trylock		// 两个线程都没有获取到对应的锁
				释放锁a		释放锁b		// 等待下一轮循环
##################################################################################
【9】条件变量
	①引入
		(1)为什么要使用条件变量?
		  1.允许多个线程以无竞争的方式等待特定的条件发生。
		  2.比如生产者消费者模型，互斥锁保护生产的产品（共享数据）; 
			  1.如果没有条件等待,消费者只有不断的轮询获取互斥锁,来操作产品。
			  2.有了条件等待后，消费者可以在某个条件上等待，条件不满足时线程在等待条件的线程列表上休眠，
			    当条件满足后，生产者从条件等待的线程列表中将消费者唤醒。
		(2)为什么要将互斥量
			条件变量本身是共享资源(多个线程使用), 需要互斥量来保护。
			所以:线程在修改条件变量之前必须先锁住互斥量
		(3)为什么达到某种条件后有"唤醒"和"广播"两种选择
			1.一个生产者一个消费者时: "生产者唤醒"消费者,消费者将获得互斥锁
			2.一个生产者多个消费者时: "生产者唤醒"所有消费者,多个消费者共同竞争一把锁
	②条件的初始化和销毁
		pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
		int pthread_cond_init(pthread_cond_t *cond,const pthread_condattr_t *attr);
		int pthread_cond_destroy(pthread_cond_t *cond);	
		注意:
			1.pthread_cond_init:如果采用默认属性，可以将 NULL 作为第二个参数。
			2.永远不要用一个条件变量对另一个条件变量赋值，即 pthread_cond_t cond_b=cond_a 不合法，这种行为是未定义的。
				因为：条件变量不是一个值,无法对其赋值。
			3.使用 PTHREAD_COND_INITIALIZE 静态初始化的条件变量，不需要被销毁。	
			4.要调用 pthread_cond_destroy 销毁的条件变量可以调用 pthread_cond_init 重新进行初始化。
			5.不要引用已经销毁的条件变量，这种行为是未定义的。
	③条件变量的使用
		(1)	while(唤醒条件不满足)
				int pthread_cond_wait(pthread_cond_t *restrict cond,
									pthread_mutex_t *restrict mutex);
			1.必须传递一个上锁的互斥量给该函数(对条件变量进行保护)
			2.这个函数自动把调用的线程放到"等待条件"的线程列表上休眠
			3.指定2.后,线程随即对互斥量解锁(生产者将获得这把互斥锁)
			4.如果生产者通过条件信号唤醒了pthread_cond_wait函数的调用线程, 然后释放互斥锁;
			   那么多个消费者会被唤醒,然后会同时竞争互斥锁; 得到到互斥锁的线程从该函数返回,然后往下执行,
			   没有竞争到互斥锁的的线程继续休眠。
			5.该函数成功返回后将从新持有互斥锁						
									
			0.为什么要加while()?
				共享数据 i= 0;
				线程1:
					上锁
					if(i= 1)
						pthread_cond_wait(&pool->cond, &pool->mutex);
						i= 2
					解锁
				线程2:
					上锁
					if(i= 1)
						pthread_cond_wait(&pool->cond, &pool->mutex);
					解锁
				主线程:
					if (i= 1)
						pthread_cond_broadcast(cond)
				假如: 线程1先被唤醒 -> 更改i= 2 -> 然后释放锁
					 -> 线程2被唤醒
				分析: 线程2的唤醒条件本来是if(i = 1), 而i= 2时, 线程2被唤醒了
					 这就是假换。加了while(), 被唤醒后判断唤醒是否条件, 如果不满足继续休眠
					 如果满足就唤醒
					
		(2)int pthread_cond_timedwait(pthread_cond_t *restrict cond,
								pthread_mutex_t *restrict mutex,
								const struct timespec *restrict abstime);			
			1.该函数与 pthread_cond_wait 的工作方式几乎是一样的，只是调用时需要指定一个超时的时间。
			2.注意这个时间是绝对时间，而不是相对时间。如果最多等待 2 分钟，那么这个值应该是当前时间加上 2 分钟。			
		(3)int pthread_cond_signal(pthread_cond_t *cond);
			  唤醒至少一个阻塞在条件变量上的线程
		(4)int pthread_cond_broadcast(pthread_cond_t *cond);			
			  广播唤醒等待在条件变量上的所有线程。
			
		(5)"示例"及说明	
			-----------------------------------------------------------
			<生产者>
				5.锁住互斥量(安全生产和保护条件变量)
				6.生产"共享数据"
				7.唤醒/广播正在睡眠的线程()	// 执行这一步之前,生产者任然在睡眠
				8.释放互斥锁
			<各个消费者>
				1.先锁住互斥量（为了保护条件变量）
				2.pthread_cond_wait（cond， mutex）
					3.将调用该函数的线程放到“等待条件的线程列表”中睡眠
					4.释放互斥量
				9. 各个消费者被“唤醒/广播”唤醒
				10.得到互斥锁？	// 各个消费者共同竞争这把互斥锁
					是：转到11.
					否: 继续在“等待条件的线程列表”中睡眠
				11.消费"共享数据"	（互斥锁保护"共享数据"）
				12.解开互斥锁。
			-----------------------------------------------------------
			为什么：生产者要先唤醒/广播，然后在释放互斥锁？
				1.先唤醒/广播，然后在释放互斥锁？会导致没抢到锁的线程从内核中醒来,然后又睡去(这是一种性能损失)
				2.如果先释放互斥锁,再唤醒/广播等待的线程: 
					先解锁、后通知条件变量虽然可能会有性能上的优势，但是也会带来其他的问题。如果存在一个
					高优先级的线程，既等待在互斥量上，也等待在条件变量上；同时还存在一个低优先级的线程，只等
					待在互斥量上。一旦先解锁互斥量，低优先级的进程就可能会抢先获得互斥量，待调用
					pthread_cond_signal 之后，高优先级的进程会发现互斥量已经被低优先级的进程抢走了。
				==> 所以如果除开消费者外，还有其他线程在使用“保护条件变量的互斥量”那么
					推荐使用"生产者要先唤醒/广播，然后在释放互斥锁", 宁愿损失性能,也不能让任何消费者都抢不到互斥锁。
##################################################################################
【10】线程的读写锁(reader-writer lock)
(1)概述
	1.读写锁与互斥锁类似, 不过读写锁允许更高的并行性。
	2.读写锁也成为“共享互斥锁”。
	3.当读写锁以读模式锁住时称为“以共享模式锁住了”。
	  当读写锁以写模式锁住时称为“以互斥模式锁住了”。
	4.读写锁使用之前必须初始化， 释放他们之前必须销毁。
(2)读写锁的三种状态
	①读模式加锁状态
	②写模式加锁状态
		1.在解锁之前,所有试图对这个锁加锁的线程都会阻塞。
		2.写模式加锁状态时，如果有线程试图以写模式申请锁时，读写锁会柱塞随后的读模式请求。这样可以避免读锁被长时间占用。
	③不加锁状态
		1.所有试图以读模式对他进行加锁的线程都可以得到锁。
		2.但是所有试图以写模式对此锁加锁的线程都会阻塞，直到所有读锁都被释放
(3)接口
		// 初始化读写锁
	int pthread_rwlock_init(pthread_rwlock_t *lock, const pthread_rwlockattr_t *attr);
		// 以读模式锁定读写锁
	int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);
		// 以写模式锁定读写锁
	int pthread_rwlock_rwlock(pthread_rwlock_t *rwlock);
		// 不管以何种方式锁定的读写锁, 都用下面的函数解锁
	int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);
					
##################################################################################
##################################################################################
					第八章.理解Linux线程(2)
【一】线程的取消(强制使进程退出)	//不建议使用取消接口来使线程退出
(1)函数取消接口
	①向线程发送取消请求
		pthread_cancel(pthread_t thread);	
		1.一个线程可以通过调用该函数向另一个线程发送取消请求。
		2.如果成功，该函数返回0，否则将错误码返回。
		3.这不是个阻塞型接口，发出请求后，函数就立刻返回了，而不会等待目标线程退出之后才返回。
		4.函数的本质：会向目标线程发送一个SIGCANCEL（可靠信号）的信号，该信号就是6.4节“ 信号的分类 ”中提到的被NPTL征用的32号信号。
	②设置线程能否被取消(在线程执行函数中设置)
		int pthread_setcancelstate(int state, int *oldstate);
		・PTHREAD_CANCEL_ENABLE 
			线程的默认取消状态是 PTHREAD_CANCEL_ENABLE 
		・PTHREAD_CANCEL_DISABLE
			1.其他线程发送的SIGCANCEL信号被暂时挂起(而不是被抛弃)，暂时不予处理。当线程状态设置为PTHREAD_CANCEL_ENABLE后,
			  SIGCANCEL信号不在被挂起, 会加入到正常的信号队列中
			2.那么收到取消请求后，会发生什么？这取决于线程的取消类型。	
	③设置线程的取消类型
		int pthread_setcanceltype(int type, int *oldtype);
		・PTHREAD_CANCEL_ASYNCHRONOUS（异步取消）	// 永远不要使用异步取消
			即线程可能在任何时间点（可能是立即取消，但也不一定）取消线程。这种取消方式太粗暴，很容易造成后续的混乱。
		・PTHREAD_CANCEL_DEFERRED(延迟取消)
			1.新建线程的默认取消类型为"延迟取消"。
			2.取消点: 就是对于某些函数，如果线程允许取消且取消类型是延迟取消，并且线程也收到了取消请求，
				那么当执行到这些函数的时候，线程就可以退出了。==>这些函数称为"取消点"函数
			3.通过man pthreads可以查询到这些取消点函数（有好几十个之多）。	
			4.线程执行到取消点，会自动处理取消请求，但是如果线程没有用到任何取消点函数。
				1.为了应对这种场景，系统引入了pthread_testcancel函数，该函数一定是取消点。
				2.编程者可以周期性地调用该函数，只要有取消请求，线程就能响应。
				void pthread_testcancel(void);
			5.如果线程被取消，并且其分离状态是可连接的，那么需要由其他线程对其进行连接(回收资源)。
			6. pthread_join 函数的第二个参数会被置成 PTHREAD_CANCELED ，通过该值可以知道线程并不是“寿终正寝”，而是被其他线程取消而导致的退出。
	⑤线程取消的弊端
		1.线程取消是一种在线程的外部强行终止线程的执行做法
		2.目标线程可能会持有互斥量、信号量或其他类型的锁，这时候如果收到取消请求，其他线程可能会死锁（被取消的线程未释放锁）
	⑥异步取消安全函数	//即使执行异步取消也安然无恙的函数
		pthread_cancel()
		pthread_setcancelstate()
		pthread_setcanceltype()
	⑥编程人员应该遵循以下原则：
		・ 第一，轻易不要调用 pthread_cancel 函数，在外部杀死线程是很糟糕的做法，毕竟如果想通知目标线程退出，还可以采取其他方法。
		・ 第二，如果不得不允许线程取消，那么在某些非常关键不容有失的代码区域，暂时将线程设置成不可取消状态，退出关键区域之后，再恢复成可以取消的状态。
		・ 第三，在非关键的区域，也要将线程设置成延迟取消，永远不要设置成异步取消。
【二】限制指定子线程work执行时间为A秒
	1.使用定时器alarm()和setitimer()		// 注意: 信号可能会被主线程捕获(参考第6章笔记)
	2.创建新线程来发送信号
		1.在子线程work中再创建一个子线程work2
		2.work中注册一个信号SIG
		3.将work线程的线程ID pid1作为参数传递给子线程work2
		3.在work2中sleep(A)后, 调用pthread_kill(pid1, SIG);向子线程发送信号
		4.当线程work收到work1发来的信号后,从信号函数中回收work2并退出work
	
	
	
	

------------------------------------------------------------------------------------		
【二】线程的清理函数
(1)为什么要使用线程清理函数
	1.假设遇到取消请求，线程执行到了取消点，却没有来得及做清理动作（如动态申请的内存没有释放，申请的互斥量没有解锁等），
	 可能会导致错误的产生，比如死锁，甚至是进程崩溃。
	2.为了避免这种情况，线程可以设置一个或多个清理函数，线程取消或退出时，会自动执行这些清理函数，以确保资源处于一致的状态。
(2)相关接口
	void pthread_cleanup_push(void (*routine)(void *),void *arg);
	void pthread_cleanup_pop(int execute);	
	注意:
		1.Linux 就是用宏来实现的。这意味着这两个函数必须同时出现，并且属于同一个语法块(同一函数中)。	
		2.	pthread_cleanup_push(clean_func,clean_arg);
			......
			if(cond)
				pthread_cleanup_pop(0);
			//在日常编码中很容易犯上面这种错误。因为 pthread_cleanup_push 和 phtread_cleanup_pop 的实现中包
			//含了 { 和 } ，所以将 pop 放入 if{} 的代码块中，会导致括号匹配错乱，最终会引发编译错误。	
		3.可以注册多个清理函数
			pthread_cleanup_push(clean_func_1,clean_arg_1)
			pthread_cleanup_push(clean_func_2,clean_arg_2)
			...
			pthread_cleanup_pop(execute_2);
			pthread_cleanup_pop(execute_1);	
		3.从 push 和 pop 的名字可以看出，这是栈的风格，后入先出，就是后注册的清理函数会先执行
		其中 pthread_cleanup_pop 的用处是，删除注册的清理函数。如果参数是非 0 值，那么执行一次，再删除清理函数。否则的话，就直接删除清理函数。
(3)何时触发清理函数：
	1.pthread_cancel:
		1.线程取消前执行了pthread_cleanup_pop(0), 就不会执行清理函数
		2.否则执行清理函数
	2.pthread_exit()
		1.如果在pthread_exit前执行了pthread_cleanup_pop(0), 清理函数不会执行
		2.如果在pthread_exit前执行了pthread_cleanup_pop(1), 清理函数会执行
		3.pthread_exit在pthread_cleanup_pop函数前被执行, 清理函数一定会执行
	3.return()
		1.如果在return前执行了pthread_cleanup_pop(0), 清理函数不会执行
		2.如果在return前执行了pthread_cleanup_pop(1), 清理函数会执行
		3.return在pthread_cleanup_pop函数前被执行, 清理函数一定不会执行
	
------------------------------------------------------------------------------------		
【三】线程池
(1)思想
	1.一个进程中的线程就好比是一家公司里的员工，员工的数目应该根据公司的业务多少来
	  定，太少了忙不过来，但是太多了也浪费资源。	
	2.最理想的情况是：让进程有一些初始数目的线程，当没有任务的时候这些线程自动进入睡眠，
	  有了任务他们会立即执行任务，不断循环。
	3.进程还应该可以根据自身任务的繁重与否来增删线程的数目。
	4.当所有的任务都完成了之后，所有的线程还能妥当地收官走人。
	5.多个线程池(部门)协同工作。
	
(2)达到的目的	
	1.用户通过init_pool(&pool, n)来初始化一个线程池, 初始线程数为n
	2.用户通过add_task(&pool,do_task, "arg")来向任务链表中投递任务
	3.当n个线程能及时处理任务链表里面的任务时(任务链表没有任务排队), 空闲的线程休眠, 新任务添加时唤醒
	4.当n个线程不能及时处理任务链表里面的任务时(任务链表有任务排队), 创建新线程来执行任务
	5.能创建的线程数上线为MAX个
	6.当任务不再繁忙时, 要取消额外创建的线程

(2)框架构想及API
		主线程:						 投递任务
									   ↓(投递任务)	
		任务链表:	任务1-->任务2->任务3...................
					↓	
					↓(取出第一个任务)
			|-------------------------|
			|线程1	线程2	线程3 ... |
			|-------------------------|
	1.任务链表被多个线程操作, 需要提供互斥锁来保护"共享资源" 	
	2.限制创建线程的最大个数
	3.向外提供初始化线程池的接口
		1.根据用户的要求创建初始线程个数为n的线程池
		2.初始化一个任务链表
	4.内部线程池的线程处理函数
		上锁	// 如果这里不上锁,有可能在判断过程中添加了新任务
			注册线程清理函数(防止线程被取消时,没有释放互斥锁)
			1.任务链表为空:
				当前线程个数 >= 用户初始创建的线程个数?
				否: 当前线程睡眠在条件变量上(while + wait)
				是: 关闭当前线程	(现在任务不繁忙, 空闲线程占用系统资源)
			2.任务链表不为空:
					1.当前线程从链表中取出第一个任务
					2.从任务链表中删除当前任务
		解锁	// 先解锁后执行的原因是: 任务执行期间不应该阻止其他线程获取任务
		3.执行任务
		4.当前任务执行完毕后, 重复上面的操作
	5.向外提供主线程投递任务到任务链表的接口
		上锁
			1.将任务投递到链表尾部
			2.当前有正在睡眠的线程?
				有: 广播所有在条件变量上睡眠的线程
				无: 创建线程		// 当前任务繁忙, 用户要求创建的线程不够用
		解锁
			用新建线程执行该任务
	6.向外提供销毁线程池的接口
		
		
		
		
	
	
		





		
##############################################################################################################
##############################################################################################################
						第9章 进程间的通信： 管道

##############################################################################################################
##############################################################################################################
						第10章 进程间的通信： System V IPC
【一】SYSTEM-V IPC概述：
(1) System V IPC 编程接口
	--------------------------------------------------------------------------------
	头文件			|	消息队列	  	  |		信号量		|	共享内存			|
	--------------------------------------------------------------------------------
	头文件			|	sys/msg.h 	  |		sys/sem.h	|	sys/shm.h				|
	--------------------------------------------------------------------------------
	关联数据结构	|	msqid_ds  	  |		semid_ds	|	shmid_ds				|
	--------------------------------------------------------------------------------
	创建或打开对象	|	msgget()  	  |		semget()	|	shmget() + shmat		|
	--------------------------------------------------------------------------------
	关闭对象		|	  无	  	  |		  无		|		无					|
	--------------------------------------------------------------------------------
	控制操作		|	msgctl()      |		semctl		|	shmctl					|
	--------------------------------------------------------------------------------
	执行IPC			|	msgsnd/msgrcv |		semop()		|	访问共享内存(memcpy...) |
	--------------------------------------------------------------------------------
(2)SystemV IPC对象的删除
	1.消息队列: 立即删除消息队列		// 内核没有对使用消息队列的进程进行计数
	2.信号量:   立即删除信号量集		// 内核没有对使用信号量集的进程进行计数
	3.共享内存:	如果共享内存的引用计数等于 0，则可以立即删除共享内存。
				如果有多个进程在使用这段共享内存, 等所有进程都和这段共享内存分离(解除映射)后, 才能真正删除这段共享内存
(3)SystemV IPC对象的非文件属性
	1.System V IPC 对象在文件系统中没有实体文件与之关联。
	2.在shell中无法用 ls 查看存在的IPC对象，无法用 rm 将其删除。也无法用 chmod 来修改它们的访问权限
	3.Linux 提供了 ipcs、 ipcrm和ipcmk等命令来操作这些对象。
	4.System V IPC 对象不是文件描述符，所以无法使用基于文件描述符的多路转接I/O技术（select、poll和epoll等）。
(4)SystemV IPC对象的内核持久性
	1.哪怕创建 System V IPC 对象的进程已经退出，哪怕有一段时间没有任何进程打开该 IPC 对象，只要不执行
		删除操作或系统重启，后面启动的进程依然可以使用之前创建的 System V IPC 对象来通信。
(5)	标识符ID和IPC对象的作用域
	1.每种 SystemV IPC都有一个相关的get调用，该函数返回一个整型标识符ID， System V IPC 后续的函数操作都要作用在该标识符ID上。
	2.System V IPC对象的作用范围是整个操作系统,对于任何进程，无论是否存在亲缘关系，只要有相应的权限，都可以通过操作 System V IPC 对象来达到通信的目的。
------------------------------------------------------------------------------------------------------------------------------------------------------------	
【二】SystemV 共享内存
原理:
					[进程1]	[进程2]
			strcpy	  ↓	 ↑ printf
		______________↓_____↑______
		|			| 共享内存  |	|
		|			|(PAGE_SIZE)|	|	(内存空间)
		|___________|___________|___|
			 (共享内存原理)
(1).共享内存概述
	1.管道、 FIFO 和消息队列，任意两个进程之间想要交换信息，都必须通过内核，
	  内核在其中发挥了中转站的作用：
		-----------------------------------------------------------------	  
		|	[进程A]						[进程B]							|
		|		\write(msgsnd)			  /read/msgrcv		用户层		|
		|	---------------------------------------------------------	|			
		|		  \						/					内核层		|	
		|		  ↓				   ↑								|		
		|		 [IPC(管道.FIFO.消息队列)]  								|	
		|----------------------------------------------------------------
				  (管道、 FIFO 和消息队列	)
			缺点: 一个通信周期内，上述过程至少牵扯到两次内存拷贝和两次系统调用	
	2.共享内存: 内核搭台, 进程唱戏。
		步骤：1.内核负责构建出一片内存区域
			  2.两个或多个进程可以将这块内存区域映射到自己的虚拟地址空间
			  3.从此之后内核不再参与双方通信，进程之间使用共享内存通信
				(当进程使用共享内存时，可能会发生缺页，引发缺页中断，这种情况下，内核还是会参与进来的。)
			  4.共享内存所有进程间通信方式中效率最高的一种.
			  5.进程可以像操作普通进程的地址空间一样操作这块共享内存，一个进程可以将信息写入这片内存区域，
			     而另一个进程也可以看到共享内存里面的信息，从而达到通信的目的
			  6.注意: 
			    要防止多个进程同时操作同一块共享内存(使用信号量(生产者-消费者模型)搭配使用,来控制共享内存资源的互斥访问)
  
		-----------------------------------------  
		|							用户空间:	|	
		|	|-----|		|-----|					|		
		|	|进程A|		|进程B|					|					
		|	|-----|		|-----|					|								
		|	| map | 	| map |					|					
		|	|-----|		|-----|					|				
		|	 ↓ ↑		 ↓ ↑					|				
		|	[	共  享  内  存	]				|							
		-----------------------------------------	  
(2)创建或打开共享内存		
	int shmget(key_t key, size_t size, int shmflg);
		size： 必须是正整数，实际 size 会被向上取整为页面大小的整数倍。
	    shmflg：支持 IPC_CREAT 和 IPC_EXCL 标志位 
		单个共享内存段的最大字节数为 SHMMAX //cat /proc/sys/kernel/shmmax
(3)使用共享内存: 将共享内存映射到进程的虚拟地址空间
	void *shmat(int shmid, const void *shmaddr, int shmflg);
		通常会将第二个参数设置为 NULL,表示由内核分配共享内存区域
		shmid: 为shmget返回的共享内存标识符ID
		shmflg: 如果进程仅仅是读取共享内存段的内容，并不修改，则可以指定 SHM_RDONLY 标志位。
	// SHM_KEY所在的共享内存不存在时创建他, 若存在返回错误
	第一个进程: shmid = shmget(SHM_KEY, SHM_SIZE, IPC_CREAT | IPC_EXCL | 0777);
	// 打开SHM_KEY所在的共享内存
	第二个进程: shmid = shmget(SHM_KEY, SHM_SIZE, 0777);
(4)	分离共享内存
	int shmdt(const void *shmaddr);
	1.shmdt 函数仅仅是使进程和共享内存脱离关系，并未删除共享内存
	2.shmdt 函数的作用是将共享内存的引用计数减 1 
	3.只有共享内存的引用计数为 0 时，调用 shmctl 函数的 IPC_RMID 命令才会真
		正地删除共享内存。
(5)控制共享内存:
	int shmctl(int shmid, int cmd, struct shmid_ds *buf);
		IPC_STAT: 获取 shmid 对应的共享内存的信息(struct shmid_ds信息)
		IPC_SET:  只能修改 shm_perm 中的 uid 、 gid 及 mode 。	
		IPC_RMID: 如果共享内存的引用计数 shm_nattch 等于 0 ，则可以立即删除共享内存。但是如果仍然存在进程
				  attach 该共享内存，则并不执行真正的删除操作，而仅仅是设置 SHM_DEST 标记。待所有进程都执行过
				  分离操作之后，再执行真正的删除操作。
				  //，共享内存处于 SHM_DEST 状态的情况下，依然允许新的进程调用 shmat 函数来 attach该共享内存。
		...........
(6)key的获取方法(密钥)
	方法1: (1-5000)内的任意整数
	方法2: key_t ftok(const char *pathname, int proj_id); // 任意合法路径,任意整数
------------------------------------------------------------------------------------------------------------------------------------------------------------	
【三】.消息队列(SYSTEM-V IPC)
(1)创建或打开一个消息队列
	int msgget(key_t key, int msgflg);
(2)发送消息
	int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);
	 msqid: 是由 msgget 返回的标识符 ID 。
	 msgp:  指向用户定义的缓冲区。它的第一个成员必须是一个指定消息类型的 long 型，后面跟着消息文本的内容
			struct msgbuf {
				long mtype; 	/* 消息类型，必须大于0 */
				char mtext[1];  /* 消息体，不一定是字符数组，可以是任意结构*/
			};
	 msgsz：消息的大小
	 msgflg：IPC_NOWAIT 表示执行一个无阻塞的发送操作。
				(1)无IPC_NOWAIT标志位:
					如果消息队列满了，msgsnd函数会陷入阻塞，直到队列有足够的空间来存放这条消息为止。
				(2)有IPC_NOWAIT标志位:
					如果消息队列满了，msgsnd函数就不会陷入阻塞了，而是立刻返回失败，并置 errno 为 EAGAIN 。
	 返回值： 成功返回消息队列ID(非负)
(3)	接收消息
	ssize_t msgrcv(int msqid, void *msgp, size_t msgsz,long msgtyp,int msgflg);	 
	 msgtyp:
		msgtyp == 0: 最先进入消息队列的消息被取出。
		msgtyp < 0:  mtype 的值越低，其优先级越高，越早被取出。
		msgtyp > 0:，会将消息队列中第一条 mtype 值等于 msgtyp 的消息取出。通过指定不同的 msgtyp ，多个进程可以在同一个消息队列中
		挑选各自感兴趣的消息。一种常见的场景是各个进程提取和自己进程 ID 匹配的消息。	
	 msgflg:
	 ・IPC_NOWAIT ：如果消息队列中不存在满足 msgtyp 要求的消息，默认情况是阻塞等待，但是一旦设置了 IPC_NOWAIT 标志位，则立即返回失败，并且设置 errno 为 ENOMSG 。
	 ・MSG_EXCEPT ：这个标志位是 Linux 特有的，只有当 msgtyp 大于 0 时才有意义，含义是选择 mtype ！ =msgtyp 的第一条消息
	 ・MSG_NOERROR ：在消息体变长的情况下，此时会将消息体截断并返回。
(4)控制消息队列
	int msgctl(int msqid, int cmd, struct msqid_ds *buf);
		IPC_RMID: 	删除消息队列(立即生效, 因为内核没有为使用消息队列的进程维护引用计数)
			所有阻塞的msgsnd函数和msgrcv函数会被唤醒，并返回EIDRM 错误。
		IPC_SET:	设置消息队列
		IPC_STAT:	获取消息队列的状态
(5)优缺点
	1.当消息队列中有消息到来时，无法主动通知到某进程, 必须靠进程主动去接收消息。
	2.消息队列的读取进程,只能用阻塞或轮询的方式。这就意味着一个进程或线程不得不无所事事，盯在该消息队列上。
	3.如果 System V消息队列是文件，能支持 select 、 poll 和 epoll 等I/O多路转接函数，一个进程就能同时监控多个文件（或者多个消息队列），提
	  供更灵活的编程模式。可惜的是， System V 消息队列并非文件，不支持I/O多路转接函数。
	4.用一个消息队列可进行多个进程间的通信(通过进程接收的消息类型不同) 
(6)示例代码: 用消息队列编写了3个进程之间任意聊天的小程序
------------------------------------------------------------------------------------------------------------------------------------------------------------	
【四】.SYSTEM-V IPC信号量(进程间同步互斥)
system-v信号量(进程间同步互斥)
(1)概述
	1.消息队列的作用是进程之间传递消息。
	2.信号量的作用是为了同步多个进程的操作
	3.内核会负责维护信号量的值，并确保其值不小于 0 。
	4.信号量上支持的操作
		・ 将信号量的值设置成一个绝对值。
		・ 在信号量当前值的基础上加上一个数量。
		・ 在信号量当前值的基础上减去一个数量。
		・ 等待信号量的值等于 0 。
	5.二值信号量
		1.它只有两种合法值： 0 和 1 ，对应一个可用的资源。
		2.若当前有资源可用，则与之对应的二值信号量的值为 1 ；
		3.若资源已被占用，则与之对应的二值信号量的值为 0 。
		4.当进程申请资源时，如果当前信号量的那么进程会陷入阻塞，直到有其他进程释放资源，将信号量的值加 1 才能被唤醒。
	6.互斥量（ mutex ）是用来保护临界区的，所谓临界区，是指同一时间只能容许一个进程进入。
	  而信号量（ semaphore ）是用来管理资源的，资源的个数不一定是 1 ，可能同时存在多个一模一样的资源，
		因此容许多个进程同时使用资源。
	7.信号量是互斥量的一个扩展，由于资源数目增多，增强了并行度。但是这仅仅是一个方面。更重要的区别是，互斥量和信号量解决的问题是不同的。
	8.互斥量的关键在于互斥、排它，同一时间只允许一个线程访问临界区。决定了解铃还须系铃人，即加锁进程必然也是解锁进程， 
	9.而信号量的关键在于资源的多少和有无。申请资源的进程不一定要释放资源，信号量同样可以用于生产者 - 消费者的场景。在这种场景下，
	  生产者进程只负责增加信号量的值，而消费者进程只负责减少信号量的值。彼此之间通过信号量的值来同步。
	10.和二值信号量相比， System V 信号量在两个维度上都做了扩展。
		第一，资源的数目可以是多个。资源个数超过 1 个的信号量称为计数信号量
		第二，允许同时管理多种资源，由多个计数信号量组成的一个集合称为计数信号量集，每个计数信号量管理一种资源。
	11.	fork前创建的信号量,父子进程的信号量是实时自动同步的
(2)创建或打开信号量
	int semget(key_t key, int nsems, int semflg);
		第二个参数 nsems 表示信号量集中信号量的个数。换句话说，就是要控制几种资源。大部分情况下只控制一种。
		semflg 支持多种标志位。目前支持 IPC_CREAT 和 IPC_EXCL 标志位，其含义不再赘述。
(3)操作信号量
	int semop(int semid, struct sembuf *sops, unsigned nsops);
	第二个参数是 sembuf 类型的指针, sem_num 解决的是操作哪个信号量的问题	
	第三个参数是表示要同时操作几个信号量
	通常的方法:
	1.抢占资源型
		同一个资源互斥访问: 		
			[资源]
			setctl	1			// 初始化为1
		p1			p2
		semop-1		semop-1 	// 使用资源前,必须先占有资源
		使用临界资源资源
		sleep(1)	sleep(1)	// 将当前进程挂起1秒, 给其他进程抢占资源的机会
		sem+1		sem+1		// 释放资源 
	2.生产者消费者类型				//(共享内存和信号量的搭配使用就是)
			[资源]
			setctl	0			// 初始化为0
		生产者		消费者
		semop+1 	semop-1		// 二者完全独立, 当资源消耗完后, 消费者陷入阻塞
	
(4)控制信号量	
	int semctl(int semid, int semnum, int cmd,/* union semun arg*/);
(5)通常的封装
	union semun {
		int              val;    /* Value for SETVAL */
		struct semid_ds *buf;    /* Buffer for IPC_STAT, IPC_SET */
		unsigned short  *array;  /* Array for GETALL, SETALL */
		struct seminfo  *__buf;  /* Buffer for IPC_INFO	 (Linux-specific) */
	};
	// 获取信号量集中指定信号量的值
	int sema_getval(int semid, int index)
	{	union semun ignore_arg;
		return semctl(semid, index, GETVAL, ignore_arg);
	}
	// 设置信号量集中指定信号量为value
	int sema_setval(int semid, int index, int val)
	{	union semun arg;
		arg.val = val;
		return semctl(semid, index, SETVAL, arg);
	}
	// 立即删除信号量集
	int sema_rmid(int semid)
	{	union semun ignore_arg;
		int ignore_index;
		return semctl(semid, ignore_index, IPC_RMID, ignore_arg);
	}
	/* 操作信号量 */ 
	// 申请资源(操作一个信号量)
	int semaphore_wait (int semid, int index)
	{
		struct sembuf operations[1];
		operations[0].sem_num = index;			// 操作一组信号量中的哪一个信号量
		operations[0].sem_op = -1;				// 信号量0的值 + 1
		operations[0].sem_flg |= SEM_UNDO;		// 进程退出后恢复信号量(成对出现)
		return semop(semid, operations, 1);	// 信号量集合操作
	}
	// 释放资源(操作一个信号量)
	int semaphore_post(int semid, int index)
	{
		struct sembuf operations[1];
		operations[0].sem_num = index;			// 操作一组信号量中的哪一个信号量
		operations[0].sem_op = 1;				// 信号量0的值 - 1
		operations[0].sem_flg |= SEM_UNDO;		// 进程退出后恢复信号量(成对出现)
		return semop(semid, operations, 1);
	}
##############################################################################################################
						第11章 进程间的通信LPOSIX IPC
##############################################################################################################
##############################################################################################################
【一】POSIX IPC概述
----------------------------------------------------------------------------------------
【二】POSIX 消息队列
----------------------------------------------------------------------------------------
【三】POSIX信号量(POSIX有名信号量、POSIX无名信号量)
(1)概述
	1.理论与SYSTE-V一样, 但在IPC上进行了封装, 和在文件系统上进行了扩展
	2.POSIX 信号量和 System V 信号量的作用是相同的，都是用于同步进程之间及线程之间的操作，以达
	  到无冲突地访问共享资源的目的。
	3.POSIX 信号量的作用和 System V 信号量是一样的。但是两者在接口上有很大的区别：
		・POSIX 信号量将创建和初始化合二为一
		・一次只能修改一个信号量。System V 信号量其本质是信号量集,一次可以修改多个信号量。
		・POSIX 信号量一次只能将信号量的值加 1 或减 1 。System V 信号量能够加上或减去一个大于 1 的值。
		・POSIX 信号量并没有提供一个等待信号量变为 0 的接口, System V 信号量中， semop 函数则提供了这样的接口
		・POSIX 信号量并没有提供 UNDO 操作，而 System V 信号量则提供了这样的操作。
	4.POSIX 信号量真正比 System V 信号量优越的地方在于， POSIX 信号量性能更好。	
		对于 System V 信号量而言，每次操作信号量，必然会从用户态陷入内核态时间上的开销很大
		 POSIX 信号量,只要不存在真正的两个线程争夺一把锁的情况，那么修改信号量就只是用户态的操作，并不会牵扯到内核。
		 在竞争并不激烈的情况下， POSIX 的性能要远远高于 System V 信号量。
	5.（☆）POSIX 提供了两类信号量：有名信号量和无名信号量。
		1.无名信号量，又称为基于内存的信号量，由于其没有名字，没法通过 open 操作直接找到对应的信号量，
		  所以很难直接用于没有关联的两个进程之间：无名信号量多用于线程之间的同步。
		2.有名信号量由于其有名字，多个不相干的进程可以通过名字来打开同一个信号量，从而完成同步
			操作，所以有名信号量的操作要方便一些，适用范围也比无名信号量更广。
(2)有名信号量(用于进程间的通信)
	// 有名字，多个不相干的进程可以通过名字来打开同一个信号量，从而完成同步
	①创建、打开、关闭、删除有名型号量
		1.sem_t *sem_open(const char *name, int oflag);
		2.sem_t *sem_open(const char *name, int oflag,mode_t mode, unsigned int value);
		  第二个参数 oflag 标志位支持的标志包括 O_CREAT 和 O_EXCL 标志位。如果带了 O_CREAT 标志位，则表示要创建信号量。
			mode:  创建的新信号量的访问权限
			value: 新建信号量的初始值。创建和赋初值都是由一个接口来完成的
			不要尝试创建 sem_t 结构体的副本,切记，后面所有的调用都要用通过 sem_open 返回的 sem_t 类型的指针来进行操作，而不能使用结构体的副本。
		3.int sem_close(sem_t *sem); 			// 关闭信号量
			1.当一个进程打开有名信号量时，系统会记录进程与信号的关联关系。调用 sem_close 时，会终止这
			  种关联关系，同时信号量的进程数的引用计数减 1 。
		    2.进程终止时，进程打开的有名信号量会自动关闭。当进程执行 exec 系列函数时，进程打开的有名信号量会自动关闭。
			3.关闭不等同于删除.
		4.int sem_unlink(const char *name);	// 删除信号量
		   将有名信号量的名字作为参数，传递给 sem_unlink ，该函数会负责将该有名信号量删除。由于系统
			为信号量维护了引用计数，所以只有当打开信号量的所有进程都关闭了之后，才会真正地删除。
		5.注意
		   如果程序结尾没有删除Posix信号量, 第二次运行时就只会打开前面创建的信号量（会在当前目录下生产一个信号量文件）;
			而信号量的初值是在信号量创建时设置的; 
		==> 第二次运行时,信号量的初值可能不是我们想要的
	②信号量的使用
		/*  信号量的使用，总是和某种可用资源联系在一起的。创建信号量时的 value 值，其实指定了对应资
			源的初始个数。当申请该资源时，需要先调用 sem_wait 函数；当发布该资源或使用完毕释放该资源时，
			则调用 sem_post 函数。
		*/
		1.等待信号量
		  int sem_wait(sem_t *sem);
			如果调用 sem_wait 函数时，信号量的当前值大于 0 ，那么 sem_wait 函数立刻返回。否则 sem_wait 函
			数陷入阻塞，待信号量的值大于 0 之后，再执行减 1 操作，然后成功返回。
          int sem_trywait(sem_t *sem);
			sem_trywait 会尝试将信号量的值减 1 ，如果信号量的值大于 0 ，那么该函数将信号量的值减 1 之后会
			立刻返回。如果信号量的当前值为 0 ，那么 sem_trywait 也不会陷入阻塞，而是立刻返回失败，并置 errno
			为 EAGAIN 。
		  int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);
			有限期等待，第二个参数为一个绝对时间。可以使用 gettimeofday 函数获取到 struct timeval 类型的当前时间，然后
			将 timeval 转换成 timespec 类型的结构体，最后在该值上加上想等待的时间。
			如果超过了等待时间，信号量的值仍然为 0 ，那么返回 -1 ，并置 errno 为 ETIMEOUT 。
		2.发布信号量
		  int sem_post(sem_t *sem);
			表示资源已经使用完毕，可以归还资源了。该函数会使信号量的值加 1 。
			如果发布信号量之前，信号量的值是 0 ，有多个进程正等待在信号量上，那么将无法确认哪个进程会被唤醒。
		3.获取信号量的值
		  int sem_getvalue(sem_t *sem, int *sval);
			返回当前信号量的值，并将值写入 sval 指向的变量
			当 sem_getvalue 返回时，其返回的值可能已经过时了。从这个意义上讲，该接口的意义并不大。
(3)无名信号量(用于多线程间的同步互斥)
	// 信号量是由 E.W.Dijkstra 为互斥和同步的高级管理提出的概念。
		1.有名信号量用于进程间资源访问的同步与互斥
		2.无名信号量用于线程间资源访问的同步与互斥
	①为什么要使用无名信号量
		1.无名信号量，由于其没有名字，所以适用范围要小于有名信号量。只有将无名信号量放在多个进
		  程或线程都共同可见的内存区域时才有意义，否则协作的进程无法操作信号量，达不到同步或互斥的目的。
		2.所以一般而言，无名信号量多用于线程之间。因为线程会共享进程的地址空间，所以访问共同的无名信号量是很容易办到的事情。
		3. 或者将信号量创建在共享内存内，多个进程通过操作共享内存的信号量达到同步或互斥的目的。
	②初始化.使用无名信号量
		int sem_init(sem_t *sem, int pshared, unsigned int value);
			pshared: 用于声明信号量是在线程间共享还是在进程间共享。
				  0 表示在线程间共享，非零值则表示信号量将在进程间共享。
			1.要想在进程间共享，无名信号量必须位于共享内存区域内。
			2.对于线程间共享的信号量，线程组退出了，无名信号量也就不复存在了。
			3.无名信号量初始化以后，就可以像操作有名信号量一样操作无名信号量了。
		int sem_wait(sem_t *sem);
		int sem_trywait(sem_t *sem);
		int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);
		int sem_post(sem_t *sem);
		int sem_getvalue(sem_t *sem, int *sval);
			  
	③销毁无名信号量
		int sem_destroy(sem_t *sem);
			1.销毁 sem_init 函数初始化的无名信号量。
			2.只有在所有进程都不会再等待一个信号量时，它才能被安全销毁。
(4)练习
/* 要求: 1.生产5个后广播消费者使用
		 2.消费到还剩一个后,通知生产者生产
		 3.生产期间不准消费, 消费期间不准生产
		 4.生产者0.5s生产一个, 每个消费者1s消费一个
		 5.使用无名信号量实现
----------------------------------------------------------------------------------------
【四】内存映射mmap
(1)概述
	①作用:在调用进程的虚拟地址空间中创建一个新的内存映射。
	②"文件映射"和"匿名映射"
		根据内存背后有无实体文件与之关联，映射可以分成以下两种：
		・ 文件映射：内存映射区域有实体文件与之关联。 
			1.mmap 系统调用将普通文件的一部分内容直接映射到调用进程的虚拟地址空间。
			2.一旦完成映射，就可以通过在相应的内存区域中操作字节来访问文件内容。这种映射也被称为基于文件的映射。
		・ 匿名映射：匿名映射没有对应的文件。这种映射的内存区域会被初始化成 0 。
			3.匿名映射没有对应的文件。这种映射的内存区域会被初始化成 0 。
	③一个进程映射的内存可以与其他进程中映射的内存共享物理内存。
		所谓共享是指各个进程的页表条目指向 RAM 中的相同分页。	
		
			<进程A页表>						  <物理内存>							
		------------------					--------------
		------------------					
		映射区域的页表项	---------   	
		------------------		↓			--------------
		------------------      ↓ 
								 →→→→→→→映射页	
			<进程B页表>			↑
		------------------		↑			--------------
		------------------      ↑	
		映射区域的页表项	---------   	
		------------------
		------------------					--------------
					
					(进程内存共享映射)
		这种内存映射的共享，会在以下两种情况下发生：
			・ 通过 fork ，子进程继承了父进程通过 mmap 映射的副本。
			・ 多个进程通过 mmap 映射了同一个文件的同一个区域。	
			注意:
			 1.虽然子进程拷贝了父进程的内存，但是父子进程的页表并不是始终都指向同一物理内存的，一旦父子进程中有一个尝试
			   修改内存的内容时，内核就不得不发起写时复制，分配新的物理内存。从此父子进程分道扬镳，彼此再也看不到对方对内存的改动。
			 2.对于进程 malloc 出来的内存，fork 之后父子进程并不是共享同一块映射。
	④"私有映射"和"共享映射"：
		私有映射( MAP_PRIVATE):
			1.在映射内容上发生的变更对其他进程不可见。
			2.对于文件映射而言，变更不会同步到底层文件中。
			3.对映射内容所做的变更是进程私有的。
			4.事实上，内核使用了写时复制技术来完成这个任务。未对映射内容进行修改操作时，页面仍然是共享的。
			  一旦有进程试图修改其中一个分页的内容时，内核首先会为该进程创建一个新的分页，并将需要修改的分页中的内容拷贝到新分页中。
	    共享映射（ MAP_SHARED ）：
			1.在映射内容上发生的所有变更，对所有共享同一个映射的其他进程都可见。
			2.对于文件映射而言，变更会同步到底层的文件中。
			3.很明显，共享映射是用于进程间通信的。
	⑤内存映射的分类及用途
		内存映射根据有无文件关联，分成文件与匿名；根据映射是否在进程间共享，分成私有和共享。这两个维度两两组合，内存映射共分成 4 种类型，
		--------------------------------------------------------------
						文件映射							匿名映射
		--------------------------------------------------------------
		共享映射		内存映射IO, 进程间共享物理内存		进程间共享内存
		--------------------------------------------------------------
		私有映射		根据文件内容初始化映射的内存			分配新内存
		--------------------------------------------------------------
(2)内存映射的相关接口
	①void *mmap(void *addr, size_t length, int prot, int flags,int fd, off_t offset);
		1.内存映射源: fd	offset length
			将 fd 对应的文件，从 offset 位置起，将长度为 length 的内容映射到进程的地址空间。
		2.对于文件映射: 调用 mmap 之前需要调用 open 取到对应文件的文件描述符。
		3.addr: 指定将文件对应的内容映射到进程地址空间的起始地址。一般来讲为了可移植性，该参数总是指定为 NULL ，
				表示交给	内核去选择合适的位置。
		4.prot: 设置对内存映射区域的保护
				-----------------------------------------
				  prot				说明
				-----------------------------------------
				PROT_READ:		映射的内容可读
				PROT_WRITE:		映射的内容可写
				PROT_EXEC:		映射的内容可执行
				PROT_NONE:		映射的内容不可访问
				-----------------------------------------
		5.flags: 用于指定内存映射是共享映射还是私有映射，也用于指定内存映射是文件映射还是匿名映射。
				-----------------------------------------
				 flags				说明
				-----------------------------------------
				MAP_SHARED		请求创建共享映射
				MAP_PRIVATE		请求创建私有映射
				MAP_ANONYMOUS	请求创建匿名映射, fd=-1
				MAP_FIXED		要求对进程的虚拟地址空间非常了解, 不建议使用
				-----------------------------------------
		6.注意:
		  1.mmap 系统调用的操作单元是页。参数 addr 和 offset 都必须按页对齐，即必须是页面大小的整数倍。
		  2.在 Linux 下，页面大小是 4096字节，该值可以通过 getconf 命令来获取到。
		  3.获取页大小： 
			getconf PAGESIZE		// shell
			long sysconf(int name); // 程序
		7.返回值
			当 mmap 调用成功时，则返回映射区域的起始地址，如果失败，则返回 MAP_FAILED ，并置 errno 。
			
		8.误解:调用 mmap 时，真的已经把文件对应区域的内容读取到了内存的对应位置。事实上并非如此， 
				mmap 仅仅是建立了两者之间的关联。当第一次读取映射区的内容或修改映射区的内容时，会
				引发缺页中断（ page fault ），这时候才会真正地将文件的内容加载到内存的对应位置。
	②int munmap(void *addr, size_t length);	// 解除内存映射		
		 addr: 是 mmap 返回的内存映射的起始地址	
		 length: 是内存映射区域的大小。	
		注意:
		  1.执行过 munmap 后，如果继续访问内存映射范围内的地址，那么进程会收到 SIGSEGV 信号，引发段错误。
		  2.关闭对应文件的文件描述符并不会引发munmap 。	
		  3.如果创建内存映射时 flags 中带上了 MAP_PRIVATE 标志位，那么解除该内存映射时，调用进程对内存映射的所有改动都会被丢弃。	
(3)共享文件映射
	①共享文件的建立和使用
		1）打开文件，获取文件描述符 fd ，这一步是通过 open 来完成的。
			1.打开文件时设置的权限必须要和 mmap 系统调用需要的权限相匹配。
		2）将文件描述符作为 fd 参数，传给 mmap 函数。			
		注意:
			1.没有映射某区域却强行访问，会引发段错误，产生 SIGSEGV 信号。
			2.访问的映射地址虽然在 mmap 映射的内存区域之内，但并不在文件长度的范围以内,会导致 SIGBUS 信号的产生。
				比如： 如果内存映射在使用过程中，调用 truncate 或 ftruncate 将文件截断，那么访问文件真实长度之外的区域，就会触发 SIGBUS 信号
				
	②共享文件映射的用途			
		操作文件：
			1.共享文件映射区域的内存，就等同于对文件的读写。
			2.对映射内容所做的修改，都会自动反应到文件上，内核会负责将修改最终同步到底层的块设备。	
			3.对于 read 和 write 接口而言，页高速缓存和用户空间缓冲区之间的数据传输是不可避免的。
			   但是如果使用 mmap 来操作文件，则不需要这次复制。 mmap 对共享文件映射的操作，直接作用在页高速缓存上，节省了一次数据传输。
		进程间通信：
			1.进程的地址空间是彼此隔离的，一个进程一般不能直接访问另一个进程的地址空间。
			2.通过共享文件映射，两个进程的映射区域指向了同一个物理内存（页高速缓存），这就给进程间通信提供了可能，	
			3.如果两个进程的共享文件映射都源自同一个文件的同一个区域，那么一个进程对映射区域的修改，
			   对于另外那个进程是立刻可见的，同时内核会负责在合适的时机将修改同步到底层文件。
			   这是因为两个映射区域的对应分页都指向了同一个页高速缓存（ Page Cache ），
			4.fcntl 函数提供了文件区域记录锁的功能,可以和mmap配合使用
(4)私有文件映射
	1.当调用 mmap 时，如果将 flags 设置成 MAP_PRIVATE 标志位，那么映射就是私有文件映射。
	2.最常见的情况就是前面提到的加载动态共享库，多个进程共享相同的文本段。
	3.文本段通常被保护成 PROT_READ|PROT_EXEC 。
	4.映射共享库时一般设置为: PROT_READ|PROT_EXEC, 为了防止被恶意程序篡改
(5)共享匿名映射
	①创建方法	
		方法一: 调用 mmap 时，在参数 flags 中指定 MAP_ANONYMOUS 标志位，并且将参数 fd 指定为 -1 。
		方法二: 打开 /dev/zero 设备文件，并将得到的文件描述符 fd 传递给 mmap 。	
		// 不论采用哪种方式，得到的内存映射中的字节都会被初始化成 0 。
	②作用:
		让相关进程共享一块内存区域。
		比如父进程创建一个共享匿名映射，然后 fork 创建子进程，这种情况下，父子进程就可以通过这块内存区域来通信。
(6)私有匿名映射
	①创建方法
		创建匿名映射时，将flags 中设置为 MAP_PRIVATE 标志位，
	②用途
		1.典型的用途是分配进程所需的内存。映射出来的内存并没有文件与之关联，对内存的操作也是私有的，不会影响到其他进程。
		2.比较典型的例子就是 glibc 中的 malloc 实现。当要分配的内存大于 MMAP_THREASHOLD 字节时， glibc 的 malloc 是使用 mmap 来实现的。
			strace工具跟踪到// mmap(NULL, 135168, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f2a29f0c000
----------------------------------------------------------------------------------------
【五】POSIX共享内存
	
##################################################################################
进程的虚拟地址空间:
1.虚拟存储器是一个抽象概念，它为每一个进程提供了一个假象，好像每个进程都在独占的使用主存。
  每个进程看到的存储器区是一致的，称之为虚拟地址空间。
2.每个进程看到得虚拟地址空间由大量准确定义的区（area）构成，每个区都有专门的功能。
3.当进程创建时，每个进程都会有一个自己的 4GB 虚拟地址空间。要注意的是这个 4GB 的地址空间是“虚拟”的，
	并不是真实存在的.
4.而且每个进程只能访问自己虚拟地址空间中的数据，无法访问别的进程中的数据，
	通过这种方法实现了进程间的地址隔离。
5.32位机器，每个程序有4G的虚拟地址空间。大致分为4块，从低地址到高地址依次是：NULL区，用户区，隔离区，核心区。
6.用户私有的数据都在用户区,系统内核等东西都在核心区。
7.总体来说，A进程的虚拟地址空间中的内容和B进程相比，只有各自的用户区不一致。
8.malloc 分配的内存区域完全归调用进程所有，其他进程不可见，
##############################################################################################################
						第12章 网络通信：连接的建立
							    网络通信基础
##############################################################################################################
【一】重点内容
	(1)网络通信模型,相关专业术语
	(2)TCP/DUP通信的过程及相关API
	(3)使用TCP协议常见的五种模型实现不同主机的通信
		一: 多线程实现TCP广播
		二: TCP点播
		三: 轮询非阻塞的方式实现对套接字的检测
		四: 多进程实现TCP
		五: UDP的广播和UDP组播
	(4)TCP同行中的三次握手和四次握手
	(5)四类网络地址
	(6)unix域套接字
---------------------------------------------------------------------------------------------------
【二】计算机编程中ISO协议
	数据帧： 传送的协议数据单元
	协议:    人为的规定计算机网络中每个层次发送数据的规则
	1.物理层(网卡): 
			1.两个硬件之间怎么通信。定义物理设备的标准：网线的接口类型、光纤的接口类型、各种传输介质的传输速率
			2.建立、维护和取消物理连接。如：中继器和集线器
			3.主要作用是传输比特流	
			
	2.数据链路层(驱动)	
			1.解决两个相邻结点之间的可靠传输问题。
			2.定义了如何让格式化数据以进行传输，以及如何控制对物理介质的访问以及差错校验等功能	。
			3.通过使用接收系统的硬件地址或物理地址来寻址


	3.网络层（路由器、交换机）: IP协议
		当有多台计算机时，解决数据包如果通过各结点传送的问题，即通过路径选择算法（路由）将数据包送到目的地。
		网络层：即路由器，交换机那些具有寻址功能的设备所实现的功能。
				这一层定义的是IP地址，通过IP地址寻址。所以产生了IP协议。	
	4.传输层：（TCP/UDP）
		1.提供了应用进程之间的端-端连接。一个电脑可能有多个进程同时在使用网络连接，那么网络包达到主机之后，
		  怎么区分自己属于那个进程？这就需要靠传输层的作用了。
		2.用一个寻址机制来标识一个特定的应用程序（端口号）
		3.传输层协议能提供应用的多路复用/分用服务、可靠数据传送、带宽保证及延迟保证等。
			复用：当传输层从应用程序接收报文后要封装在传输层的段中再交给网络层发送。
			分用：当传输层从网络层接收数据后，必须将数据正确递交给某个应用程序。
			可靠数据传输: TCP
			流量控制:防止接收端速度太慢造成溢出和丢包的现象。 
	5.会话层:
		1.解决用户级别的体验不好？难道我每次都要调用TCP去打包，然后调用IP协议去找路由，自己去发？
		  当然不行，所以我们要建立一个自动收发包，自动寻址的功能。
		2.建立和管理应用程序之间的通信
	6.表示层:
		1.解决不同系统之间的通信语法问题:数据表示、数据安全、数据压缩。
		2.现在我能保证应用程序自动收发包和寻址了。但是我要用Linux给window发包，两个系统语法不一致，于是需要表示层（presentation）.
	7.应用层	
		1.网络服务与使用者应用程序间的一个接口
		2.该层通过应用程序来完成网络用户的应用需求，如文件传输、收发电子邮件等
---------------------------------------------------------------------------------------------------
【三】TCP/IP模型四层模型		
			应用层
				应用层: 用户和网络的接口, 传输文件, 邮件
				表示层: 数据压缩, 数据安全, 数据表示 
				会话层: 自动收发包，自动寻址
            传输层: 	(TCP/IP)应用进程之间的端-端连接
            网络层:     (路由, 交换机)发包的路径选择算法
            网络接口层  
				数据链路层: 驱动, 格式化传输
				物理层:	硬件接口类型, 集线器, 中继器, 比特流	  
	张三发送信息给李四，张三这边是从上到下，李四那边是从下到上。
    下层协议为上层提供了实现的基础。
  
---------------------------------------------------------------------------------------------------
【四】两种IP地址
	1.IPV4:	长度32位: 192.168.1.101(点分十进制写法)
	2.IPV6: 长度128位
---------------------------------------------------------------------------------------------------
【五】地址分类: 有两个特点
	注意: IP地址用4个字节表示。点分十进制形式中xxxx,xxxx,xxxx,xxxx，每一个逗号包含一个字节
			// 第一个字节全0和全1不用。	
	A类地址: 1).第1个字节为网络地址， 后3个字节为主机地址。
			 2).第1个字节的最高位固定为0
			    1.0.0.1    ～	126.255.255.255
	B类地址: 1).前2个字节为网络地址， 后2个字节为主机地址。
			 2).第1个字节的前2位固定为10
				128.0.0.1  ～   191.255.255.255
	C类地址: 1).前3个字节为网络地址， 后1个字节为主机地址。
			 2).第1个字节的前3位固定为110
				192.0.0.1  ～   223.255.255.255
	D类地址: （组播地址）
			 1).不分网络地址和主机地址， 
			 2).第一个字节固定为1110	
				224.0.0.1  ～   239.255.255.255
			 3).组播地址分类
				224.0.0.0～224.0.0.255	   为预留的组播地址（永久组地址），地址224.0.0.0保留不做分配，其它地址供路由协议使用。
				224.0.1.0～238.255.255.255 为用户可用的组播地址（临时组地址），全网范围内有效。
				239.0.0.0～239.255.255.255 为本地管理组播地址，仅在特定的本地范围内有效。	
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx						
						
端口号: 用于区分同一台主机上不同的进程(服务): u16, 实际使用时用1024以后的去选择(0-1024可能被系统占用)
【一】寻址：标识一个目标通信进程
	进程标识由两部分组：
		计算机的网络地址： 标识网络上我们想与之通信的计算机。
		用端口号表示服务： 标识特定的进程
	(1)字节序
		1.大端和小端：
			大端： 低地址上存放高字节数据
			小段： 低地址上存放低字节数据
		2.TCP/IP协议栈使用大端字节序
		3.对于TCP/IP应用程序， 用以下函数来处理(处理器字节序)和(网络字节序)之间实施转换
			处理过程: 被转换的为大端时不进行转换, 为小端时进行转换
			u32 htonl(u32 host)			// 转换成32位IP地址(转换成:网络字节序)
			u16 htons(u16 host)			// 转换成16位端口号(转换成:网络字节序)
			u32 ntohl(u32 net)			// 转换成32位IP地址(转换成:主机字节序)
			u16 ntohs(u16 net)			// 转换成16位端口号(转换成:主机字节序)
			
				// 点分十进制IP字符串和IPv4地址的in_addr结构相互转换
			int inet_aton(const char *cp, struct in_addr *inp);
			char *inet_ntoa(struct in_addr in);	
				// 点分十进制IP字符串和32ip网络字节序相互转换
			in_addr_t inet_addr(const char *cp)     // 将点分十进制IP字符串转换为网络字节序	
			in_addr_t inet_network(const char *cp);	// 将点分十进制IP字符串转换为主机字节序	
				// 将IP地址在“点分十进制”和“二进制整数之间转换, 支持 AF_INET or AF_INET6.
			const char *inet_ntop(int af, const void *src,char *dst, socklen_t size);
			int inet_pton(int af, const char *src, void *dst);
			 
				例: sin_port = htonl(INADDR_ANY)	// 返回主机上任意一个能用的IP
				例: svr_addr.sin_addr.s_addr = inet_addr("192.168.1.166");
		4.将IP地址在“点分十进制”和“二进制整数”(网络字节序)之间转换
			// 将网络字节序二进制地址转换成文本字符串格式
			const char *inet_ntop(int af, const void *src,char *dst, socklen_t size);
                             
			// “点分十进制”转换为“二进制整数”(网络字节序)
			int inet_pton(int af, const char *src, void *dst);
				domain:  协议族
				src:    “点分十进制”IP地址字符串
				dst:	存放转换后的结构struct in_addr, 4个字节
		5.常用举例:
			struct sockaddr addr;
			addr.sin_port        = htons(8888);				// 主机端口
			addr.sin_addr.s_addr = inet_addr("192.168.1.104");
			addr.sin_addr.s_addr = htonl(INADDR_ANY);
			printf("ip = %s\n", inet_ntoa(addr.sin_addr));			   // 打印出点分十进制  
			
	(2)地址格式
		1.地址格式与特定的通信域相关，为了使不同格式的地址能够传入到套接字函数，地址会被强制转换成一个通用的地址结构
			通用地址结构体： 
			struct sockaddr {
				sa_family_t sa_family;  // 地址族: AF_INET AF_INET6 AF_UNIX(2Byte)
				char sa_data[14]; 		// 存放IP地址和端口号 (14Byte)
			};
		2.因特网IPV4（AF_INET）,套接字地址用
			struct in_addr {
				in_addr_t s_addr; 		 /* IPv4 address */
			};
			struct sockaddr_in {
				sa_family_t sin_family;    // 地址族： AF_INET AF_INET6 AF_UNIX(2Byte)
				in_port_t sin_port;	 	  // 端口号	  (2Byte)
				struct in_addr sin_addr;  // IPv4地址 (4Byte)
				unsigned char sin_zero[8] // 用于和通用地址结构sockaddr对齐 (8Byte), 方便类型转换
			};
		3.因特网IPV6（AF_INET6）
			struct in6_addr {
				uint8_t s6_addr[16];	 	/* IPv6 address */
			};
			struct sockaddr_in6 {
				sa_family_t sin6_family; 	/* address family */
				in_port_t sin6_port; 	 	/* port number */
				uint32_t sin6_flowinfo;  	/* traffic class and flow info */
				struct in6_addr sin6_addr;  /* IPv6 address */
				uint32_t sin6_scope_id;		/* set of interfaces for scope */
			};	
		4.unix本地域套接字(用于一台主机的不同进程见得通信)
			struct sockaddr_un {
				u_short sun_family;
				char sun_path[108];		// 存放绑定时生成文件的路径
			}
		
		
        5.虽然sockaddr_in和sockaddr_in6差异很大，但是他们均被强制转换成 sockaddr输入到套接字例证中

	(3)地址查询
		1.获得/设置计算机系统主机信息
			struct hostent *gethostent(void);
			void sethostent(int stayopen);
			void endhostent(void);
		2.每个服务用唯一的端口号来标识。
			struct servent *getservbyname(const char *name, const char *proto);
			struct servent *getservbyport(int port, const char *proto); //将一个端口号映射到服务名
			struct servent *getservent(void);
			void setservent(int stayopen);					// 顺序扫描服务数据库
			void endservent(void);	
		3.将主机名和一个服务名映射到地址
			int getaddrinfo(const char *restrict host,
				const char *restrict service,
				const struct addrinfo *restrict hint,
				struct addrinfo **restrict res);
			void freeaddrinfo(struct addrinfo *ai);	
		4.如果getaddrinfo失败, 不能使用perror或strerror来生产错误消息, 要调用下面的函数将返回的错误码转换成错误消息。
			const char *gai_strerror(int error);
		5.将一个将地址翻译成一个主机名和一个服务名
			int getnameinfo(const struct sockaddr *restrict addr, socklen_t alen,
				char *restrict host, socklen_t hostlen,
				char *restrict service, socklen_t servlen, int flags);
【二】套接字描述符(socket)
	(1)引入
		1.套接字时通行端点的抽象
		2.套接字描述符在UNIX系统中被当做一种文件描述符
		3.事实上许多文件描述符的函数（如read、write）可以用于处理套接字描述符
		4.	待连接套接字:	socket函数创建的套接字
			监听套接字:		listen()调用之后的套接字
			已连接套接字:	accept()调用后返回的新套接字
	(2)创建套接字
	   int socket(int domain, int type, int protocol);
		domain: 地址族
		type:   套接字类型
		protocol: 为给定的地址族和套接字类型选择默认协议
		error, -1 is returned,
		----------------------------------------------------------------------------------
		①Domain Description
			域				描述
			AF_INET 		IPv4 网域
			AF_INET6 		IPv6 网域
			AF_UNIX 		UNIX 域套接字
			AF_UNSPEC		未指定		
		②type套接字类型
			类型			描述
			SOCK_DGRAM:		固定长度的、无连接的、不可靠的传递（UDP）、无序的
			SOCK_RAW: 		IP协议的数据报接口 
			SOCK_SEQPACKET：固定长度的、有序的、可靠地、面向连接的报文 
			SOCK_STREAM ：  有序的、可靠地、双向的、面向连接的字节流(TCP)		
			说明：
				1.SOCK_SEQPACKET与SOCK_STREAM类似，区别是接收到的是报文服务，而不是字节流服务
				2.SOCK_RAW直接访问下面的网络层
		③protocol通常是0，表示为给定的域和套接字类型选择默认协议
		----------------------------------------------------------------------------------
	(3)禁止套接字I/O
		int shutdown(int sockfd, int how);
			how的行为:
			 SHUT_RD  : 关闭读端
			 SHUT_WR  : 关闭写端
			 SHUT_RDWR: 关闭读写端
	(4)TCP和UDP的区别
		UDP: 
			1.对于SOCK_DGRAM接口, 两个对等进程之间通信时不需要逻辑连接，只需要向对等进程所使用的套接字送出一个报文
			2.数据报时自包含报文，发送数据报近似于给某人邮寄信件。
				1.你能寄很多信
				2.但你不能保证传递的秩序
				3.并且有些信件可能丢失在路上，
				4.每封信都包含接收者的地址，使这封信独立于所有其他信件。每封信可能送达不同的接收者
		TCP：
			1.SOCK_STREAM字节流要求在交换数据之前，在本地套接字和和通信对等的套接字之间建立一个逻辑连接
			2.面向连接的协议就像与对方打电话。
				1.首先需要通过电话建立一个连接
				2.每个连接都是端到端的通信链路（进程服务到进程服务）
				3.对话中不包含地址信息，就像呼叫两端存在一个点对点的虚拟连接，并且连接本身暗示特定的源和目的地
	(5)以文件描述符为参数的函数使用套接字描述符的行为	
		-------------------------------------------------------------------------------------------
		函数				 				使用套接字时的行为
		close (Section 3.3) 				释放套接字
		dup, dup2 (Section 3.12) 			和一般描述符一样复制
		fchdir (Section 4.23) 				失败, with errno set to ENOTDIR
		fchmod (Section 4.9) 				未指定
		fchown (Section 4.11) 				由实现定义
		fcntl (Section 3.14) 				支持一些命令:如 F_DUPFD,F_GETFD, F_GETFL, F_GETOWN,and F_SETOWN F_DUPFD_CLOEXEC, F_SETFD, F_SETFL, 
		fdatasync, fsync (Section 3.13) 	由实现定义
		fstat (Section 4.2) 				支持一些stat结构成员
		ftruncate (Section 4.13) 			未指定
		ioctl (Section 3.15) 				支持部分,依赖于底层驱动
		lseek (Section 3.6) 				由实现定义
		mmap (Section 14.8)					未指定
		poll (Section 14.4.2) 				正常工作
		pread and pwrite (Section 3.11) 	fails with errno set to ESPIPE
		read (Section 3.7) and readv		没有任何标志位的recv(Section 14.6)等价
		select (Section 14.4.1) 			正常工作
		write (Section 3.8) and writev		没有任何标志位的send(Section 14.6)等价
		-------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------
【三】服务器套接字与地址绑定（bind）
	地址: IP地址 + 端口号
	(1)为什么服务器套接字需要绑定地址, 而客户端套接字不要与IP绑定
		1.绑定的地址中的端口是编程人员预先给服务器设置一个确定的端口，而不是由系统随机分配一个端口。
		2.服务器绑定了某一个地址，客户端才能通过该端口向服务器发起连接请求。
		3.如果不绑定地址，而是由系统随机分配给服务器一个地址，既然是随机的，那么客户端也不知道系统分配的是哪个端口。
			客户端不知道服务器的地址，还怎么与服务器通信呢？
		4.客户端就不需要绑定地址了，系统随机分配一个就可以了。当客户端第一次向服务器发送数据时，客户端的地址随同数据一起就给了服务器。
			服务器有了客户端的地址自然就可以向客户端发送数据。	
	(2)int bind(int sockfd, const struct sockaddr *addr, socklen_t len);
		・sockfd ：表示要绑定地址的套接字描述符。
		・addr ：表示绑定到套接字的地址。
		・addrlen ：表示绑定的地址长度。sizeof(server_addr)或者sizeof(client_addr)
		返回值: 0 表示成功， -1 则表示错误。	
		对于绑定的地址有以下限制:
			1.指定的地址必须是当前进程运行所在计算机上的有效地址
			2.地址的地址族必须和sockfd的地址族匹配
			3.地址中的端口必须不小于1024(1025～65536)	// 地址族占2个字节
			4.一般只能将一个套接字端口绑定到一个给定的地址上
	(3)发现绑定到套接字上的地址
		int getsockname(int sockfd, struct sockaddr *restrict addr,socklen_t *restrict alenp);
		
	(4)如果套接字已经和对等方连接, 找到对方的地址
		int getpeername(int sockfd, struct sockaddr *restrict addr,socklen_t *restrict alenp);
---------------------------------------------------------------------------------------------------
【四】客户端套接字(主动)与服务端套接字之间连接（connect）
	地址: IP地址 + 端口号
	(1)为什么是客户端主动连接服务端?
		1.服务端的套接字与地址进行了绑定, 而客户端的地址是由系统随机分配的(没有和客户端套接字绑定)
		2.所以,客户端的地址不能确定, 故只能是客户端主动去连接服务端
	(2)int connect(int sockfd, const struct sockaddr *addr, socklen_t len);
		・int sockfd ：套接字描述符。
		・const struct sockaddr *addr ：要连接的服务端地址。
		・socklen_t addrlen ：要连接的地址长度, sizeof(server_addr)。	
			返回值 0 表示成功， -1 表示失败。
		1.如果服务端套接字sockfd没有绑定到一个地址,调用connect时,系统会给sockfd绑定一个未使用的默认地址
		2.connect 的用途是使用指定的套接字去连接指定的地址。对于面向连接的协议（套接字类型为SOCK_STREAM ），
			connect 只能成功一次（因为真正的连接已经建立了）。
		3.而对于非面向连接的协议（套接字类型为SOCK_DGRAM ），则可以执行多次connect（因为这时的 connect 仅仅是设置了默认的目的地址）。
		4.connect是一个阻塞型的接口,因为对于 TCP 套接字来说， connect 实际上是要真正地进行三次握手。
		5.无论是 UDP 还是 TCP ，都可以进行连接
		
---------------------------------------------------------------------------------------------------
【五】服务器调用listen来宣告他愿意同时监听已连接客户端的最大路数（listen）
	(1)int listen(int sockfd, int backlog);
		・int sockfd ：成功创建的 TCP 套接字。
		・int backlog ：定义 TCP 监听客户端的最大路数。
		0.仅仅对创建的TCP套接字可以进行监听, UDP套接字调用listen会出错				
		1.一旦路数满了,系统就会拒绝多余的连接请求。
		2.一旦服务器调用了listen，所用的套接字就能接收连接请求。未被监听的套接字不能与客户端套接字连接。
	(2)监听套接字的特点
		1."监听套接字", 默认为不可读状态
		2.当调用accept时, "监听套接字"使accept阻塞。
		3.当有一个客户端连接上"监听套接字"，且accept函数返回之前。
		  这一段时间内,"监听套接字"为可读状态。
		4.当accept函数返回新套接字后， "监听套接字"又恢复为不可读状态
			可调用select和poll对监听套接字进行监视
---------------------------------------------------------------------------------------------------
【六】服务器获得客户端连接请求并与之建立连接（accept）	
	int accept(int sockfd, struct sockaddr *restrict addr,socklen_t *restrict len);	
	・int sockfd ：			 处于监听状态的套接字。
	・struct sockaddr*addr ：用于保存对端(客户端)的地址信息。如果不需要设置NULL
	・socklen_t*addrlen ：	 是一个输入输出值。调用者将其初始化为 addr 缓存的大小， accept 返回时，会将其设置为 addr 的大小。
						如果不保存客户端地址, 就设置为NULL。	
	・int flags ：	是新引入的系统调用 accept4 的标志位；目前支持 SOCK_NONBLOCK 和SOCK_CLOEXEC 。
	・返回值:		若执行成功，则返回一个非负的文件描述符；若失败则返回 -1 。
	・注意: 　
		// 只有调用了listen函数后, accept函数才能被调用。 否则accept会返回错误
		// 只能对TCP套接字进行accept, 对UDP套接字进行
		0.若不关心对端地址信息	
		1.一旦服务器调用了listen，所用的套接字就能接收请求
		2.accept所返回的文件描述符是套接字描述符，该描述符连接到调用connect的客户端。
		  这个返回的新套接字描述符和原始套接字（sockfd）具有相同的套接字类型和地址族。
		3.传给accept的原始套接字（sockfd）没有关联到这个连接，而是继续保持可用状态并接受其他连接请求。
		4.如果不关心客户端标识，可将产生addr和len设置为NULL
		5.如果没有连接请求在等待，accept函数会阻塞直到一个请求到了
		6.服务器可用调用poll或者select来等待一个请求的到来。在这种情况下一个等待连接请求的客户端套接字请求会以可读的方式出现。
---------------------------------------------------------------------------------------------------
【七】数据传输
	(0) read/write
	(1)数据发送
		1.ssize_t send(int new_sockfd, const void *buf, size_t len, int flags);
			//send只能用于处理已经连接状态的套接字
			1.类似于write, 使用send时套接字必须已经连接
			2.	/* Send N bytes of BUF to socket FD.  Returns the number sent or -1.
			3.flags, 允许非阻塞等操作(一般为0)
				MSG_CONFIRM		MSG_DONTROUTE		MSG_DONTWAIT
				MSG_EOR			MSG_MORE			MSG_NOSIGNAL	MSG_OOB(发送紧急带外数据)
			4.即使send成功返回,也不代表连接的另一端，只能保证数据发送到了驱动上
			5.对于无连接的套接字，除非先调用connect设置了目标地址，否则不能使用send
		-----------------------------------------------------------------------------	
		2.ssize_t sendto(int new_sockfd, const void *buf, size_t len, int flags,
				const struct sockaddr *dest_addr, socklen_t addrlen);
			sockfd：socket文件描述字	
			buf：		指明一个存放应用程序要发送数据的缓冲区
			len：		指明buf的长度
			flag：	    一般设置为0
			dest_addr： 表示目的机的地址和端口号信息
			addrlen：   常被赋值为sizeof(struct sockaddr)	
			返回值:     成功返回发送的字节数, 失败返回-1
			// 对于面向连接的套接字，目标地址是被忽略的，因为连接中隐含了目标地址
		-----------------------------------------------------------------------------	
		
		3.ssize_t sendmsg(int new_sockfd, const struct msghdr *msg, int flags);
			用msghdr结构来指定多重缓冲区传输数据
		-----------------------------------------------------------------------------
		[注意]: 1.send 只能用于处理已连接状态的套接字, 不管是否连接sendto and sendmsg都可以使用
				2.无论是 UDP 还是 TCP ，都可以进行连接
				3.sendto 可以在调用时，指定目的地址(就像寄快递一样)。如果套接字已经是连接状态，
					那么目的地址 dest_addr 与地址长度就应该为 NULL 和 0 ，不然就可能会返回错误。
				4.sendmsg 则比较特殊，无论是要发送的数据还是目的地址，都保存在 msg 中。其中 msg.msg_name 和
					msg.msg_len 用于指明目的地址，而 msg.msg_iov 则用于保存要发送的数据。
				5.这三个系统调用都支持设置指示标志位 flags 。
				
		4.ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count)
			in_fd : 被打开是等待读数据的fd, 必须是一个支持mmap函数的文件描述符，也就是说必须指向真实文件，不能是socket描述符和管道
			out_fd: 被打开是等待写数据的fd, 必须是一个socket描述符。
			Offset: 是在正式开始读取数据之前应该向前偏移的byte数.
			count : 是需要在两个fd之间“搬移”的数据的byte数.
			说明: 
				1.sendfile是"零拷贝"
				2.sendfile几乎是专门为在网络上传输文件而设计的。
				3.read/write的缺点: 要执行4次内存拷贝, 和用户态到内核态的上下文切换开销
					1.调用read(2)函数，文件数据被copy到内核缓冲区
					2.read(2)函数返回，文件数据从内核缓冲区copy到用户缓冲区
					3.write(2)函数调用，将文件数据从用户缓冲区copy到内核与socket相关的缓冲区。
					4.数据从socket缓冲区copy到相关协议引擎				
				4.sendfile
					1.避免了不必要的内存拷贝。
					2.避免了额外的用户态/内核态上下文切换（Context Switch）
			
	(2)数据接收
    ssize_t recv(int sockfd, void *buf, size_t len, int flags);
		sockfd：服务端中是accept返回的套接字描述符，客户端中是socket创建的
		buf：   存储缓冲区  
		flags： len， 想要读取的字节数， 可以填sizeof（buf）;
			MSG_PEEK： 查看下一个要读取的数据但不真正的取走它，调用read或区中一个recv函数时，才会真正的返回查看的数据
			MSG_WAITALL： 对于SOCK_STREAM套接字，接收的数据可以比预期的少，但是使用了该标志后，直到所请求的数据全部返回，recv才会返回
			MSG_CMSG_CLOEXEC	MSG_DONTWAIT	MSG_ERRQUEUE	MSG_OOB MSG_TRUNC
			错误返回-1, 成功返回发送的字节数		
		注意: 如果服务器端/客户端断开连接了,那么当所有数据接收完毕后，recv会返回0	
			// 我们接受数据时应该判断这个返回值， 如果为0， 我们不应该关闭接收对应的套接字
	-----------------------------------------------------------------------------
	ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,
					struct sockaddr *src_addr, socklen_t *addrlen);
		sockfd：标识一个已连接套接口的描述字。
		buf：接收数据缓冲区。
		len：缓冲区长度。	
		flags: 一般设置为0;
		from：（可选）指针，指向装有源地址的缓冲区。
		fromlen：既是输入值又是输出值。 如果from不为NULL, addrlen需要指向一个整数，表示src_addr的大小； 函数返回时被设置为src_addr的长度
			通常为NULL, 或者sizeof(sockaddr)
		// 如果不关心发送数据的进程地址, 可将from和fromlen都设为NULL
			1.如果addr非空，他将包含发送者套接字的端点地址
			2.因为可以获取发送者的地址，所以常用于无连接的套接字
	-----------------------------------------------------------------------------
	ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags);	
		1.msghdr指定接收数据的输入缓冲区，可以设置flags来改变recvmsg的默认行为
	-----------------------------------------------------------------------------
	(3) 对于UDP套接字连接了客户端:
			1.只能是客户端向服务端发数据
			2.服务端不能像服务器发送数据(包括所有发送函数)
---------------------------------------------------------------------------------------------------
【八】TCP广播和点播
		每连接一个客户端，就将客户端地址和accept返回的新套接字放入链表
	广播：向链表中节点对应项的新套接字发送消息
	点播：从链表中找到想要发送的IP, 发送消息给对应的新套接字
---------------------------------------------------------------------------------------------------
【九】设置.获得套接字的属性
	int getsockopt(int sockfd, int level, int optname,void *optval, socklen_t *optlen);
	int setsockopt(int sockfd, int level, int optname,const void *optval, socklen_t optlen);							
		1.sockfd: 要设置的描述符
---------------------------------------------------------------------------------------------------
【十】TCP传输流程图
		服务端						客户端
		socket						socket
		bind				
		listen	
	while(1){
		accept	←三次握手的建立→	connect	// 调用connect时, 如果客户端没有绑定地址, 系统会给客户端绑定一个可用的地址
	}
		send /recv					send /recv
		close						close
							

######################################################################################################		
######################################################################################################		
							第13、14章	TCP UDP综述
---------------------------------------------------------------------------------------------------
【一】设置套接字的属性
	int setsockopt(int sockfd, int level, int optname,const void *optval, socklen_t optlen);
		1.setsockopt()函数用于任意类型、任意状态套接口的设置选项值。
		2.尽管在不同协议层上存在选项，但本函数仅定义了最高的“套接口”层次上的选项。
		3.选项影响套接口的操作，诸如加急数据是否在普通数据流中接收，广播数据是否可以从套接口发送等等。
		4.大多数套接字级选项都使用int参数进行optval。 对于setsockopt（），参数应该是非零以启用布尔选项，或者如果要禁用该选项则为零。
			optlen = sizeof(int)	
		5.对其他选项，optval指向包含所需选项的结构，而optlen则为结构的长度。
	(1)参数
		s：标识一个套接口的描述字。
		level：选项定义的层次；目前仅支持SOL_SOCKET和IPPROTO_TCP层次。
			SOL_SOCKET:	 	// 基本套接口   
			IPPROTO_IP:  	// IPv4套接口   
			IPPROTO_IPV6: 	// IPv6套接口   
			IPPROTO_TCP: 	// TCP套接口
			1.如果想要在套接字级别上设置选项，就必须把level设置为 SOL_SOCKET。
		optname：		需设置的选项。
			optname可以有哪些取值，这取决于level。
			SO_DEBUG		// 打开或关闭调试信息。
				当option_value不等于0时，打开调试信息，否则，关闭调试信息。
			SO_REUSEADDR，  // 打开或关闭地址复用功能。
				1.当option_value不等于0时，打开，否则，关闭。缺省条件下，一个套接口不能与一个已在使用中的本地地址捆绑（参见bind()）。
				2.应用程序可在bind()调用前先设置SO_REUSEADDR选项。	
			SO_DONTROUTE    // 打开或关闭路由查找功能。禁止选径；直接传送。	
				当option_value不等于0时，打开，否则，关闭。   
			SO_BROADCAST	// 允许或禁止发送广播数据。
				1.当option_value不等于0时，允许，否则，禁止。	
				2.一般在发送UDP数据报的时候，希望该socket发送的数据具有广播特性：
					int bBroadcast = 1;
					setsockopt( s, SOL_SOCKET, SO_BROADCAST, ( const char* )&bBroadcast, sizeof( int ) );
			SO_SNDBUF		// 设置发送缓冲区的大小。
			SO_RCVBUF		// 设置接收缓冲区的大小。
				1.发送缓冲区限制。 上限：256 * (sizeof(struct sk_buff) + 256)，下限：2048字节。	
				2.设置发送缓冲区：
					int nSendBuf = 32*1024; //设置为32K
					setsockopt( s, SOL_SOCKET, SO_SNDBUF, ( const char* )&nSendBuf, sizeof( int ) );
				3.设置接收缓冲区：
					int nRecvBuf = 32 * 1024; //设置为32K
					setsockopt( s, SOL_SOCKET, SO_RCVBUF, ( const char* )&nRecvBuf, sizeof( int ) );		
				4.在发送数据的时，不执行由系统缓冲区到socket缓冲区的拷贝，以提高程序的性能：
					int nZero = 0;
					setsockopt( socket, SOL_S0CKET, SO_SNDBUF, ( char * )&nZero, sizeof( nZero ) );
			SO_KEEPALIVE	// 套接字保活
				如果协议是TCP，并且当前的套接字状态不是监听(listen)或关闭(close)，
				那么，当option_value不是零时，启用TCP保活定时器，否则关闭保活定时器。
			SO_OOBINLINE	// 紧急数据放入普通数据流
			SO_NO_CHECK		// 打开或关闭校验和
			SO_PRIORITY		// 设置在套接字发送的所有包的协议定义优先权。
				这个值在0到6之间（包括0和6），由option_value指定。
				
			SO_LINGER		// 如果选择此选项, close或 shutdown将等到所有套接字里排队的消息成功发送或到达延迟时间后>才会返回. 否则, 调用将立即返回。	
			SO_DONTLINER 	// 不要因为数据未发送就阻塞关闭操作。	
			SO_PASSCRED		// 允许或禁止SCM_CREDENTIALS 控制消息的接收。
			SO_TIMESTAMP	// 打开或关闭数据报中的时间戳接收。
			SO_RCVLOWAT		// 设置接收数据前的缓冲区内的最小字节数。	
				在Linux中，缓冲区内的最小字节数是固定的，为1。
			SO_RCVTIMEO		// SO_SNDTIMEO，设置发送超时时间。
			SO_BINDTODEVICE // 将套接字绑定到一个特定的设备上。	
			SO_ATTACH_FILTER和SO_DETACH_FILTER // 关于数据包过滤，它们最终会影响sk->sk_filter。
			TCP_NODELAY		// TCP_NODELAY选项禁止Nagle算法。	
		返回值：
			1.若无错误发生，setsockopt()返回0。否则的话，返回SOCKET_ERROR错误，
			2.应用程序可通过WSAGetLastError()获取相应错误代码。	
		optval：		指针，指向存放选项值的缓冲区。
		optlen：		optval缓冲区的长度。	
		
	(2)常用属性设置的范例：
		1.设置套接字地址可复用：
			const int bReuseaddr = 1;
			setsockopt(s,SOL_SOCKET ,SO_REUSEADDR,(const void*)&bReuseaddr,sizeof(bReuseaddr));
		2.如果要已经处于连接状态的soket在调用closesocket后强制关闭，不经历TIME_WAIT的过程：
			int bDontLinger = 0; 
			setsockopt(s,SOL_SOCKET,SO_DONTLINGER,(const void*)&bDontLinger,sizeof(bReuseaddr));
		3.在sendto(),recvfrom()过程中有时由于网络状况等原因，发收不能预期进行,而设置收发时限：
			setsockopt(socket，SOL_S0CKET,SO_SNDTIMEO，(char *)&nNetTimeout,sizeof(int));
			setsockopt(socket，SOL_S0CKET,SO_RCVTIMEO，(char *)&nNetTimeout,sizeof(int));
		4.在send()的时候，返回的是实际发送出去的字节(同步)或发送到socket缓冲区的字节(异步);
		5.系统默认的缓冲区发送和接收一次为8K，在实际的过程中发送数据和接收数据量比较大，可以设置socket缓冲区，而避免了send(),recv()不断的循环收发：
			// 接收缓冲区
			int nRecvBuf=32*1024;//设置为32K
			setsockopt(s,SOL_SOCKET,SO_RCVBUF,(const void*)&nRecvBuf,sizeof(int));
			//发送缓冲区
			int nSendBuf=32*1024;//设置为32K
			setsockopt(s,SOL_SOCKET,SO_SNDBUF,(const void*)&nSendBuf,sizeof(int));
		6.如果在发送数据的时，希望不经历由系统缓冲区到socket缓冲区的拷贝而影响程序的性能：
			int nZero=0;
			setsockopt(socket，SOL_S0CKET,SO_SNDBUF，(void *)&nZero,sizeof(nZero));
		7.同上在recv()完成上述功能(默认情况是将socket缓冲区的内容拷贝到系统缓冲区)：
			int nZero=0;
			setsockopt(socket，SOL_S0CKET,SO_RCVBUF，(void *)&nZero,sizeof(int));
		8.一般在发送UDP数据报的时候，希望该socket发送的数据具有广播特性：
			int bBroadcast=1; 
			setsockopt(s,SOL_SOCKET,SO_BROADCAST,(const void*)&bBroadcast,sizeof(int));
		9.设置客户端套接字加入多播组
			struct ip_mreq mreq;
			memset(&mreq, 0, sizeof(mreq))
			mreq.imr_multiaddr.s_addr = inet_addr("组播地址") // 组播地址是D类地址
			mreq.imr_interface.s_addr = htonl(INADDR_ANY)	 // 客户端网卡地址
								或	   inet_addr("客户端网卡地址");
			setsockopt(socketfd, IPPROTO_IP,IP_ADD_MEMBERSHIP, &mreq, sizeof(mreq));
		10.设置客户端套接字多播组中剔除
			setsockopt(socketfd, IPPROTO_IP,IP_DROP_MEMBERSHIP, &mreq, sizeof(mreq));
		11.在client连接服务器过程中，如果处于非阻塞模式下的socket在connect()的过程中可以设置connect()延时，直到accpet()被呼叫
			int bConditionalAccept=1;
			setsockopt(s,SOL_SOCKET,SO_CONDITIONAL_ACCEPT,(const void*)&bConditionalAccept,sizeof(int));
		12.如果在发送数据的过程中send()没有完成，还有数据没发送)而调用了closesocket(),以前我们一般采
			取的措施是"从容关闭"shutdown(s,SD_BOTH),但是数据是肯定丢失了，如何设置让程序满足具体应用
			的要求(即让没发完的数据发送出去后在关闭socket)？
				struct linger {
				u_short l_onoff;
				u_short l_linger;
				};
				linger m_sLinger;
				m_sLinger.l_onoff=1; //(在closesocket()调用,但是还有数据没发送完毕的时候容许逗留)
				// 如果m_sLinger.l_onoff=0; 则功能和2.作用相同;
				m_sLinger.l_linger=5;//(容许逗留的时间为5秒)
				setsockopt(s,SOL_SOCKET,SO_LINGER,(const void*)&m_sLinger,sizeof(linger));
			Note:
			1.在设置了逗留延时，用于一个非阻塞的socket是作用不大的，最好不用;
			2.如果想要程序不经历SO_LINGER需要设置SO_DONTLINGER，或者设置l_onoff=0；
		13.还一个用的比较少的是在SDI或者是Dialog的程序中，可以记录socket的调试信息：
			(前不久做过这个函数的测试，调式信息可以保存，包括socket建立时候的参数,采用的具体协议，以及出错的代码都可以记录下来）
			int bDebug=TRUE;
			setsockopt(s,SOL_SOCKET,SO_DEBUG,(const void*)&bDebug,sizeof(int));
---------------------------------------------------------------------------------------------------
【二】udp传输流程
	客户端				服务端
	socket				socket
						bind			
	recvfrom/sendto		recvfrom/sendto // 如果recvfrom返回0表示连接断开了
	close				close

---------------------------------------------------------------------------------------------------
【三】udp广播和组播
	**********重点
	1.在TCP连接时，Server的端口号指定的，Client连接服务器需要指定Server的端口号(并且Client的端口号是随机获取的)
	2.而在UDP传输数据时，端口号的设定却刚好与TCP连接时相反。为什么呢？
	  答：Server要发送数据给Client，而每个Client上有很多应用程序(但是并不是每个应用程序都需要接收到Server广播来的消息)。
		因此Server端在发送消息时需要指定发送给Client的端口号。而客户端套接字需要bind地址和端口号
	Server的端口需要设定么？
	答：不需要，Server只是需要进行广播出去数据，不进行数据的接收―>因此Server的端口号可以随机获取。

(1)udp广播	// 发给在运行的所有客户端
	(1)UDP广播实现原理
								 |----->[client1]					
		[server]----->[交换机]---|----->[client2]	
								 |----->[client3]	
		执行过程	: 
			1.server发送的数据报中携带广播地址(非客户端地址)。
			2.交换机收到数据报后，如果发现数据报中携带的是广播地址，交换机就会将数据报广播连接到
			  交换机就会将数据报广播给连接到交换机上的所有用户。
	(2)UDP广播实现过程
		服务端:	
				  socket
					↓
				开放广播权限 	
					↓
				  sendto		 	
		客户端:
				 socket
					↓
				 bind广播地址  
					↓
				 recvfrom	接收报文, 地址为bind的地址
				
				
		注意:
			①为什么服务端不绑定主机地址,而客户端需要绑定地址?
				1.Server要发送数据给Client，而每个Client上有很多应用程序(但是并不是每个应用程序都需要接收到Server广播来的消息)。
				2.Server只是需要进行广播出去数据，不进行数据的接收―>因此Server的端口号可以随机获取。
			②客户端sendto中的IP地址
				1.可以使网卡的广播地址(如:192.168.1.255)
				2.不能是宏INADDR_BROADCAST: 255.255.255.255		// 与客户端绑定地址不在同一网段
			③客户端bind地址
				1.可以是网卡的广播地址(如:192.168.1.255)
				2.可以是宏INADDR_ANY							// 会选取广播地址
				3.不可以是网卡地址(如:192.168.1.107)			// 将收不到数据
			④客户端recvfrom的地址
				与bind的地址相同
			⑤发送端sendto中的端口号必须 与 接收端bind的端口号相同。(否则不能接收)
			
(2)udp组播 // 发给加入到组中的所有客户端
    ①流程图			
		服务端					客户端
		socket					socket	
		 ↓					 	 ↓
	  设置套接字可以广播	 设置套接字可以被组播
		 ↓						 ↓
	    sendto					bind	  
		 						 ↓
							   recvfrom 
		注意:
			[1]服务端sendto的套接字
	②客户端套接字加入多播组
		struct ip_mreq mreq;
		memset(&mreq, 0, sizeof(mreq))
		mreq.imr_multiaddr.s_addr = inet_addr("组播地址") // 组播地址是D类地址
		mreq.imr_interface.s_addr = htonl(INADDR_ANY)	 // 客户端网卡地址
							或	   inet_addr("客户端网卡地址");
		setsockopt(socketfd, IPPROTO_IP,IP_ADD_MEMBERSHIP, &mreq, sizeof(mreq));
	③客户端套接字多播组中剔除
		setsockopt(socketfd, IPPROTO_IP,IP_DROP_MEMBERSHIP, &mreq, sizeof(mreq));
	④注意:
		1.udp组播的接收端必须能够ping通外网, 才能够接收。
		2.发送端与接收端绑定的端口号必须相同。
		3.发送端sendto使用的"IP组播地址"必须 与 接收端mreq.imr_multiaddr.s_addr完全相同。
		4.接收端bind的IP地址可以是:
			1.发送端sendto使用的"IP组播地址"
			2.INADDR_ANY
		5.mreq.imr_interface.s_addr = htonl(INADDR_ANY);
		6..组播地址分类
			224.0.0.0～224.0.0.255	   为预留的组播地址（永久组地址），地址224.0.0.0保留不做分配，其它地址供路由协议使用。
			224.0.1.0～238.255.255.255 为用户可用的组播地址（临时组地址），全网范围内有效。
			239.0.0.0～239.255.255.255 为本地管理组播地址，仅在特定的本地范围内有效。	
			// 我们做好选用224.0.1.0～238.255.255.255之间的

---------------------------------------------------------------------------------------------------
【四】对比UDP和TCP
(1)UDP:
		1.udp由于是”不可靠”的通信方式，所有往往用于通信要求不是特别高的场合，比如视频点播.
		2.udp通信过程没有那么繁琐，效率相对于tcp会高
		3.udp会丢失数据包，丢了之后是不会主动重新传输
(2)TCP:传输可靠, 支持丢包重传和错包重传
(3)TCP协议过程
	---------------------------------------------------------------------------------
			  /* TCP初始化过程  */
	CLIENT									SERVER
	socket									socket	
											bind
											listen			// 阻塞, 
											"LISTEN"		// 监听状态, 等待连接
	---------------------------------------------------------------------------------
	connect	  /* 连接过程(三次握手)  */
	1.客户端主动发送SYN同步信号
	  然后置状态为"SYN_SENT"
										2.服务端收到SYN信号后,发送ACK应答信号和SYN同步信号
										  然后置状态为SYN_RCVD
	3.收到SYN和SYN信号后,回应ACK信号	
	  然后置状态为"ESTABLISH"(就绪)
										收到ACK回应后, 置状态为"ESTABLISH"(就绪)
										然后accept返回
			         (连接建立成功) //只有在Client和Server同时为ESTABLISHED时，即同时就绪时才可以进行数据传输
	---------------------------------------------------------------------------------
			 /* 数据发送过程(服务端write过程也一样)*/	
	write								read
	1.发送数据DATA						2.收到数据后,回应ACK
	2.read阻塞等待服务端ACK
		重复
	---------------------------------------------------------------------------------
	close	  /* 断开连接过程(四次握手)  */
	1.客户端主动发送FIN完成信号
	  然后置状态为"FIN_WAIT_1"
										2.服务端收到FIN信号后, 发出ACK应答信号
	 客户端收到ACK,
	  然后置状态为"FIN_WAIT_2"
										3.等待TIME_WAIT时间后, 发出FIN完成信号
											然后置状态为LAST_ACK
	 4.收到FIN后, 发出ACK应答信号
	  然后置状态为"TIME_WAIT"  
										收到ACK应答后,立即置状态为"CLOSED"	
	  等待2xMSL后,置状态为"CLOSED"	
			     (连接断开成功)
	---------------------------------------------------------------------------------
	LISTEN：表示Server大门已开，随时准备有Client前来连线；
	SYN_SENT：   只在Client端出现，表示Client发送过SYN了，正在焦急地等待Server的ACK；
	SYN_RCVD：   只在Server端出现，表示Server收到Client的SYN了，并且已经发给Client自己的ACK和SYN了，正在焦急地等待Client的ACK；
	ESTABLISHED：在Client端出现表示Client把自己的ACK（第3次握手）发出去了，Client已经就绪；在Server端出现表示Server已经收到Client的ACK（第3次握手）了，Server已经就绪；
	FIN_WAIT_1： 仅出现在主动方，表示主动方想要断开连接，已经关闭了写通道，并向对端发送了FIN，等待对方的ACK到来；
	CLOSE_WAIT： 仅出现在被动方，表示被动方收到FIN后，已经回复ACK，正在等自己的应用层调用close方法关闭写通道，在CLOSE_WAIT状态下，自己只能发送数据，但不能接收数据；
	FIN_WAIT_2： 仅出现在主动方，表示主动方已收到对端的ACK，等待对端的FIN，此时无法再发送数据，但是可以接收数据；
	LAST_ACK：   仅出现在被动方，表示被动方缓冲区数据已经发送完毕，并且已经发送FIN到对端，等待对端的ACK；如果应用层写的比较垃圾，没有调用close关闭socket，则会一直停留在CLOSE_WAIT；
	TIME_WAIT：  仅出现在主动方，表示主动方已经发出ACK了，本次通讯完事了，双方都不能再读写了，但是主动方不确定对方能不能收到最后一个ACK，为了保证这个端口释放后，不被后来的连接马上使用被当成是新连接，通俗地讲，为了不乱套，这个状态会一直等待，等多久呢， 等2×MSL（Maximum Segment Lifetime）个时间，这个MSL是操作系统配置的，有默认参数，可以改。
(4)三次握手	
 tcp建立连接的过程就是三次握手的过程（connect跟accept之间）
	1.首先客户端给服务器发送同步信号SYN-
	2.服务器收到信号之后给客户端一个应答ACK+SYN
	3.客户端收到应答以后，再给服务器发送应答确认ACK
(5)四次握手	
	1.首先客户端给服务器发送结束信号FIN
	2.服务器收到信号之后给客户端一个应答ACK
	3.等待CLOSE_TIME后, 服务器再发送一个结束信号FIN-
	4.客户端收到信号之后给一个应答ACK
	四次握手中有一个time_wait，服务器发送了ACK有可能客户端没有收到(客户端掉线了),服务器等待一会，然后再次发送FIN，等待客户端的确认，最后结束通信。				 
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
【五】TCP和UDP通信中几种常见的I/O模型
	// 并发阻塞: accept, 可能有多个客户端想要连接, 但同一时间只有一个客户端在跟服务端尝试连接(connect之后, accept返回之前)
	TCP并发阻塞IO(多线程实现)	// 重点
	TCP并发阻塞IO（多进程实现）	// 重点
	TCP非阻塞轮询				// 了解
	UDP信号触发					// 了解
	多路复用select TCP新套接字	// 重点
	select实现TCP广播
	
(1)TCP并发阻塞IO(多进程实现)	// 重点
	①方法: 每成功连接一个客户端（accept）, 就创建一个子进程来与新客户端通信
	②注意: 
		  1.父进程中要关闭accept返回的新文件描述符, 让子进程去操作这个描述符来通信
		  2.子进程中要关闭父进程创建的TCP套接字描述符, 子进程用不到。
		     // 因为fork后父子进程都可访问fork前产生的描述符(父子进程的文件描述符的操作是同步的, 因为共用一个strct file结构)
		  3.父进程中应该对 SIGCHLD 的处理函数设置为 SIG_IGN ，或者在调用 sigaction 函数时设置 SA_NOCLDWAIT 标志位。
		     让子进程退出时“自行了断”， 不成为"僵尸进程"。
	③伪代码(父进程接单, 创建子进程来收发信息)
		/* 客户端 */
		int main() 
		{
			signal(SIG_CHLD, SIG_IGN);	// 让子线程退出时“自行了断”，  子进程退出时不变为僵尸进程
			sfd = socket(AF_INET, SOCK_STREAM);
			bind(sfd, );
			listen(sfd, );
			while(1) {
				newfd = accept(sfd, );	// 阻塞到有一个客户端连接	
				ret = fork();			
				if (!ret) {				// 子进程
					close(sfd);
					break;				// 退出while(1)循环
				}
				else if(ret > 0) {		// 父进程
					close(newfd);
					continue;			// 结束本次循环
				}
			}
			// 以下为子进程区域, 父进程不会执行到这儿来
			while(1) {
				recv(newfd, );		// 收发数据
			}
			close(newfd);
			exit(0);
		}
(2)TCP并发阻塞IO（多线程实现）	// 重点
	①方法: 每成功连接一个客户端（accept）, 就创建一个线程来与新客户端通信
	②注意: 
		1.新建线程只有线程栈是独立的, 其余资源都跟一个线程组的资源共用
	③伪代码(父进程接单, 创建子进程来收发信息)
		void *work(void *arg)
		{	int newfd = *arg;
			pthread_detach(pthread(self));	// 设置为分离状态
			while(1){
				recv();
			}
			close(newfd);
			free(arg)
		}
		
		int main() 
		{	pthread_t tid;
			int *new_fd;
			sfd = socket(AF_INET, SOCK_STREAM);
			bind(sfd, );
			listen(sfd, );
			char *newfd_arry[CONNECT_MAX];
			int i = 0;
			while(1) {
				newfd = accept(sfd, );	// 阻塞到有一个客户端连接
				new_fd = malloc(4);
				*new_fd = newfd;
				pthread_create(&tid, NULL, work, (void *)new_fd);
			}
		}
（3）UDP 套接字信号驱动IO(重点)		// 了解
	①方法: 在套接字上开启SIGIO信号驱动IO功能
			// 当在此文件描述符上输出或接受输入时，产生一个SIGIO信号（默认情况下为SIGIO，但可以通过fcntl（2）更改）。 
		1.设置套接字描述符sfd接收SIGIO和SIGURG信号的进程ID或进程组ID。 // 一个套接字可能在多个进程中都有描述符, 他们都有可能接收信号
			fcntl(sfd, F_SETOWN, getpid());
		2.设置套接字: 启用信号驱动的I/O (文件状态标志)
			int val = fcntl(sfd, F_GETFL);
			val |= O_ASYNC;
			fcntl(sfd, F_SETFL, val);
		3.在信号函数里面收发数据
	②伪代码
		// server.c
			// 信号处理函数
		int sfd;
		char buf[50];
		void *sigio_func(int sig)
		{	
			recvfrom(sfd, buf, 50, 0);
			printf("recv: %s\n", buf);
		}
		int main()
		{
			sfd = socket(AF_INET, SOCK_STREAM, 0);
			// 设置套接字地址可复用
			
			// 1.设置套接字描述符sfd接收SIGIO和SIGURG信号的进程ID或进程组ID
			fcntl(sfd, F_SETOWN, getpid());
			
			// 2.设置套接字: 启用信号驱动的I/O (文件状态标志)
				int val = fcntl(sfd, F_GETFL);
				val |= O_ASYNC;
				fcntl(sfd, F_SETFL, val);
				
			// 3.注册信号处理函数
				signal(SIGIO, sigio_func);
				
			bind(sfd, &server_addr);
		}
	
（4）TCP I/O多路复用select, poll		// 重点
	①方法
		1.监听"监听套接字"
		2.当“监听套接字”为可读状态时， 表示有新连接且accept还未返回。
		3.这时让程序跳转去执行accept，接收新描述符并插入链表， 然后设置新的描述符集。
		4.当有连接断开时，将对应的新描述符从链表中删除，然后跳转去重新设置描述符集
	②原理
		 1."监听套接字", 默认为不可读状态
		 2.当调用accept时, "监听套接字"使accept阻塞。
		 3.当有一个客户端连接上"监听套接字"，且accept函数返回之前。
			这一段时间内,"监听套接字"为可读状态。
		 4.当accept函数返回新套接字后， "监听套接字"又恢复为不可读状态
	③注意:
		第一个连接的过程不会被select监听到, 因为描述符集在accept之后设置的
	④select实现伪代码

		int main(int argc, char **argv)
		{
			// 创建套接字
			sfd = socket(AF_INET, SOCK_STREAM, 0);

			// 设置套接字地址可复用
			const int bReuseaddr = 1;
			setsockopt(sfd,SOL_SOCKET ,SO_REUSEADDR,(const void*)&bReuseaddr,sizeof(bReuseaddr));
			
			// 绑定
			MY_IPV4_ADDR(server_addr, MY_SERVER_PORT, MY_SERVER_IP);
			 bind(sfd, (struct sockaddr *)&server_addr, sizeof(server_addr)))
			
			// 监听
			listen(sfd, 10);
			listenfd = sfd;
			len = sizeof(tmp_client_addr);
			
		have_connect:	// 监视到有新连接
			// 接收
			memset(&tmp_client_addr, 0, sizeof(tmp_client_addr));
			newfd = accept(listenfd, (struct sockaddr *)&tmp_client_addr, &len);	
			printf("%s connect....\n", inet_ntoa(tmp_client_addr.sin_addr));

			// 新套接字插入链表
			info = malloc(sizeof(info_t));
			info->newfd		  = newfd;
			info->client_addr = tmp_client_addr;
			list_add(&info->list, &head);
			
		updata_set:		// 更新描述符集	
			//设置监视描述符集
			FD_ZERO(&rset);
			FD_SET(listenfd, &rset);				// 监视"监听套接字"	
			list_for_each(pos, &head) {
				info = container_of(pos, info_t, list);
				FD_SET(info->newfd, &rset);	// 监视链表中的每一个新描述符
				printf("info->newfd = %d\n", info->newfd);
			}
			while(1)
			{	tmprset = rset;
				bzero(sbuf,50);
				bzero(buf,50);
				
				if (select(FD_SETSIZE, &tmprset, NULL, NULL, NULL) > 0)		// 返回-1,表示收到信号而中断
				{	// 监视"监听描述符"。 当为可读状态时, 表示有新连接且accept还未返回.
					if(FD_ISSET(sfd, &tmprset)) 
						goto have_connect↑;

					// 验证链表中的所有新描述符是否可读
					list_for_each(pos, &head) {
						info = container_of(pos, info_t, list);
						if(FD_ISSET(info->newfd, &tmprset)) {
							// 接收
							ret = recv(info->newfd, buf, 50, 0);
							if (ret > 0)
								printf("recv %s: %s\n", inet_ntoa(info->client_addr.sin_addr), buf);
							// 客户端断开连接
							else if(ret == 0){	
								close(info->newfd);// 关闭套接字
								list_del(&info->list);// 从链表中删除
								free(info);
								goto updata_set↑;// 跳转到b2去更新描述符集
							}
						}
					}
				}
			}
		}
	
	④poll实现伪代码
		1.跟select原理完全一样
		2.不同的是添加监视的描述符, 和判断描述符书否"准备好"的过程有所不同。
		int main(int argc, char **argv)
		{
			// 创建套接字
			sfd = socket(AF_INET, SOCK_STREAM, 0);

			// 设置套接字地址可复用
			const int bReuseaddr = 1;
			setsockopt(sfd,SOL_SOCKET ,SO_REUSEADDR,(const void*)&bReuseaddr,sizeof(bReuseaddr));
			
			// 绑定
			MY_IPV4_ADDR(server_addr, MY_SERVER_PORT, MY_SERVER_IP);
			bind(sfd, (struct sockaddr *)&server_addr, sizeof(server_addr))
			// 监听
			listen(sfd, 10);
			listenfd = sfd;
			one_time_flag = 0;
			
		have_connect:	// 监视到有新连接
			// 接收
			newfd = accept(listenfd, (struct sockaddr *)&tmp_client_addr, &len);	
			// 新套接字插入链表
			info = malloc(sizeof(info_t));
			info->newfd		  = newfd;
			info->client_addr = tmp_client_addr;
			list_add(&info->list, &head);
			fdcnt++;
		updata_set:		// 更新描述符数组
			if (one_time_flag == 1)
				free(fdarray);	// 第一次不释放, 后面的都释放
			one_time_flag = 1;
			fdarray = malloc(sizeof(struct pollfd) * (fdcnt + 1)); // + 1: 监听套接字
			// 监视"监听套接字"	
			fdarray[0].fd = listenfd;		
			fdarray[0].events = POLLIN;
			
			// 监视"新描述符"
			i = 1;			
			list_for_each(pos, &head) {
				info = container_of(pos, info_t, list);
				fdarray[i].fd 	  = info->newfd;
				fdarray[i].events = POLLIN;
				i++;
			}
			while(1)
			{	
				bzero(sbuf,50);
				bzero(buf,50);
				if (poll(fdarray, fdcnt+1, -1) > 0)		// 返回-1,表示收到信号而中断
				{
					// 监视"监听描述符"。 当为可读状态时, 表示有新连接且accept还未返回.
					if(fdarray[0].revents & POLLIN)
						goto have_connect↑;

					// 验证链表中的所有新描述符是否可读
					i = 1;			
					list_for_each(pos, &head) {
						info = container_of(pos, info_t, list);
						
						if(fdarray[i++].revents & POLLIN) {
							ret = recv(info->newfd, buf, 50, 0);
							if (ret > 0)
								printf("recv %s: %s\n", inet_ntoa(info->client_addr.sin_addr), buf);
							// 客户端断开连接
			   				else if(ret == 0){	
								close(info->newfd);		// 关闭套接字
								list_del(&info->list);	// 从链表中删除
								fdcnt--;
								free(info);
								goto updata_set↑;		// 跳转到updata_set去设置监视描述符数组
							}
						}
					}
				}
			}
		
(5)select实现TCP广播	// 重点
	①方法
		1.监听"监听套接字"
		2.当“监听套接字”为可读状态时， 将accept返回的新套接字插入链表
		3.调用send向链表里面的每一个新描述发送数据
	②原理
	 1."监听套接字", 默认为不可读状态
	 2.当调用accept时, "监听套接字"使accept阻塞。
	 3.当有一个客户端连接上"监听套接字"，且accept函数返回之前。
		这一段时间内,"监听套接字"为可读状态。
	 4.当accept函数返回新套接字后， "监听套接字"又恢复为不可读状态
	③伪代码
		int main(int argc, char **argv)
		{
			// 创建套接字
			sfd = socket(AF_INET, SOCK_STREAM, 0);

			// 设置套接字地址可复用

			// 绑定
			MY_IPV4_ADDR(server_addr, MY_SERVER_PORT, MY_SERVER_IP);
			bind(sfd,
			
			// 监听
			listen(sfd, 10);
			
		connect:	// 监视到有新连接
			// 接收
			newfd = accept(sfd, NULL, NULL);	// 阻塞前不应该拿到锁

			// 新套接字插入链表
			info = malloc(sizeof(info_t));
			info->newfd = newfd;
			list_add(&info->list, &head);
			
		updata_set:		// 更新描述符集	
			//设置监视描述符集
			FD_ZERO(&rset);
			FD_SET(sfd, &rset);				// 监视"监听套接字"	
			list_for_each(pos, &head) {
				info = container_of(pos, info_t, list);
				FD_SET(info->newfd, &rset);	// 监视链表中的每一个新描述符
				printf("info->newfd = %d\n", info->newfd);
			}
			FD_SET(STDIN_FILENO, &rset);	// 监视标准输入描述符
			
			while(1)
			{
				tmprset = rset;
			
				select(FD_SETSIZE, &tmprset, NULL, NULL, NULL);
				
				// 监视"监听描述符"。 当为可读状态时, 表示有新连接，但是accept还未返回
				if(FD_ISSET(sfd, &tmprset)) 
					goto connect;

				// 当键盘输入时, 发给链表中的每一个新描述符
				if(FD_ISSET(STDIN_FILENO,&tmprset))
				{	
					scanf("%s",sbuf);
					list_for_each(pos, &head) {
						info = container_of(pos, info_t, list);
						send(info->newfd, sbuf, 50, 0);
					}
				}
				// 验证链表中的所有新描述符是否可读
				list_for_each(pos, &head) {
					info = container_of(pos, info_t, list);
					if(FD_ISSET(info->newfd, &tmprset)) {
						// 读
						ret = recv(info->newfd, buf, 50, 0);
						if (ret > 0)
							printf("recv: %s\n", buf);
						// 客户端断开连接
						else if(ret == 0){	
							// 关闭套接字
							close(info->newfd);
							
							// 从链表中删除
							list_del(&info->list);
							free(info);
							
							// 跳转到b2去更新描述符集
							goto updata_set;
						}
					}
				}
			}
			return 0;
		err:
			close(sfd);
			return -1;
		}
	
	
(6)TCP非阻塞轮询	// 了解
	①方法: 1.设置socket创建的的套接字为非阻塞, 这样accept就不会阻塞
			2.设置accept返回的新套接字newfd也为非阻塞, 这样读写新套接字就不会阻塞
			3.将accept返回的新套接字插入链表
			4.遍历链表进行非阻塞读写
			
---------------------------------------------------------------------------------------------------
【五】作业
（1）udp广播	
（2）TCP传输控制图片
	1.同TCP套接字给开发板发送一种BMP图片。
	2.在Ubuntu上用命令控制开发板图片显示
		full命令--》全屏显示
		half命令--》1/2显示
		double命令 两倍显示
（3）使用TCP发送一个本地记事本给开发板
	思路： 1. 打开记事本提取
		   2.发送
		   3.接收并存储





				
				
				
	
●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●
								Uinux环境高级编程
●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●
##############################################################################################################
##############################################################################################################
	
##############################################################################################################
								第17章 高级进程间的通信
##############################################################################################################
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx							
【一】UNIX域套接字（类似于进程间通信的有名管道）
(1)形式:
		1.tcp域套接字
		2.udp域套接字
(2)通信范围: 仅能用于同一台主机主机上的不同两个进程之间的通信
(3)注意
	struct sockaddr_un {
		u_short sun_family;
		char sun_path[108];		// 路径
	}
	1.当我们将sockaddr_un绑定到一个域套接字时: 系统会在sun_path路径下创建一个S_IFSOCK类型的文件
	2.生成的文件仅用户向客户进程告示套接字的名字。该文件无法打开，也不能用于进程间通信
	3.当我们将套接字绑定到sockaddr_un时，若系统已经生成了S_IFSOCK类型的文件，那么bind会失败
	   只有我们删除了该文件才能绑定成功
	4.当我们关闭域套接字时，系统并不自动删除系统生成的S_IFSOCK类型文件。 // 需要手动删除
(4)说明
	多个线程可以向一个udp套接字发送数据报, 但是要使用互斥量
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx							
【二】TCP域套接字（类似于进程间通信的有名管道）

	// 跟tcp和udp网络套接字的使用过程一模一样
	// 只是在某些标记上的设置,和地址的设置不同
	①服务端
		struct sockaddr_un un;
		fd = socket(AF_UNIX, SOCK_STREAM, 0)
		
		un.sun_family = AF_UNIX;
		strcpy(un.sun_path, "foo.socket");	// 生成"foo.socket"通信文件, 类似于管道
		
		int size = sizeof(un);
		bind(fd, (struct sockaddr *)&un, size);
		
		listen(fd, 5);
		newfd = accept(fd, NULL, NULL);	
		while(1) {
			recv(newfd);
			read(newfd);
		}
	②客户端
		struct sockaddr_un un;
		fd = socket(AF_UNIX, SOCK_STREAM, 0)
		un.sun_family = AF_UNIX;
		strcpy(un.sun_path, "foo.socket");	// 生成"foo.socket"通信文件, 类似于管道
		connect(fd, &un);
		while(1) {
			recv(fd);
			read(fd);
		}

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx							
【三】点对点--UDP域套接字（类似于进程间通信的有名管道）
注意: 
	1.UDP域套接字只能单向通信
	2.必须是接收方绑定(创建类似于管道的通信文件), 发送端不能绑定, 否则接收方收不到数据。
	3.域套接字需要包含的头文件: (否则报错)
		#include <stdio.h>
		#include <stdlib.h>
		#include <string.h>
		#include <sys/types.h>
		#include <unistd.h>
		#include <errno.h>
		#include <sys/types.h>
		#include <sys/socket.h>
		#include <net/if.h>
		#include <sys/un.h>
		#include <sys/ioctl.h>
		#include <stddef.h>
		#include <fcntl.h>
	4.如果要实现双向通信
		1.需要两个管道
		2.一个进程里面读写这个管道的套接字必须是同一个,否则收不到数据(☆)
①接收端:
	#define SOCKET_UN_UDP_PATH "udp_un.socket"

	int main(void){

		int server_sock, len, rc;
		int bytes_rec = 0;
		struct sockaddr_un server_sockaddr;
		char buf[256];
		struct sockaddr_un remote; 
		remote.sun_family = AF_UNIX;		
		strcpy(remote.sun_path, SOCKET_UN_UDP_PATH); 
		
		// 删除存在的管道文件, 否则绑定失败
		system("rm -rf udp_un.socket");
		memset(&server_sockaddr, 0, sizeof(struct sockaddr_un));
		memset(buf, 0, 256);
		
		server_sock = socket(AF_UNIX, SOCK_DGRAM, 0);
		server_sockaddr.sun_family = AF_UNIX;
		strcpy(server_sockaddr.sun_path, SOCKET_UN_UDP_PATH); 
		len = sizeof(server_sockaddr);
		
		// 绑定
		rc = bind(server_sock, (struct sockaddr *)&server_sockaddr, len);
		printf("rc=%d\n", rc);

		// 接受
		bytes_rec = recvfrom(server_sock, buf, 256, 0, NULL, NULL);
		printf("%s\n", buf);

		close(server_sock);
		return 0;
	}
	
②发送方:
	#define SOCKET_UN_UDP_PATH "udp_un.socket"
	#define DATA 		"Hello from client\n"

	int main(void)
	{
		int client_socket, rc;
		struct sockaddr_un remote; 
		char buf[256];
		
		memset(&remote, 0, sizeof(struct sockaddr_un));		
		client_socket = socket(AF_UNIX, SOCK_DGRAM, 0);
		remote.sun_family = AF_UNIX;        
		strcpy(remote.sun_path, SOCKET_UN_UDP_PATH); 
		
		strcpy(buf, DATA);
		// 发送
		rc = sendto(client_socket, buf, strlen(buf), 0, (struct sockaddr *) &remote, sizeof(remote));
		rc = close(client_socket);
		return 0;
	}
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx							
【四】多个线程发送,同一个线程接收--UDP域套接字（类似于进程间通信的有名管道）
	①接收方
		static int fd;
		#define ADDR (struct sockaddr *)&addr
		int main()
		{
			static struct sockaddr_un addr;
			system("rm -rf socket");
			fd = socket(AF_UNIX, SOCK_DGRAM, 0);
			memset(&addr, 0, sizeof(addr));
			addr.sun_family = AF_UNIX;		
			strcpy(addr.sun_path, "socket"); 
			bind(fd, ADDR, sizeof(addr));
			char buf[100];
			while(1){
				memset(buf, 0, 100);
				recvfrom(fd, buf, 100, 0, NULL, NULL);
				printf("%s\n", buf);
			}
			return 0;
		}
	②多线程发送方
		static pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
		static int fd;
		static struct sockaddr_un addr;
		#define SEND_ADDR (struct sockaddr *)&addr
		void *work(void *args)
		{
			pthread_detach(pthread_self());
			char *buf = "work";
			while(1){
				sleep(1);
				pthread_mutex_lock(&mutex);
				sendto(fd, buf, 4, 0, SEND_ADDR, sizeof(addr));
				pthread_mutex_unlock(&mutex);
			}
			return NULL;
		}
		// 多个线程同时写udp域套接字
		int main()
		{
			pthread_t uid;
			fd = socket(AF_UNIX, SOCK_DGRAM, 0);
			memset(&addr, 0, sizeof(addr));
			addr.sun_family = AF_UNIX;		
			strcpy(addr.sun_path, "socket"); 
			pthread_create(&uid, NULL, work, NULL);
			char *buf = "main";
			while(1){
				sleep(1);
				pthread_mutex_lock(&mutex);
				sendto(fd, buf, 4, 0, SEND_ADDR, sizeof(addr));
				pthread_mutex_unlock(&mutex);
			}
			return 0;
		}

##################################################################################
		第14章 高级IO
##################################################################################
【一】、非阻塞IO
	1.opens时启用, O_NOOBLOCK标志
	2.fcntl打开O_NOOBLOCK标志
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx			
【二】、记录锁
	当一个进程正在读或修改文件某个部分, 或者整个文件时, 使用记录锁可以阻止其他进程修改同一文件区
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx			
【三】、IO多路转接(select/poll)
	select poll的区别与共同点:
		1.内核中的select和poll的实现中都是采用轮询来处理的，轮询的fd数目越多，耗时越多。
		2.select最多同时监听__FD_SETSIZE(1024)路, 而poll没有限制。
		3.都可用于监视终端:	STDIN_FILENO.STDOUT_FILENO.STDERR_FILENO	//	标准输入, 标准输出, 标准错误
	pselect和select poll的区别
		1.select poll监视过程中会被信号中断，而pselect可以设置相应的屏蔽信号集
		2.pselect提供了比select更高精度的超时设置(取决于硬件)
①函数select
	int select(int maxfdp1, fd_set *restrict readfds,
				fd_set *restrict writefds, fd_set *restrict exceptfds,
				struct timeval *restrict tvptr);
	maxfdp1:    描述符变量最大的一个 + 1。 通常设置为宏FD_SETSIZE(1024) //设置为其他有错误风险
	readfds:    被监视的可读描述符集	  
	writefds:	被监视的可写描述符集	   
	exceptfds:	被监视的异常描述符集
	  注意：1）3个描述符集中的任一个都可以为NULL， 也可以全部为NULL。如果都为NULL， 那么该函数相当于usleep
		    2）假如readfds描述符集中没有加入任何描述符， 且	writefds、exceptfds都为空，那么select还是会阻塞
			3) select返回后, 描述符集已经被修改, 我们要重新监视时, 必须修改描述符集
	tvptr: 愿意等待的时间长度	
			1. tvptr == NULL	
				// 永远等待
			2. (tvptr->tv_sec == 0) && (tvptr->tv_usec == 0) 
				// 不等待, 测试完所有描述符后, 立刻返回。
			3. (tvptr->tv_sec != 0) || (tvptr->tv_usec != 0) 
				1.在tvptr时间内，如果有一个及以上描述符准备好了，便立刻返回准备好的个数。
				2.如果在tvptr时间内没有准备好的描述符，返回-1。
	返回值:
		(1)返回-1表示出错。比如没有描述符准备好前被信号中断返回，这种情况传入的描述符集不被修改。
		(2)返回0。若在指定时间内没有一个描述符准备好，就返回0，这时所有描述符集都会置0。
		(2)返回正值，说明准备好的描述符数。这个值时3个描述符集中准备好的描述符之和。
		   如果该描述符读写都准备好了，那么会被计数两次。
	“准备好”的说明：
		(1) 对于读集中的描述符,如果read不会被阻塞, 则认为该描述符是准备好的。
		(2) 对于写集中的描述符,如果write不会被阻塞, 则认为该描述符是准备好的。
		(3) 对于异常条件集中的描述符,如果有一个未决异常条件, 则认为该描述符是准备好的。
		(4) 对于普通文件描述符，读集、写集、异常条件集总是准备好的。
		(5) 对于终端当键入"\n"时, "STDIN_FILENO"标准输入被认为是可读的。
			之后文们应该调用: read(STDIN_FILENO, buf, n);
		注意：如果一个非套接字描述符对应的文件到达尾端，select会认为该描述符时可读的（而不是异常），调用read会但会-1。
	注意：
		
	(1)描述符集(fd_set)
		[1]说明: 为每一个描述符保持一位
		[2]处理过程:
			1.分配一个描述符集fd_set
			2.将描述符集fd_set的所有位清0
			3.设置我们关心的描述符的位
			4.从select返回时, 测试该集中的给定位是否处于打开状态,然后再对打开描述符进行操作。
		[3]描述符集的操作函数
			int FD_ISSET(int fd, fd_set *fdset);	// 测试fd在描述符集中的位是否打开，若打开返回非0值； 否则返回0。
			void FD_CLR(int fd, fd_set *fdset);		// 清除fd在描述符集中位
			void FD_SET(int fd, fd_set *fdset);		// 开启fd在描述符集中的位(添加一位, 而不是打开)
			void FD_ZERO(fd_set *fdset);			// 描述符集中的所有位清0
		[4]操作流程(伪代码)
			fd_set rset;
			int fd;
			FD_ZERO(&rset);
			FD_SET(fd, &rset);
			select(FD_SETSIZE, &rset, NULL, NULL, &timeout);
			if (FD_ISSET(fd, &rset)) 
				read(); /write
------------------------------------------------------------------------------------------------------------
②函数pselect
int pselect(int maxfdp1, fd_set *restrict readfds,
		fd_set *restrict writefds, fd_set *restrict exceptfds,
		const struct timespec *restrict tsptr,
		const sigset_t *restrict sigmask);
	除以下几点外，pselect与select相同：	
		1.提供的tsptr超时比select提供的超时更精确(前提是要硬件时钟支持)
		2.pselect将超时时间tsptr定义为const类型, 说明pselect函数内部不会修改超时设置，而select中的超时很有可能被修改。
		3.pselect提供了线程的阻塞信号集。
			1.pselect调用时，以原子的设置该信号阻塞集。
			2.pselect返回时，恢复以前的信号阻塞集。
------------------------------------------------------------------------------------------------------------
③函数poll
	int poll(struct pollfd fdarray[], nfds_t nfds, int timeout);
		fdarray：每个数组元素指定一个描述符fd和poll对该描述符感兴趣的条件。
		nfds：   数组元素的个数
		timeout：超时时间(毫秒)
			1. timeout == -1	
				// 永远等待
			2. timeout == 0
				// 不等待, 测试完所有描述符后, 立刻返回。
			3. timeout > 0
				1.在tvptr时间内，如果有一个及以上描述符准备好了，便立刻返回准备好的个数。
				2.如果在tvptr时间内没有准备好的描述符，返回-1。
		返回值:
			(1)返回-1表示出错。比如没有描述符准备好前被信号中断返回。
			(2)返回0。超时时间内没有一个描述符准备好。
			(2)返回正值，说明准备好的描述符数目。
		"准备好"的概念与select相同
		说明：
		  1.struct pollfd
			{
				int fd;					// 被监视的描述符
				short int events;		// poll对该描述符感兴趣的条件
				short int revents;		// poll返回时，该值由内核设置，用于说明每个描述符发生哪些事件。 
			};
		  2.events可取值, 和revents可能被内核设置的值
				// 说明可读性
				POLLIN :		= POLLRDNORM | POLLRDBAND
				POLLRDNORM:    可以不阻塞的读普通数据
				POLLRDBAND:		可以不阻塞的读优先级数据
				POLLPRI 		可以不阻塞的读高优先级数据
				// 说明可写性
				POLLOUT 		可以不阻塞的写普通数据
				POLLWRNORM 		= POLLOUT
				POLLWRBAND 		可以不阻塞的写优先级数据
				// 说明异常条件。 即使events中没有设置下列条件，当下列条件满足时，revents任然被设置为相应字段
				POLLERR 		已出错
				POLLHUP 		已挂断
				POLLNVAL		描述符没有引用一个打开文件
		  3.poll返回时判断哪些描述符可读
			for (i= 0; i< nfds; i++)
			{	if(fdarray[i].revents & POLLIN);
					read(fdarray[i].fd);	// 可以的原理也完全相同
			}

		  
				