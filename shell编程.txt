			
			
zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz
					基本语法(注意跟C语言语法区分)
zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz
【一】解释器注意点
#!/bin/bash		// 是shell脚本的解释器， 用来解释脚本文件
	1.注意在window中创建的sh文件不能在linux中直接运行
		因为:.sh文件的格式为dos格式(:set ff )。而linux只能执行格式为unix格式的脚本
	  解决: 1.用vi编辑器打开文件, 然后执行":set ff=unix"命令
				或者:dos2unix 1.sh
			2.在linux中创建文件,传到本地再进行编辑。
	2.使用#注释
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
【二】shell变量
	类型: 普通变量 环境变量 命令行变量
		注意: 变量没有类型名
	var1=10
	var2=-57
	var3=testing
	var4="still more testing"
	1.shell脚本会自动决定变量值的数据类型。在脚本的整个生命周期里，shell脚本中定义的变量
	  会一直保持着它们的值，但在shell脚本结束时会被删除掉。	
	2.在变量、等号和值之间不能出现空格
	
(1)普通变量: 整形 字符串
	①定义: 变量名=变量的值		// =两边不能有空格
	②使用: $变量名
		例1: name="张三"	
			echo $name		// 输出"张三"
			
		例2: a=5	
			echo "a = $a" $a	// 输出: a = 5 5
(2)环境变量
	①查看环境变量
		1.用env查看Linux系统中的所有环境变量
		2.输出环境变量的值:
			echo $环境变量
	②临时修改系统的环境变量:
		临时修改:
		export PATH=/xxx/xxx/xxx:$PATH
	③永久修改系统的环境变量	
		1.在 /etc/envienment中修改
		2.然后source /etc/envienment
	④使用$配合环境变量符号, 可以打印出环境变量的值
		* 含有所有命令行参数（以单个文本值的形式）
		@ 含有所有命令行参数（以多个文本值的形式）
		# 命令行参数数目	// ./*.sh不算在参数个数里面
		n 第n个参数
		? 最近使用的前台进程的退出状态码
		- 当前命令行选项标记
		$ 当前shell的进程ID（PID）
		! 最近执行的后台进程的PID
		0 命令行中使用的命令名称
		_ shell的绝对路径名		
		
(3)命令替换
	①反引号字符``, 在特殊符号里面有讲
	②$() 格式	// 例: $(cmd) 等价于`cmd`

	
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
【三】shell的输入、输出、退出
①规则
	输出: echo
	输入: read
②举例:
	read -p "pleace input "str		// 获取键盘输入, 然后将其保存到变量str中
	echo $str		// 输出变量str的值
③退出
	在想要退出脚本的地方使用exit n // n在0～255之间
	
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
【四】shell的特殊符号
①元字符 (指在shell中有特殊含义的字符)
	< > | ; ! ? * [ ] $ \ " ' ` ~ ( ) { } ^
②三种引号
	(1)双引号 " "
		1.说明: 消除元字符的特殊含义，除$ ` "个字符外，均当作普通字符处理。
		2.可以使用\来消除$ ` "的特殊语义
		3.例:
			// 这里的``(倒引号)，执行了pwd命令，并没有被当成普通字符打印出来
			echo "curent directory is `pwd`"	// curent directory is /work/shell

			// 这里的$HOME被当成环境变量打印出来
			echo "home directory is $HOME"		// home directory is /home/book

			// 这里的* . ?都被当做普通字符直接打印出来
			echo "file *.?"						// file *.?

			// 这里的''被当作普通字符打印出来(单引号没有起作用)
			echo "directory '$HOME'"			// directory '/home/book'

			// 这里的""被当作元字符(""起了作用, 没有被当做字符)
			echo "pid= "$$""					// pid= 8065
			
			// 这里的\$指明将$当作一个普通字符
			echo "pwd = \$PWD"					// pwd = $PWD

	(2)单引号 ' '
		1.除单引号自身外，都当作普通字符来处理， // 意思是:如果''内嵌套'',但是嵌套的''未使用\, 那么嵌套的''里面的内容就不会当做字符串
		2.可以使用\来消除单引号里面的特殊语义
		3.举例
			// 在''中，除了''之外所有的字符都被当作普通字符处理了
			echo 'curent directory is `pwd`'	// curent directory is `pwd`
			echo 'home directory is $HOME'		// home directory is $HOME
			echo 'file *.?'						// file *.?

			// 在''中里面的因为$HOME使用了''所以被当作特殊字符
			echo 'directory '$HOME''			// directory /home/book
			
			// \来消除了$的特殊语义
			echo 'directory '\$HOME''			// directory $HOME
	
	(3)反引号 ` `
		命令替换，将一个命令的输出作为另一个命令的参数
		
	(4)(( expression )) 以是任意的数学赋值或比较表达式
		如: ((i=0;i<3;i++))	//i分别取0 1 2 
	(5)	[[ expression ]]
		比使用test命令的优点在于, 可以在expression中使用正则表达式
		如: if [[ $USER == r* ]]
③转义字符\
	1.说明: 反斜线(\)是bash的转义字符,引用转义字符的目的是让后接的字符恢复其原来作为单纯字符的用途,也就是除去特殊字符的作用.  
	2.例:
		echo pwd = \$PWD	// pwd = $PWD
④通配符 
		
⑤管道 | (可以将多个命令组合在一起)
	用法一: cmd1 | cmd2	// 将cmd1的执行结果作为cmd2的参数
			
⑥重定向
	(1)基础
		在linux系统启动后，默认会打开3个描述符，分别是 ：
		 1.标准输入， 文件描述符用数字0表示  stdin
		 2.正确输出,  文件描述符用数字1表示  stdout
		 3.错误输出,  文件描述符用数字2表示  stderr
	(2)linux shell 下常用到的输入、输出操作符为：
		1、 标准输入:  	  代码为0，使用 <或者 <<    /dev/stdin
		2、 标准输出 : 	  代码为1，使用 > 或者>>    /dev/stdout
		3、 标准错误输出: 代码为2，使用 2>或者 2>>  /dev/stdeer
	(3)Bash的重定向操作总结
		-----------------------------------------------------------------------------------------------------
			类型 				操作符	用途
		-----------------------------------------------------------------------------------------------------
		重定向标准输入			  <		将命令中接收输入的途径由默认的键盘更改为制定的文件
		-----------------------------------------------------------------------------------------------------
		重定向标准输出			  >		将命令的执行结果输出到制定的文件中，而不是直接显示到屏幕上,会覆盖原来的内容
								  >>	追加
		-----------------------------------------------------------------------------------------------------
		重定向标准错误			  2>	将错误结果输出到指定文件中，覆盖掉原先的文件数据内容
								  2>>	将错误的结果追加到指定文件中
		-----------------------------------------------------------------------------------------------------
		重定向标准输出和标准错误  &> 	将标准输出，标准错误输出内容全部保存到文件中，而不是显示到屏幕上
		-----------------------------------------------------------------------------------------------------
	
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
【四】条件判断
①test命令
	(1)基本语法
		// 文件判断
		test -e file 	判断文件 file 是否存在, 存在返回 0，否则返回 1
		test -r file 	判断文件 file 是否可读, 可读返回 0，否则返回 1
		test -w file 	判断文件 file 是否可写, 可写返回 0，否则返回 1
		test -x file 	判断文件 file 是否可执行, 可执行返回 0，否则返回 1
		test -d file 	判断文件 file 是否是目录, 是目录返回 0，否则返回 1
		test -f file 	判断文件 file 是否是普通文件, 是普通文件返回 0，否则返回 1
		test -s file 	判断文件 file 是否非空 非空返回 0，否则返回 1
		// 字符串判断
		test s1 = s2 	判断字符串 s1 和 s2 是否相同, 相同返回 0，否则返回 1
		test s1 != s2	判断字符串 s1 和 s2 是否不同, 不同返回 0，否则返回 1
		test s1 < s2	判断字符串 s1 是否小于 s2, s1 小于 s2 返回 0，否则返回 1
		test s1 > s2 	判断字符串 s1 是否大于 s2, s1 大于 s2 返回 0，否则返回 1
		test -n s 		判断字符串 s 长度是否为非 0, s 长度为非 0 返回 0，否则返回 1
		test -z s 		判断字符串 s 长度是否为 0, s 长度为 0 返回 0，否则返回 1
		// 数值判断
		test n1 -eq n2  判断数值 n1 是否等于 n2, n1等于n2 返回 0，否则返回 1
		test n1 -ne n2  判断数值 n1 是否不等于 n2, n1 不等于 n2 返回 0，否则返回 1
		test n1 -gt n2  判断数值 n1 是否大于 n2, n1 大于 n2 返回 0，否则返回 1
		test n1 -ge n2  判断数值 n1 是否大于等于 n2, n1 大于等于 n2 返回 0，否则返回 1
		test n1 -lt n2  判断数值 n1 是否小于 n2, n1 小于 n2 返回 0，否则返回 1	
		test n1 -le n2  判断数值 n1 是否小于或者等于 n2, n1 小于 n2 返回 0，否则返回 1	
	(2)test命令和if语句配合使用
		比如: 
			if test -e file	// 当test命令返回0时执行then后的语句
			then
				commands
			fi
		注意:
			1.if和test配合使用时, 可以简写为if [ -e file ], 其中省略了test的声明
			2.第一个方括号之后和第二个方括号之前必须加上一个空格。
②declare 命令
	变量的默认类型为字符串
	1、变量声明为数值型
		declare -i num=12   // 声明
		或者:
			declare -i num
			i = 12
		declare -p num		// 查看	输出declare -i num="12"
		
	2、声明数组变量
	（1）定义数组
		// 方法1
		declare -a arr
		arr[0]=0
		arr[1]=1
		arr[2]=2
		// 方法二
		declare -a arry[0]=0 arry[1]=1 arry[2]=2		// 声明为数组类型
	（2）查看数组
		echo ${arr} ---结果0
		echo ${arr[1]} ---结果1
		echo ${arr[2]} ---结果2
		方法二
		declare -p arr
		和普通变量区别是使用大括号，同时使用下标，若没有下标，则默认使用0。

	3、声明环境变量
		declare -x t=123
		export命令调用的也是上面declare -x 的命令

	4、声明变量只读属性
		declare -r a=123
		重新赋值会报错，不能修改，不能删除	
		
	5、查看变量属性
		declare -p     查看所有变量属性
		declare -p  变量名  查看指定变量的属性

	综上所述，declare声明变量总结如下：
	declare [+/-][选项] 变量名
	选项：
	   -：给变量舍得类型属性
	   +：取消变量的类型属性
	  -a：将变量声明为数组型
	  -i：将变量声明为整型
	  -x：将变量声明为环境变量
	  -r：将变量声明为只读变量
	  -p：查看变量的被声明的类型

②条件判断(跟test语句配合在一起)
	(1)if-then-fi语句
		if command
		then
			commands
		fi
	  说明：
		 1，每一个 if 语句都有一个 fi（即倒过来写的 if）作为结束标记。
		 2，分支结构中使用 then 作为起始语句。
		 3，当 if 语句后面的语句执行结果为真（即为 0）时，then 以下的语句才会被执行。
	  例:
		my_variable="Full"
		if test $my_variable
		then
			echo "returns a True"
		else
			echo "returns a False"
		fi
		// 执行结果: returns a True	
	
	(2)if-then-else-fi语句
		if command
		then
			commands
		else
			commands
		fi	
	   说明:
		1.当 if 语句中的命令返回退出状态码 0 时， then 部分中的命令会被执行
		2.当 if 语句中的命令返回非零退出状态码时，bash shell会执行 else 部分中的命令	
	
	(3)if-then-elif-then-else-fi语句
		if command
		then
			commands
		elif command
		then
			commands
		else
			commands
		fi	
	   说明:
		1.当 if 语句中的命令返回退出状态码 0 时， then 部分中的命令会被执行
		2.当 if 语句中的命令返回非零退出状态码时，bash shell会继续判断elif后的命令, 若命令返回0,执行elif下的then
		3.若ifhe elif后的命令都返回非0, 那么执行else下的命令
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
【五】case命令(选择条件分支)
	(1)语法
		case $变量名 in
		 模式1 | 模式2）	// 或
			 命令序列
			 命令...
			 ;;
		 模式3）
			 命令序列
			 ;; 
		 *）
			 默认执行的命令序列
			 ;;     
		esac	
	(2)特点
		1.case行尾必须为单词 in 每个模式必须以右括号 ） 结束
		2.双分号 ;; 表示命令序列结束
		3.匹配模式中可是使用方括号表示一个连续的范围，如[0-9]；
		4.使用竖杠符号“|”表示或。
		5.最后的“*）”表示默认模式，当使用前面的各种模式均无法匹配该变量时，将执行“*）”后的命令序列。	
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
【五】for命令(分支)
	(1)语法
		for var in list
		do
			commands
		done	
	  说明: 在每次迭代中，变量 var 会包含列表中的当前值。第一次迭代会使用列表中的第一个值，第二次迭代使用第二个值，以此类推

	(1)指定列表的值
		1.直接指定:
			for var in 1 2 3 4 5
		2.从变量读取列表
			list="Alabama Alaska Arizona Arkansas Colorado"
			list=$list" Connecticut"
		3.从文件中读取
			file="for.c"
			for state in $(cat $file)	// 或者: for state in cat `$file`
	// 练习: 计算1到100的和
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
【六】算术运算
(1)使用 expr 外部程式
	expr 命令能够识别少数的数学和字符串操作符
	如: c=$(expr 1 + 5)	// +好两边必须有空格
(2)使用$[ operation ]
	如: var1=$[1 + 5]
(3)使用let 命令	
	如: let a=5+4
		let b=9-3 
		echo $a $b
(4)declare i num=$a+$b
(5)2：使用 $(( ))
	r=$(( 4 + 5 ))
	echo $r
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
【七】字符串处理(简单的)
(1)	 ${}简单用法
	1.# 是去掉左边
	2.% 是去掉右边
	3.单一符号是最小匹配r两个符号是最大匹配(贪婪匹配)。
	4.${file:m:n}：从m个字节开始提取n个字节	//从左往右
	5.${file/dir/var}：将第一个 dir 提换为 var
	6.${file//dir/$path}：将全部 dir 提换为 $path
	7.${#var}:获取var的字节数
		例:
		~# qq=www.qq.com
		~# var=@
		~# echo ${qq#*.} 		//排除第一个
			qq.com
		~# echo ${qq##*.}		//排除前两个
			com	
		~# echo ${qq%.*} 		//排除后一个
			www.qq
		~# echo ${qq%%.*}		//排除后两个
			www
		~# echo ${qq/./$var} 	// 第一个.替换为$var	
			www@qq.com
		~# echo ${qq//./$var} 	// 所有.替换为$var
			www@qq@com
		~# echo ${#qq}			// 获取变量的字节数	
			10	
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
【八】正则表达式
	---------------------------------------------------------------------------------
	元字符 	    含义 						示例 		说明
	---------------------------------------------------------------------------------
	  .   		匹配一个任意字符 			a.b			匹配以 a 开头 b 结尾，中间有一
														个任意字符的单词
	---------------------------------------------------------------------------------
	 [ ]       	匹配一个指定范围的字符 		a[xyz]b		匹配以 a 开头 b 结尾，中间有一
	---------------------------------------------------------------------------------
	 [^ ]     	 匹配一个不在指定范围的字符 a[^xyz]b		匹配以 a 开头 b 结尾，中间有一
														个不是 x 或 y 或 z 的字符的单词	
	---------------------------------------------------------------------------------
	  ^       	匹配行首 					^ab 		匹配以 ab 为行首的单词
	---------------------------------------------------------------------------------
	  $   	   	匹配行尾 					ab$			匹配以 ab 为行尾的单词
	---------------------------------------------------------------------------------
	  \    		转义符 						\<ab\> 		使<和>成为有特殊含义的符号	
	---------------------------------------------------------------------------------
	 < >  		匹配一个指定的单词 			\<ab\> 		精准匹配 ab 这个单词
	---------------------------------------------------------------------------------
	 | 			逻辑或 						ab|AB 		匹配 ab 或者 AB
	---------------------------------------------------------------------------------
	 ? 			使前面的字符重复0次或1次 	ba?c 		匹配 a 重复了 0 次或 1 次的单词	
														// 匹配*bc*, 或者	*bac*	 
	---------------------------------------------------------------------------------
	 * 			使前面的字符重复0次或多次    ba*c 		匹配 a 重复了 0 次或多次的单词	
	---------------------------------------------------------------------------------
	 + 			使前面的字符重复1次或多次     a+ 		匹配 a 重复了 1 次或多次的单词
	---------------------------------------------------------------------------------
	{n} 		使前面的字符重复n次 		     a{6} 		匹配 a 重复了 6 次的单词	
	---------------------------------------------------------------------------------
    {n,} 		使前面的字符重复n次或以上     a{6,}	    匹配 a 重复了 6 次或以上的单词	
	---------------------------------------------------------------------------------
	{n,m} 		使前面的字符重复n次到m次 	 a{6,9}  	匹配 a 重复了 6 次到 9 次的单词	
	---------------------------------------------------------------------------------
	 -/~		区间						[a-z] [1-9] // [abc...z] [123...9] 
	---------------------------------------------------------------------------------
	注意: 1.{}需要转义
		  2.[]不需要转义
		  3.空格用空白表示( )
		  4.并不是所有的linux命令都支持正则表达式(find就不支持)	
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
【九】sed(替换,删除,插入,打印)
①注意  1.在单引号里面，元义字符可以直接使用，如果要去掉元义则要在前面加\ ； 
	  2.在双引号里面，sed的命令要使用元义，则需要加\ ，
	  3.而命令的正则表达式要使用元义直接使用就行。
②常用选项
	-e：它告诉sed将下一个参数解释为一个sed指令，只有当命令行上给出多个sed指令时才需要使用-e选项
	-f：后跟保存了sed指令的文件
	-i：直接对内容进行修改，不加-i时默认只是预览，不会对文件做实际修改
	-n：取消默认输出，sed默认会输出所有文本内容，使用-n参数后只显示处理过的行
	
③常用编辑命令
	N 	预先多读取一行
	nN	在读取第n行时多读取一行
	s 	替换, 替换掉匹配的内容
	a 	追加, 向匹配行后面插入内容
	i 	插入, 向匹配行前插入内容
	c 	更改, 更改匹配行的内容
	d 	删除, 删除匹配的内容
	p 	打印, 打印出匹配的内容，通常与-n选项和用
	+np  打印匹配的行且打印出后面的n行
	= 	用来打印被匹配的行的行号
	n 	读取下一行，遇到n时会自动跳入下一行
	r,w	读和写编辑命令，r用于将内容读入文件，w用于将匹配内容写入到文件
	&	代替被匹配的变量
	g	一行中所有的匹配项, 缺省只会匹配第一个
	gn	一行中从第n个开始之后的所有匹配项
	n,$/s	$表示最后一行
	a$	$表示行末匹配	
	如果使用正则表达式匹配项的时候使用了圆括号括了起来，那么可以用\1，\2，\3……等来表示圆括号里面的项	


	
④应用
	1，替换文件中所有符合的文本
		例如，将"-year"改成" years"：	
		sed  "s/-year/years/" people.txt 
		
	2, 替换某行的第一个文本
		例如，将第2行的"-year"改成" years"：
		sed  "2s/-year/years/" people.txt

	3. 替换多行的第一个文本
		sed  "2,5s/-year/years/" people.txt

	3，直接通过sed修改原文，加选项 -i选项
		sed  -i "2s/-year/years/" people.txt
		注意：sed缺省状态下不会修改原文

	4，替换某行的符合的所有文本(g)
		sed  "2s/s/S/g" people.txt
		注意：g的意思是一行中所有的匹配项，否则缺省只会匹配第一个s
		
	5，替换某行符合的第n个文本
		sed  "2s/s/S/2" people.txt	// 替换第二行第二个符合的文本

	6，替换每一行中的第2个以后的小写s为大写S：
		sed  "s/s/S/2g" people.txt	
		

	[多个匹配]
	7，将所有"old"改成"OLD"，并且将第2行及以后行的后两个字符去掉
		sed -e 's/old/OLD/' -e '2,$s/..$//'	1.txt
	  等价于: 
		sed 's/old/OLD/; 2,$s/..$//' 1.txt
	  说明: 1.-e：它告诉sed将下一个参数解释为一个sed指令，只有当命令行上给出多个sed指令时才需要使用-e选项
			  2.第1个$: 最后一行
				第2个$: 行尾
	8，将&代替被匹配的变量：
		sed "s/is/[&]/" people.txt
		意思是==>：将文本中每一行出现的第一个is的左右两边加上[ ]
		
	[难点]
	9.如果使用正则表达式匹配项的时候使用了圆括号括了起来，那么可以用\1，\2，\3……等来表示圆括号里面的项：
		sed "s/\(^.*\)\tis.*from \(.*\)./\1\t:\2/g" people.txt
		1. .*表示匹配任意文本
		2. .t是制表符(键入tab键)
		3. \(^.*\)\tis.*from \(.*\).
			1. \1 = (^.*)\tis 表示匹配Tab键is前面的任意字符
			2. from(.*\). 表示匹配from之后, .之前的任意字符
				==> \2 = (.*)
			3.\t: : 表示键入tab键,后面加个冒号
		例: 	
			sed "s/\(^.*\)\tis \(.*\)-.*from \(.*\)./\1\t\2\t\3\t/" people.txt
		结果为:
			Jack    18      US
			Mike    16      Canada
			Chen    21      China
			Laui    18      HongKong
			Michael 20      UK
			Phoebe  18      Australie
	// 插入		
	10，提前预读多一行缓冲来进行匹配(N)：
		sed "N; s/old/OLD/" people.txt
	   等价于 sed -e N -e "s/old/OLD/" people.txt
	   由于替换只会针对第一个出现的单词is，而通过N又多读了一行，因此这个命令的结果是只会替换奇数行。				
	
	10.1 第1行到底3行读取时多读取一行
		sed -e "1,3N" -e "s/old/OLD/"  people.txt	
			
	11，在指定行的前面插入(i)或者后面插入(a)一些信息：
		sed '3i abcd' people.txt  意思是==>在第3行的前面插入abcd
		sed '2a abcd' people.txt  意思是==>在第2行的后面插入abcd
		sed '1,4a abcd' people.txt  意思是==>在第1至4行的后面分别插入abcd
		sed '/US/a abcd' people.txt  意思是==>在匹配US的行的后面插入abcd			
	
	// 替换行
	12, sed "2c ok" people.txt  意思是==>将第2行替换成ok

	13，删除指定的行
		sed ‘2d’ people.txt  意思是==>将第2行给删掉
		sed ‘/US/d’ people.txt  意思是==>将匹配/US/的所有行给删掉
		sed  '/\<he\>/d' people.txt 意思是==>将匹配he的所有行给删掉，注意：之所以要用<>将he给括起来，是因为不想匹配she，当然，<>需要转义，写成\<\>
	
	14，打印指定匹配的行，用命令p：
		sed '/Chen/p' people.txt  -n  意思是==>打印匹配Chen的行
		sed '/Chen/, /Lau/p' people.txt  -n  意思是==>打印匹配Chen或者Lau的行
		sed '3,/UK/p' people.txt  -n  意思是==>从第3行开始打印，直到匹配UK为止
		sed '/UK/,6p' people.txt  -n  意思是==>从匹配UK的行开始打印，直到第6行为止
	
	15，使用相对位置：
		sed '/US/, +2p' people.txt -n  意思是==>打印匹配US的行，并打印其后的2行。

	16，执行多个命令：
		sed '{/he/{/18/p}}' people.txt -n 意思是==>匹配所有/he/的行之后，再匹配/18/的行，然后打印出来。			

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
【十】awk (表格)
	测试文档：(grade.txt)
	name		date	id		color	NO	core
	M.Tansley	05/2013	48311	Green	8	90
	J.Lulu		04/2012	48317	green	12	88
	P.bunny		02/2013	48		Yellow	9	70
	J.Troll		09/2013	4842	Brown-3	11	95
	L.Tansley	05/2013	4712	Brown-2	10	85
	Vincent		07/2012	4712	Brown	13	87			
			
			
			
			
			
			
			
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
【十】函数
(1)定义函数
	①方法一:
	function name {
		echo $1			// 里面的$1跟脚本运行时传入的参数毫不相干, 这里的参数是一个局部变量
		echo $2
	}
	②方法二:
	name() {
		echo $1
		echo $2
	}
(2)使用函数
	name $arg1 $arg2
	
(3)函数中使用变量
	(1)对sh脚本而言:不管是在函数外部定义的变量还是在函数内部定义的变量都会被视为全局变量
	(2)如果在函数内部定义的全局变量的名称与外部定义的变量相同, 那么会覆盖掉全局变量的值
	(3)如果想在函数内部定义的变量与函数外不冲突, 那么应该在函数内部定义变量时应该加上local关键字。
		加上local关键字的变量即使与函数外的变量同名，他们也不会冲突，因为他们在不同的内存空间
		
(3)返回值	
	1.默认情况下，函数的退出状态码是函数中最后一条命令返回的退出状态码
	2.return 命令来退出函数并返回特定的退出状态码	// return 0
	3.查看函数的返回值可以用$?				 //  $? 来保存上个已执行命令的退出状态码
	4.函数中可以使用exit来退出整个shell程序
(4)函数的递归
	1.局部函数变量的一个特性是自成体系。除了从脚本命令行处获得的变量，自成体系的函数不需要使用任何外部资源。
	2.函数可以调用自己来得到结果。
	  比如: 下面的代码会10到1
		#!/bin/bash
		declare i=10
		func()
		{
			if [ $i -eq 0 ]
			then
				exit 0
			else
				echo $i
				let i--
				func()
			fi
		}
func(4)参数问题
	注意:
		1.传入函数的参数是函数内的局部变量。 跟脚本文件传入的参数毫不相干。
		2.当执行函数时如果未传入参数, 而函数里面使用了$n。 这时即使脚本传入了参数
			函数里面的$n也为空
		3.例：
		执行./1.sh 11 22
		#!/bin/bash
		# 这里是1.sh的参数, 是全局变量
		echo $1 	// 11	
		echo $2		// 22

		fun()
		{
		# 这里是fun()的参数, 是局部变量
			echo $1 	// zhangshan
			echo $2		// lishi
		}
		arg1=zhangshan
		arg2=lishi
		fun $arg1 $arg2

		# 这里是1.sh的参数
		echo $1			// 11
		echo $2			// 22
	
	
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
作业:
	1.判断当前目录是否存在一个file.txt, 不过不存在则创建他, 并写一串字符进去。
	  如果存在就将其北非为file.txt.bk
	2.写一个脚本核算当前目录下的文件个数(包括目录)
		法一:ls ls -l | grep '\-rw' | wc
		法二:
			#!/bin/bash
			declare i=0;
			list=`ls`
			for var in $list
			do 
				if test -e var		// if [ -e var ]
				then
					let i++
				fi
			done
	3.一运行脚本, 自动给.c文件生成模板代码: 
		如: (1)./templet.sh hello.c 如果hello.c不存在就创建hello.c
			(2)如果hello.c已经存在,将询问是否要覆盖文件: 输入yes覆盖, no不覆盖
				如果不覆盖应该立即退出脚本
			(2)在hello.c中添加模板代码
			(3)然后用vi编辑器打开hello.c
			
			// 脚本
			#!/bin/bash
			#检查文件是否存在, 不存在则创建
			#如果文件存在输入yes编辑文件(覆盖), 输入no退出

			file=$1
			if [ -e $file ]
			then
				echo "$file aready exists!"
				echo "input \"yes\" overlay $file"
				echo "input \"no\" exit"
				
				read tmp
				if [ $tmp = no ]
				then
					exit 0
				fi
			else
				touch $file
			fi

			#将cat ./templet的执行结果输出到$var中
			cat ./templet > $file		
			vi $file	
	4 练习: 在一个文档中找座机号码
		1.区号是3位到4位, 第一位必须是0
		2.区号后要么有个-或者空格
		3.区号后是7~8位电话号码 
		grep "^0[0-9]\{2,3\}[- ][0-9]\{7,8\}" num_info.txt -Hnw
		-H   --with-filename   #在显示符合样式的那一行之前，表示该行所属的文件名称。
		-n   --line-number   #在显示符合样式的那一行之前，标示出该行的列数编号。  
		-w   --word-regexp   #只显示全字符合的列。   
		
	
	
	
	
	
	
zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz
总结的命令:
	1.touch test.c		// 创建文件
	2.tree	dir_2017	// 查看目录树
	3.source 1.sh		// 终端目录会根据1.sh中的命令切换
						// 而./1.sh不会
	4.read -p "pleace input" str	// 将键盘的输入保存到变量str中
		-a 后跟一个变量，该变量会被认为是个数组，然后给其赋值，默认是以空格为分割符。
		-p 后面跟提示信息，即在输入前打印提示信息。
		-n 后跟一个数字，定义输入文本的长度，很实用。
		-r 屏蔽\，如果没有该选项，则\作为一个转义字符，有的话 \就是个正常的字符了。
		-t 后面跟秒数，定义输入字符的等待时间。
		-u 后面跟fd，从文件描述符中读入，该文件描述符可以是exec新开启的。						
		...
 	5.wc [OPTION]... [FILE]
		-c	统计字节数
		-l	统计行数
	6.seq命令
		1.seq用于产生从某个数到另一个数之间的所有整数
		2.-f指定格式，%后面指定数字的位数
			例:
			1.%3g表示指定3位数，不足3位的数，前面有个空格
			2.%03g表示指定3位数，不足3位数的前面用0填充
			3.%的前面可以加字符串
		3.-s指定分隔符，没有-s的时候，默认以回车分隔，也可以指定\n分隔，分隔符都写在双引号里，
			还可以用任意字符分隔，但是双引号里不能为空，可以是至少一个空格	
			// 例: seq -s"\n" -f "str%03g" 9 13
			// 例: mkdir $(seq -f "dir%03g" 1 5)	// 一次生成5个文件夹
			
	7.grep 
		-H   --with-filename   #在显示符合样式的那一行之前，表示该行所属的文件名称。
		-n   --line-number   #在显示符合样式的那一行之前，标示出该行的列数编号。  
		-w   --word-regexp   #只显示全字符合的列。   
		-R	 的意思是递归的对目录下的所有文件（包括子目录）进行 grep。	






