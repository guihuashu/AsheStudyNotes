################################################################################################################
参考书:
	嵌入式Qt实战教程
		(视频监控)
	Qt 5.9 C++开发指南QT5.9编程开发指南
		<多线程讲得详细>
	Qt 4编程
		<多线程, 网络编程, 嵌入式编程>
	Qt5开发实战
		<对各个类讲解的很清楚>, 线程, 数据传输, 网络编程, 进程间通信, 多媒体, 安卓
	Qt on android
#####################################################################################################
3.Qt中的模块	
	Qt Core： 核心模块，提供了其它模块所必需的数据类型和非图像类
	Qt GUI： 图形用户界面(GUI)组件的基类，包括OpenGL
	Qt Widgets: 使用QWidget扩展的控件类
	Qt QML： QML和JavaScript语言的类
	Qt Quick：用于构建具有自定义用户界面的高动态应用程序的声明性框架
	Qt Quick Controls：quick应用程序中使用的控件类
	Qt Quick Dialogs： quick应用程序中使用的对话框类
	Qt Quick Layouts：quick应用程序中使用的布局类
	Qt Network：网络库
	Qt SQL：数据库
	Qt Multimedia：多媒体库
	Qt Multimedia Widgets: 基于Multimedia开发的控件类
	..............
	

################################################################################################################
问题：
	Qt5.12ui界面改变后，必须构建，提示代码才更新。
		解决：1.将构建和运行的勾全部选上
			  2.不断的打开/关闭Qt，创建新项目，多次后会成功
################################################################################################################
注意:
	1.引用C++类时, 必须在pro中的HEADERS +=中添加头文件路径, 在SOURCES +=中添加源文件, 否则报错"找不到参数表"
	2.结构体重可以使用带信号槽机制的类, 并且信号和槽机制能被触发
	3.具有信号槽功能的类中可以包含结构体, 这个结构体也可以定义类变量(含信号槽功能), 可以将结构体里面类变量的信号连接到外层类的槽函数中
	4.主线程不能死循环, 否则不能处理事件循环
	5.QString转换为char*:  QString.toLatin1().data()	// 只能转换英文
	6.“?”表示\r\n符号
▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃
							第2章  Qt on android
▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃




▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃
							第2章  按钮控件组
▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃
【一】QAbstractButton属性
	text: 显示在按钮上的文字
	icon: 图标
	iconSize 图标的尺寸
	shortcut	相对路径
#####################################################################################################
【二】QPushButton
	flat			// 点一下隐藏按钮,只显示文字, 再点一次恢复
	
#####################################################################################################
【二】QCheckBox		// 提供了一个带有文本的"选择盒子"
(1)概述
	1.QCheckBox可用于QButtonGroup中		
	2.复选框状态改变时会发出stateChanged()信号
	
(2)QCheckBox的状态转换
	①设置了"三态属性"(tristate)
		QCheckBox有三种状态(口, 矩形填充, √)
		1.使用setTristate()设置该属性
		2.使用checkState()查询该属性
	②未设置了"三态属性"(tristate)
		1.QCheckBox仅有2种状态(口, √)
		2.可以用isChecked()函数来查询复选框是否被选中
	③复选框的三种状态
        Qt::Unchecked,			// 未选中(口)
        Qt::PartiallyChecked,	// 部分检查(就是实体矩形填充)
        Qt::Checked				// 选中(√)
(3)快捷键指定
	1.可以通过在首选字符前加上＆符号来指定快捷键。
		如: QCheckBox *checkbox = new QCheckBox("C&ase sensitive", this); // 快捷时alt+A 
	2.如果要想显示&符号, 那么应该用&&, 此时快捷键会失效。
(4)信号	
	void stateChanged(int state)	// 状态改变
(5)槽
	除了继承的槽,QCheckBox类没有实现任何槽	

	
▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃
						第3章 输入控件组
▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃
【一】QLineEdit
	(1)概述
		1.QLineEdit 部件 是一个 单行的 文本编 辑器
		2. 它允许 用户输 人和编 辑单行的纯文 本内容 ，而 且提供 了一系 列有用 的功能 ，包括 撤销与 恢复、 剪切和 拖放等 操作。
	(2)输入掩码:
						QLineEdit 掩 码字符
		------------------------------------------------------------------------------------
		字符(必须 输人）				字符 （可留空） 		含义
		------------------------------------------------------------------------------------
		A							a				只能输入 A ～ Z,a～ z
		------------------------------------------------------------------------------------
		N							n				只能输入 A ～ Z,a～ z
		------------------------------------------------------------------------------------
		X							x				可以 输人任 意字符
		------------------------------------------------------------------------------------
		9							0				只能输入 0 ～ 9
		------------------------------------------------------------------------------------
		D							d				只能输入 1 ～ 9
		------------------------------------------------------------------------------------
									#				只能输入加号 + ) ， 减号- ，0 ～ 9
		------------------------------------------------------------------------------------
		H							h				只能 输入十 六进制 字符, A ～ F, a ～ f, 0 ～ 9
		------------------------------------------------------------------------------------
		B							b				只能输 入二进 制字符 ，0 或 1
		------------------------------------------------------------------------------------
					>								后面的字母字符自动转换为大写
		------------------------------------------------------------------------------------
					<								后面的字母字符自动转换为小写
		------------------------------------------------------------------------------------
					!								停止字母字符的大小写转换
		------------------------------------------------------------------------------------
					\								将该表 中的特 殊字符 正常显 示用作 分隔符	
		------------------------------------------------------------------------------------
	(3)输入验证
		1.在 QLineEdit 中还可 以使用 验证器 来对 输人进 行约束
		2.演示代码
			// 新建 验证器 ，指定 范围为 100-999
			QValidator *validator = new QInt Validator (100, 999, this)?
			// 在行编辑器中使用验证器
			ui — >lineEdit3 —>set Validator (validator );
			
	(4)自动补全
		1.利用QCompleter类实现
		2.代码
			QStringList wordList;
			wordList << "Qt" << "Qt Creator" << tr("你好");
			QCompleter*completer =	completer ->setCaseSensitivity(Qt::QCompleter ( wordList ， this );// 新 建自动 完成器
			// 设大小写不敏感
			new	ui ->llneEdit4 ->setGompleter( completer)	
		3.运行 程序，在最后一个行编辑器 中输人“ Q”, 则自 动出现“ Qt”和“ Qt Creator” 两个 选项。	
			
	(5)常用属性
		inputMask:			// 输入掩码;
		text:				// 输入的文本
		maxLength			// 允许输入的最大文本数, 汉字和英文都是算一个
		frame				// 是否显示输入框
		echoMode			// 回显模式(密码, 不显示, 显示)
		cursorPosition		// 光标的额日子
		alignment			// 布局(居中,左, 右)
		dragEnabled			// 拖动使能
		readOnly			// 只读
		placeholderText		// 提示语句
		cursorMoveStyle		// 光标移动风格
		clearButtonEnabled	// 显示清除按钮
▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁
【二】QTextEdit	(文本编辑)	
	①作用
		TextEdit项显示一个可编辑的格式化文本块。它可以显示纯文本和富文本。
	②QTextEdit操作的三个模式：
		一般文本编辑器  setTextFormat(PlainText)  
		富文本编辑器    setTextFormat(RichText)  
		文本查看器		 setReadOnly(TRUE)  
		// 调用setTextFormat()来设置你想使用的模式。
	③概述
		1.QTextEdit可以显示图片（使用QMimeSourceFactory）、列表和表格。
		2.文本编辑可以载入一般文本和HTML文件（HTML3.2和4的子集）。表现风格和有效标记集由styleSheet()来定义。
		3.如果你想要一个有只读文本浏览器，请使用QTextBrowser。如果你只是想显示一小条多信息文本，请使用QLabel或者QSimpleRichText。 
	④使用QTextEdit作为一个显示窗口部件
		1.QTextEdit可以显示一个包括表格和图片的大的HTML子集。 
		2.文本通过使用setText()来设置或者替换，它删除任何已经存在的文本并且用传递给setText()调用的文本替换它。
		3.文本可以使用insert()、paste()、pasteSubType()和append()来插入。
		4.整个文本可以使用clear(), 来被删除并且被选择的文本可以使用removeSelectedText()来被删除。
		5.被选择（被标记）的文本也可以使用del()来被删除
		6.超文本链接可以自动加上下划线，这个可以通过setLinkUnderline()来改变。
		7.zoomIn()和zoomOut()函数能够用来通过增加（对于zoomOut()是减少）使用的点的大小来重新定义文本的大小。
	⑤使用QTextEdit作为一个编辑器 
		1.当前格式属性可以通过setItalic()、setBold()、setUnderline()、setFamily()（字体族）、setPointSize()、setColor()和setCurrentFont()来设置。
		2.当前段落的对齐方式使用setAlignment()来设置。 
		3.使用setSelection()来选择文本。setSelectionAttributes()函数用来指出被选择文本应该如何被显示。
		4.使用hasSelectedText()来搜索是否有任何文本被选择。
		5.当前被选择文本的位置可以由getSelection()提供并且被选择文本本身被selectedText()返回
		6.可以使用copy()来复制到剪贴板，或者使用cut()剪切到剪贴板中。
		7.它可以被removeSelectedText()删除。使用selectAll()可以选择（或者取消选择）整个文本。
		8.使用setCursorPosition()和getCursorPosition()可以分别设置和获得光标的位置。
		9.当光标被移动，信号currentFontChanged()、currentColorChanged()和currentAlignmentChanged()被发射来影响新光标位置的字体、颜色和对齐方式。 
		10.如果文本改变了，textChanged()信号被发射，并且如果用户通过按下回车键或者换行键插入一个新行，returnPressed()被发射。如果文本已经被修改，isModified()函数将会返回真。 
		11.QTextEdit提供基于命令的撤销和恢复。使用setUndoDepth()可以设置命令历史的深度，默认为100步。
		12.调用undo()或redo()可以撤销或者恢复上一次操作。信号undoAvailable()和redoAvailable()表明撤销和恢复操作是否可以被执行。 
		13.QTextEdit提供基于命令的撤销和恢复。使用setUndoDepth()可以设置命令历史的深度，默认为100步。调用undo()或redo()可以撤销或者恢复上一次操作。信号undoAvailable()和redoAvailable()表明撤销和恢复操作是否可以被执行。 
		14.使用toPlainText（）；获取编辑框里面的文本
▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁
【三】QComboBox	
①概述
	可以使用插入函数insertItem（）和insertItems（）填充组合框。
	可以使用setItemText（）更改项目。
	可以使用removeItem（）删除项目，并使用clear（）删除所有项目。
	可以使用setMaxCount（）设置最大项目数。






▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃
						第4章 显示控件组
▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃
【一】QWidget	
	(1)概述
		1.QWidget类是所有用户界面对象的基类， 被称为基础窗口部件 。
		2.QWidget 继承自 QObject类和 QPaintDevice类。
		3.QObject 类是所有支持 Qt对 象模型 Object Model)的对象的基类。
		4.QPaintDevice类是所有可以绘制的对象的基类。
		5.QWidget提供了自我绘制和处理用户输人等基本功能。
		6.Qt 提供的所有界面 素不是 QWidget 的子类就是与 QWidget 的子类相关联 。
		7.要设 计自己的窗口部件， 可以继承自 QWidget 或者是它的子类。
		8.注意:
			1.以QWidget主窗口为父类的对象不需要我们自己使用delete释放, 系统会自动释放。
			2.在主窗口的构造函数中只能动态分配对象, 因为构造函数退出后栈中的局部变量被销毁。
			3.当主窗口上有对话框时, 调用他的close槽并不是关闭了他, 而是隐藏了起来, 可以再次调用show来显示
			4.对话框关闭后可以再次打开。
			
	(2)窗口类型
		1.QWidget的构造函数有两 参数 ： QWidget *parent = 0 和 Qt::WindowFlags f = 0. 	
		2.parent 指父窗 口部件 ，默认值为 0, 表明没有父窗口；
		3.f 参数是 Qt::WindowF丨ags 类型的 ，是 Qt:: WindowType 枚举类型值的或组合。
		4.Qt::WindowType 枚举类型用来为部件指定各种窗口系统属性 ，比如 f=0 表明窗口类型的值为 Qt::Widget
	(3)QWidget属性	
		QObject				// objectName: 每个窗口部件都有的对象名
		QWidget				// enable: 使能窗口
		geometry: 			// 设置窗口的大小, 位置	
			X Y 宽度 高度
		sizePolicy: 		// 尺寸策略, 如果我们使用布局管理器,策略设置为expanding, 改变窗口时, 部件会自动缩放
		mininumSize:		// 拖动窗口的最小尺寸
		maxinumSize:		// 拖动窗口的最大尺寸
		baseSize:			// 设置窗口基本尺寸(没用)
		palatte				// 调色板: 继承
		font				// 字体
		cursor				// 将鼠标移动的窗口上的显示形状
		mouseTracking		// 鼠标跟踪
		tablettracking		// 表跟踪
		focusPolicy 		// 焦点政策: 是否获取焦点
		contextMenuPolicy 	//	怎样显示上下文菜单
		acceptDrops 		//	接受拖动	
		toolTip 			//	控件的提示
		toolTipDuration 	//	控件的提示时间
		whatsThis 			//	控件的帮助内容
		accessibleDescription //	说明（默认是空）
		accessibleName 		//	名称（默认是空）
		layoutDirection 	//	布局方向
		autofillBackground 	//	自动填充背景
		styleSheet 			//	控件的样式(表)
		locale 				//	本地属性(语言/国家/地区)	
		inputMethodHints 	//	控件的输入模式的提示	
		enabled				//	有效
		updatesEnabled 		//	是否激活了updates功能
		modal				//	是否模态控件
		isActiveWindow 		//	是否激活窗口
		inputMethodHints 	//	控件的输入模式的提示
#########################################################################################################################
【二】QFrame
	(1)概述:
		1.QFrame类是带有边框 的部件的基类 。
		2.Qt中凡是带有 Abstract字样的类 都是抽象基类 。
		3.子类包 括最常用的标签部件QLabel另外还有QLCDNumber QSplitter QStackedWidget QToolBox 和 QAbstractScro lArea 类。
	(2)用途
		1.QFrame类的主要功能就是用来实现不同的边框效果
			主要是由边框形状和边框阴影组合来形成的
		
	(3)属性
		frameShap		// 边框形状
		frameShadow		// 边框阴影
		lineWidth		// 边界线的宽度
		midlineWidth 	// 在边框中额外插入的一条线 的宽度，这条线的作用是为了形成 3D 效果 ，
#########################################################################################################################
【三】QLCDNumber		
	可以 让数码 字符显 示类似 液晶数 字一样 的效果 。	
#########################################################################################################################
【四】QStackedWidget	
		QStackedWidget 类提供 了一个 部件栈 ，可 以有多 个界面 （称 为页面 ）， 每个 界面可
	以拥有 自己的 部件， 不过每 次只能 显示一 个界面 。这个 部件需 要使用 QComboBox 或
	者 QListWidget 来选择 它的各 个页面 。
#########################################################################################################################
【五】QProgressBar	// 提供一个水平或者垂直的进度条(继承于QWidget)
1.进度条使用步数的概念,可以通过设置最大最大步数和最小步数来设置它。
	setMinimum()	setMaximum（）
2.我们提供当前步数值后, 他会提供当期步数值的百分比。
	setValue()
3.可以将进度条倒回到开始的地方。
	reset()
4.如果最大值和最小均被设置为0， 进度条将显示"忙碌指示符", 而不是"百分比"。
▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁
QImage类
【一】概述
	1.QImage类提供与硬件无关的图像表示，允许直接访问像素数据，并可用作绘图设备。
	2.Qt提供了四个用于处理图像数据的类：QImage，QPixmap，QBitmap和QPicture。
	3.QImage专为I / O和直接像素访问和操作而设计和优化，而QPixmap则专为在屏幕上显示图像而设计和优化。
	4.QBitmap只是一个继承QPixmap的便利类，确保深度为1.
	5.QPicture类是一个记录和重放QPainter命令的绘图设备。
	6.QImage是QPaintDevice子类，所以可以使用QPainter直接绘制到图像上。
	7.QImage类支持Format enum描述的几种图像格式。
	8.QImage提供了一系列功能，可用于获取有关图像的各种信息。还有几个功能可以转换图像。
【二】读和写图像文件
	1.QImage提供了几种加载图像文件的方法：
		1.可以在构造QImage对象时加载文件
		2.也可以在以后使用load（）或loadFromData（）函数加载。
		3.QImage还提供静态fromData（）函数，从给定数据构造QImage。 
	2.加载映像时，文件名可以引用磁盘上的实际文件，也可以引用应用程序的其中一个嵌入资源。
	3.只需调用save（）函数即可保存QImage对象
【三】Qt支持的头像格式
		
	
	
	
▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃
								第5章  对话框
▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃
(1)概述
	1.QDialog类是所有对话框窗口类的基类 ，
	2.对话 框窗口是一个经常用来完成短小任务或者和用户进行简单交互的顶层窗口 。
	4.对话框分类:
		1.模态的(modal) :
			1.在没有关闭它之前，不能再与同一个应用程序的其他窗口进行交互，比如新建项 目时弹 出的对 话框。
			2.想使一个对 话框成为模态对话框，则只需要调用它的 exec()函数；
				dialog->exec();
		2.非模态的 (modeless)
			1.在没有关闭它之前，既可以与它交互，也可以与同一程序中的其他窗口交互 ，
			2.调用show()函数:dialog->show();
		3.原因:
			1.因为调用完show()函数后会立即将控制权交给调用者，程序可以继续往下执行。
			2.而调用 exec()函数, 只有对话框窗口被关闭时才会返回
▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁
(2)对话框的信号和槽	
	1.对话框最显著的是accepted()和rejected()信号, 与之对应的分别是槽accept()和reject()
	2.如果对话框正在执行exec()函数
		1.调用槽accept(),使对话框关闭,exec()函数返回1。
		2.调用槽reject(),使对话框关闭,exec()函数返回0。
	3.如果我们创建带按钮的ui对话框，那么这两个按钮默认就是绑定的accepted()和reject()信号，
		关联的槽默认是accept()和reject()
▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁
(3)在主界面中使用自定义的对话框	
	1.创建主窗口QMainWindow, 上面放置一个按钮
	2.添加界面类dialog
	3.在主函数: 将按钮的点击事件与对话框的显示绑定
		MainWindow w;
		Dialog d;
		QObject::connect( (w.get_ui())->pb, SIGNAL(clicked()), &d, SLOT(exec()) );
		w.show();
▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁
(4.1)颜色对话框
	用途:
		颜色对话框类 QColorDialog提供了 个可以获取指定颜色的对话框部件 
	1.使用静态函数来打开颜色对话框, 和获取返回的颜色值
		// 1.getColor函数会打开一个颜色对话框（参数: 设置初始颜色 、指定父窗口、设置对话框标题。）
		// 2.我们可以选择颜色
		// 3.关闭对话框后, getColor函数返回我们选中的颜色值
		QColor color =   QColorDialog::getColor(Qt::red, this, "颜色");		
		qDebug()<<color();
	2.通过创建颜色对话框对象来获取颜色值
		QColorDialog d(this);		// 创建颜色对话框
		d.exec();					// 运行颜色对话框, 直到关闭才会返回
		qDebug()<<d.currentColor(); // 获取当前的颜色值
	3.颜色值(ARGB 1， 1， 0, 0)
▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁
(4.2)文件对话框(QFileDialog)
	用途:
		QFileDialog 类提供了一个允许用户选择文件或文件夹的对话框 。
	(1)获取文件路径
		①静态函数, 获取选择的单个文件名和路径
			QString fname = QFileDialog::getOpenFileName(this, "标题", "./", "*")
			参数:指定父窗口、设置对话框标题、 指定默认打开的目录路径、设置文件类型过滤器 。
		②静态函数, 获取选择的多个文件名和路径
			QStringList fnames = QFileDialog::getOpenFileNames(this, "标题", "./", "*");
			说明: 1.该函数返回一个用户选择的文件名, 这个文件名可以是不存在的。
				  2.如果用户选择一个存在的文件, 函数将返回选择的文件名。
					将弹出一个是否替换源文件的对话框。
	③静态函数, 另存和保存 
		getSaveFileName函数来实现保存文件对话框和文件另存为对话框 
	④获取一个已经存在的文件夹路径
		getExistingDirectory()函数来获取一个已存在的文件夹路径。
		//QString path = QFileDialog::getExistingDirectory();
	⑤也可以通过创建对象的方式
	⑤关于过滤器	
		1.tr("图片文件(*png *jpg);;文本文件(*txt)")); // (*png *jpg)中间必须有空格
▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁
(4.3)字体对话框(QFontDialog)	
	用途: QFontDialog 类提供 了一个 可以选 择字体 的对话 框部件 。
	①使用了getFont()静态函数来获取选择的字体。
		QFont font = QFontDialog::getFont(&ok, this);
		// 第一个参数ok表示我们是否选中了字体, 如果我们直接关闭字体对话框没有选择,
			那么ok为false, 否则fase为ture
	②也可用创建对象的方式
▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁
(4.4)输入对话框	(QInputDialog)	
	用途: QInputDialog 类提供了一个可以选择字体的对话框部件。可以让用户输人一个数值或字符串 。
	①getTextO 函数可以提供一 个可输人字符串的对话框 ，
		1.各参数的作用分别是:
			1.指定父窗口、
			2.设置窗口标题、
			3.设 置对话框中的标签显示文 、
			4.设置输入字符串的显示模式 (例如密码可以显示成小黑点，这里选择了显示用户输人的实际内容）、
			5.设置输人框中的默认字符串和设置获取按下按钮信息的bool变量；
		2.举例
			//QString instr = QInputDialog::getText(this, "标题", "标签");
	②getInt函数可 以提供一个输入整型 数值的对话框 ，
		例:  int in = QInputDialog::getInt(this, "输入对话框", "请输入0-100的整数, 默认为50", 50, 0, 100, 2, &ok);
	③getDouble() 函数可以提供一个输人浮点型数值的对话框 
	④getltem() 函数提供一个可以输人一个条目的对话框 
▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁
(4.5)消息对话框		
	作用:
		1.QMessageBox 类提供了一个模态的对话框来通知用户一些信息。
		2.或者向用户提出一 个问题并且获取答案。
	①问题对话框
		ret =  QMessageBox::question(this, "问题对话框", "你了解Qt吗?" );
	②提示对话框
		ret =  QMessageBox::information(this, "提示对话框", "往前走" );
	③警告对话框
		ret =  QMessageBox::warning(this, "警告", "不能接受" );
	④错误对话框
		ret =  QMessageBox::critical(this, "错误提示框", "err0" );
	⑤关于对话框
		QMessageBox::about(this, "关于提示框", "关于爱是第七" );
		
	// 注意: 返回值在QMessageBox中用宏定义了
▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁
(4.6)进度对话框		
	①作用: 进度对话框 QProgressDialog 对一个耗时较长操作的进度提供了反馈 。
	②编写步骤
		void Widget::on_pushButton_4_clicked()
		{	int i = 0;
			QProgressDialog d("复制进度", "取消", 0, 100, this);

			// 将对话框设置为模态, 只有对话框关闭时, 主窗口才可响应事件
			d.setWindowModality(Qt::WindowModal);
			d.show();
			while(i++ <= 100) {
				d.setValue(i);      // 设置进度条的值
				QCoreApplication::processEvents();  // 让QT窗口在死循环过程中能捕捉事件, 否则系统会卡死
				if(d.wasCanceled()) {   // 如果点击了取消按钮
				   qDebug()<<"取消复制";
					return;
				}
				QThread::msleep(100);
			}
			qDebug()<<"拷贝成功";
		}
▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁
(4.7)向导对话框		
	①作用: 向导对话框 QWizard 类提供了一个设计向导界面的框架 。
		//运行程序可以看到，向导页面出现的顺序和添加向导页面的顺序是一致的。	
	②示例程序
	void Widget::on_pushButton_5_clicked()
	{	
		// 定义三个向导页面对象
		QWizardPage page1(this), page2(this), page3(this);

		// 设置向导页面的标题
		page1.setTitle("安装向导");
		page2.setTitle("选择安装目录");
		page3.setTitle("安装完成");

		// 定义一个向导框架对象
		QWizard wizard(this);

		// 给向导框架对象上添加3个向导页面
		wizard.addPage(&page1);
		wizard.addPage(&page2);
		wizard.addPage(&page3);

		// 运行向导框架对象
		wizard.exec();
	}

▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃
							第6章  布局管理
▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃
(1)概述
	①能使用布局管理器的对象
		1.所有QWidget的子类实例（QWidget的子类的所有对象都可以使用布局管理器管理位于它们之中的子部件)
	②布局管理器的作用
		1.根据窗口的大小调整控件大小
		2.如果隐藏或显示布局管理器窗口时, 包含的所有空间也随之隐藏和显示
			ui->verticalLayoutWidget->show();
			ui->verticalLayoutWidget->hide();
	③注意
		 如果我们嵌套使用布局管理器, 就不能再分配局部布局管理器时指定父窗口,
		因为如果我们指定了父窗口, 那么vbox->addWidget()会立即反应到widget上, 后面的布局管理器
		就不会起作用了。
			1.我们可以使用this->setLayout(最终布局管理器);来嵌套使用
			2.也可以将最终的布局管理器的父窗口指定为this， 因为这时不再会有布局管理器覆盖他
			3.使用QWidget::SetLayout()函数可以在一个部件上应用布局管理器。
				注意: 如果是嵌套使用, 那么只能在最后的布局管理器设置好后再调用该函数。
	④// 设置窗口变化时部件xy方向都能变化
       bt4->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding); // 窗口变化时按钮xy方向都能变化
▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁
(2)基本布局管理器(QHBoxLayout、QVBoxLayout)
	ayout Name现在 所使用 的布局 管理器 的名称
	layoutLeft Margin		// 设置布局管理器到界面左边界的距离
	layoutTop Margin		// 设置布局管理器到界面上边界的距离
	layoutRightMargin		// 设置布局管理器到界面右边界的距离
	layoutBottomMargin		// 设置布局管理器到界面下边界的距离
	layoutSpacing			// 设置布局管理器中各部件的间距
	layoutSt retch			// 伸缩因子
	layoutSizeConstraint	// 设置大小约束条件
	基本用法:
		// 注意: 这里不能指定按钮和布局管理器的父对象为窗口, 否则不能嵌套使用布局管理器
		QPushButton *bt1 = new QPushButton();
		QPushButton *bt2 = new QPushButton();
		bt1->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding); 
		bt2->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding); 
		QHBoxLayout *hbox = new QHBoxLayout();
		QVBoxLayout *vbox = new QVBoxLayout();
		hbox->addWidget(bt1);
		this->setLayout(hbox);		
		vbox->addWidget(bt2);	
		this->setLayout(vbox);		// 将会覆盖布局管理器hbox及其部件
▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁
(3)栅格布局管理器(QGridLayout)
	①作用
	    QGridLayout 类使部件在网格中进行布局，它将所有的空间分隔成一些行和列 ，行和列的交叉处形成了单元格 ，
	  然后将部件放入一个确定的单元格中。	
    ②代码清单
		QPushButton *bts[5];
		QGridLayout *glaout = new QGridLayout();
		QString name[5] = {"pb1", "pb2","pb13","pb4","pb5"};
		for(int i = 0; i<5; i++)
			bts[i] = new QPushButton(name[i]);
		// 将第0个按钮放入第0行第0列的位置
		glaout->addWidget(bts[0], 0, 0);
		// 将第1个按钮放入第0行第1列的位置
		glaout->addWidget(bts[1], 0, 1);
		// 将第2个按钮放入第1行第0列的位置, 合并第一行第一列元素的位置
		glaout->addWidget(bts[2], 1, 0, 1, 2);
		// 将第3个按钮放入第2行第0列的位置
		glaout->addWidget(bts[3], 2, 0);
		// 将第4个按钮放入第2行第1列的位置
		glaout->addWidget(bts[4], 2, 1);
▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁
(4)窗体布局管理器(QFormLayout)
	①作用
		1.QFormLayout 类用来管理表单的输人部件以及与它们相关的标签 。
		  窗体布局管理器将它的子部件分为两列 ，左边是一些标签，右边是一些输人部件，
		2.QGridLayout类也可以实现该功能, 那为什么还要用QFormLayout ?
			因为: QGridLayout创建的表单的输入框长度不可以随窗口的变化而变化, 而QGridLayout可以的
	②基本用法(输入部件长度随窗口变化)
		QFormLayout* layout = new QFormLayout();	// 分配布局管理器
		QLineEdit* text1 = new QLineEdit();			// 分配行标签
		layout->addRow("Name:",text1);				// 增加一行(表单项)
		setLayout(layout);							// 布局管理器应用到窗口上(会覆盖已经在该窗口上设置的布局管理器)
▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁
(5)嵌套使用布局管理器()	
	// 只能在所有布局管理器都设置完成后,在调用this->setLayout(allVBox);来设置窗口的布局管理器, 否则重复设置会覆盖。
       // 水平布局
    QPushButton *bt1 = new QPushButton();
    QPushButton *bt2 = new QPushButton();
    QPushButton *bt3 = new QPushButton();
    QHBoxLayout *hbox = new QHBoxLayout();
    hbox->addWidget(bt1);
    hbox->addWidget(bt2);
    hbox->addWidget(bt3);
    //this->setLayout(hbox);	// 如果设置会被后面的覆盖


    // 垂直布局
    QPushButton *bt4 = new QPushButton();
    bt4->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding); // 窗口变化时按钮xy方向都能变化
    QPushButton *bt5 = new QPushButton();   // 只能x方向变化
    QPushButton *bt6 = new QPushButton();
    QVBoxLayout *vbox = new QVBoxLayout();
    vbox->addWidget(bt4);
    vbox->addWidget(bt5);
    vbox->addWidget(bt6);

    //this->setLayout(vbox);	// 如果设置会被后面的覆盖

    // 网格布局
    QPushButton *bts[5];
    QGridLayout *glaout = new QGridLayout();
    QString name[5] = {"pb1", "pb2","pb13","pb4","pb5"};
    for(int i = 0; i<5; i++)
        bts[i] = new QPushButton(name[i]);
    glaout->addWidget(bts[0], 0, 0);
    glaout->addWidget(bts[1], 0, 1);
    glaout->addWidget(bts[2], 1, 0, 1, 2);
    glaout->addWidget(bts[3], 2, 0);
    glaout->addWidget(bts[4], 2, 1);
    //this->setLayout(glaout);	// 如果设置会被后面的覆盖
	
    // 表单布局
    QFormLayout *form = new QFormLayout();
    QLineEdit *edit = new QLineEdit();
    form->addRow("表单标签", edit);
    //this->setLayout(form);	// 如果设置会被后面的覆盖
	
    // 嵌套布局为"垂直布局管理器"
    QVBoxLayout *allVBox = new QVBoxLayout(this);
    allVBox->addLayout(hbox);
    allVBox->addLayout(vbox);
    allVBox->addLayout(glaout);
    allVBox->addLayout(form);
    this->setLayout(allVBox);
	
▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁
(6)我们拖动一个布局管理器的构造过程
	1.分配一个布局管理器窗口LayoutWidget
	2.分配一个布局管理器Layout, 以LayoutWidget为父对象
	3.使用Layout->addWidget()往布局管理器中添加窗口
	代码清单:
        verticalLayoutWidget = new QWidget(Widget);
        verticalLayout = new QVBoxLayout(verticalLayoutWidget);
        pushButton_2 = new QPushButton(verticalLayoutWidget);
        verticalLayout->addWidget(pushButton_2);
		
▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃
							第7章  容器组
▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃
(1)QToolBox
	①作用
		QToolBox类提供了一列层叠窗口(widget)部件，就像常用的聊天工具QQ中的抽屉效果。
	
	②描述
		1.QToolBox中包含了多个Item, 每个Item实质是一个QWidget对象。
		2.每个Item都可以设置下面标出的属性
		3.可以使用setItemEnabled（）单独启用或禁用每个Item。
		4.使用addItem（）添加Item，或使用insertItem（）在特定位置插入Item。
		5.项目总数由count（）给出。
		6.可以使用delete删除项目。
		7.也可以使用removeItem（）从工具箱中删除项目。
		8.结合removeItem（）和insertItem（）可以将项目移动到不同的位置。
		9.当前项窗口小部件的索引由currentIndex（）返回，并使用setCurrentIndex（）设置。
		10.可以使用indexOf（）找到特定项的索引，并通过item（）返回给定索引处的项。
		11.当前项更改时会发出currentChanged（）信号。
	③QToolBox中每个条目的属性
		currentIndex		// Item的索引值
		currentItemText		// Item的标签
		currentItemName		// Item的对象名(是一个QWidget对象)
		currentItemIcon		// Item的图标
		currentItemToolTip	// 
		tabSpacing			// Item之间的间距
	④QToolBox的信号
		// QToolBox中的item切换时触发该信号, 传入条目的索引值currentIndex
		void currentChanged(int index)
	⑤增加Item
		int addItem(QWidget *widget, const QIcon &iconSet, const QString &text)
		int addItem(QWidget *w, const QString &text)
		如:
			QWidget *wfriend = new QWidget();
			QWidget *wstranger = new QWidget();
			ui->toolBox->addItem(wfriend, "好友");
			ui->toolBox->addItem(wstranger, "陌生人");	
	⑥往Item增加两个标签信息
		QLabel *lab1 = new QLabel("张三");
		QLabel *lab2 = new QLabel("李四");
		QVBoxLayout *vbox = new QVBoxLayout;

		vbox->addWidget(lab1);
		vbox->addWidget(lab2);
		wstranger->setLayout(vbox);
▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁
(2)QGroupBox
	①概述: 分组框通常带有一个边框和一个标题栏
	②属性
		title: 分组框的标题栏
		alignment:标题栏的对齐方式
		flat: 隐藏分组框的边框线
		checkable: 分组框变为可选择状态, 如果选中了, 分组框内的部件为不可选中状态
	③QGroupBox的信号
		// 这两个信号只有在checkable属性被启用时才会触发
		1.void clicked(bool checked = false)	// checkable属性改变时触发
		2.void  toggled(bool on)				// checkable属性改变时触发
▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁
(3)QButtonGroup
	①概述
		1.QButtonGroup提供了一个抽象容器，可以在其中放置按钮小部件。
			QPushButtons，QCheckBoxes（通常用于非专属按钮组）或QRadioButtons。 
		2.可以使用addButton（）将按钮添加到组中，并使用removeButton（）将其删除。
			addButton(QAbstractButton *button, int id = -1)
			参数:
				1.button为按钮指针
				2.id为我们分配的id, 我们可以在槽函数中捕捉这个id来确定是哪个按钮发的信号, fd==-1表示系统分配id
	②信号: 	buttonClicked
		void buttonClicked(QAbstractButton *);
		void buttonClicked(int);
		void buttonPressed(QAbstractButton *);
		void buttonPressed(int);
		void buttonReleased(QAbstractButton *);
		void buttonReleased(int);
		void buttonToggled(QAbstractButton *, bool);
		注意:
			1.当按钮组中的某一个按钮也被点击, 按下, 释放, 切换id操作时会触发对应的信号
			2.我们可以在槽函数中捕捉id。
▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁

▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃
							第8章  视图控件组
▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃
【一】QStandardItem(保存一个数据项)
①概述
	1.一个数据项Item由若干个『角色，数据子项』对组成。 // QStandardItemData
		// QStandardItemData的实质是一个role和value。// 『角色，数据子项』
		role是一个角色，是指设定进item的这个Qvariant所扮演的角色，实际就是对设定值的类型标定。
	2.类QStandardItem负责保存、访问这些数据。
	4.由于各个角色对应的数据子项可能具有不同的类型，Qt使用QVariant来存放每个数据子项。
	
	3.当用户希望将一些数据存放在一个QStandardItem对象中时，可以调用其成员函数
		void setData ( const QVariant & value, int role)将『role, value』对存入。
		/*	源码
		setData(const QVariant &value, int role)
			Vector<QStandardItemData>::iterator it;		
			for (it = d->values.begin(); it != d->values.end(); ++it)	// 从容器中找到item
				if ((*it).role == role) 
					(*it).value = value;	// QVariant赋给item
		class QStandardItemData
			int role;
			QVariant value;
		*/
	5.以上两个函数是QStandardItem的核心。有了这两个函数，我们就可以访问该类所表示数据项的任何一个『角色，数据子项』对。
	6.然而，对于一些常用角色，该类提供了更加简洁、容易记忆的成员函数
		1.当一个数据项被显示在视图中时，它往往包含一些文字、一个图标，还可能包含一个复选框。
		2.角色Qt::BackgroundRole控制显示背景，
		3.Qt::FontRole控制文字字体，Qt::ForegroundRole控制文字颜色，
		4.Qt::CheckStateRole控制复选框的状态。
	7.该类提供的一组成员函数可以方便地访问这些常用角色对应的数据子项。
		1.成员函数setBackground()、background()分别设置/返回背景刷子。
		2.函数setFont()、font()分别设置/返回文字字体。
		3.函数setForeground()、foreground()分别设置/返回字体颜色。
		4.函数setCheckState()、checkState()分别设置/返回复选框状态。
②该类的内部定义了一个类型为QVector<QStandardItem*>的容器
	1.每个容器元素本质上存放一个『角色，数据子项』对。
	2.可以将每个容器元素所指的QStandardItem对象设定为子对象
	3.类QStandardItem和自身具有“children”关系(自关联)。
	4.类QStandardItemModel定义了一个名为root的数据成员，逻辑上是一个指向QStandardItem对象的指针。

③宏Role的类型（variant存储的data类型）：
	Qt::DisplayRole			// 以文本形式呈现的关键数据。（QString的）
	Qt::DecorationRole		// 以图标形式呈现为装饰的数据。 
	Qt::EditRole			// 适合在编辑器中编辑的形式的数据。
	Qt::ToolTipRole			// 项目工具提示中显示的数据。（QString的）
	Qt::StatusTipRole		// 状态栏中显示的数据
	Qt::WhatsThisRole		// 在“这是什么？”中为项目显示的数据 模式。
	Qt::SizeHintRole		// 要提供给视图的项目的大小提示。
	// 描述外观和元数据的角色（具有关联类型）:
	Qt::FontRole			 // 字体类型
	Qt::TextAlignmentRole	 // 文本对齐类型
	Qt::BackgroundRole		 // 用于使用默认委托呈现的项目的背景画笔。（QBrush）
	Qt::BackgroundColorRole  // 这个角色已经过时了。 请改用BackgroundRole。
	Qt::ForegroundRole 		 // 前景画笔（通常为文本颜色），用于使用默认委托呈现的项目。（QBrush）
	Qt::TextColorRole 		 // 前景画笔（通常为文本颜色），用于使用默认委托呈现的项目。（QBrush）
	Qt::CheckStateRole 		 // 此角色用于获取项目的已检查状态。（QT:: CheckState）
	Qt::InitialSortOrderRole // 此角色用于获取标题视图部分的初始排序顺序。（QT:: SortOrder的）。 这个角色是在Qt 4.8中引入的。
	// 辅助功能角色（具有关联类型）：
	Qt::AccessibleTextRole			// 可访问性扩展和插件（如屏幕阅读器）使用的文本。（QString的）
	Qt::AccessibleDescriptionRole   // 用于可访问性目的的项目描述。（QString的）
	// 用户自定义
	Qt::UserRole 0100 // 第一个可用于特定应用程序目的的角色。
	// 对于用户角色，由开发人员决定使用哪些类型，并确保组件在访问和设置数据时使用正确的类型。

④QStandardItem的属性(Flags)
	Qt::NoItemFlags 			// 不设置任何属性
	Qt::ItemIsSelectable		// Item可选择
	Qt::ItemIsEditable 			// Item可编辑
	Qt::ItemIsDragEnabled 		// Item可拖拽
	Qt::ItemIsDropEnabled 		// Item上可被放置目标
	Qt::ItemIsUserCheckable 	// Item能够被用户选择, 显示一个复选框
	Qt::ItemIsEnabled 			// Item使能
	Qt::ItemIsAutoTristate 		// 项目的状态取决于其子项的状态。 这样可以自动管理QTreeWidget中父项的状态（如果检查了所有子项，则检查，如果未选中所有子项，则取消选中，或者如果仅检查某些子项，则检查部分检查）。
	Qt::ItemIsTristate = ItemIsAutoTristate,	// 弃用
	Qt::ItemNeverHasChildren = 128,				// 该item永远不会有子item, 仅用于优化
	Qt::ItemIsUserTristate = 256	// 用户可以循环通过三个独立的状态。
	继续看怎么增加checkbox
	注意:
		1.如果需要item可被选择
			1.需要为item提供一组合适的标志和初始状态
			2.要在model/view中做显示设置
			// item1->setCheckable(true);
		2.ItemFlags类型是QFlags <ItemFlag>的typedef。 它存储ItemFlag值的OR组合。
⑤给QStandardItem添加上复选框
     item->setCheckable(true);
	 // 实际就是设置了item1的(可被用户选择)属性
		源码:  d->changeFlags(selectable, Qt::ItemIsSelectable);
	 注意: 复选框状态改变时发出: void QStandardItemModel::itemChanged(QStandardItem *item)信号
⑤信号
	void QStandardItemModel::itemChanged(QStandardItem *item)	// item改变时发出该信号
	注意： 当item的复选框状态改变时也会发出该信号
	

⑥概述
	1.Item通常包括项目通常包含文本，图标或复选框。
	2.每个Item都有自己的背景画笔。
	4.默认情况下，项目已启用，可编辑，可选择，可检查，并且既可以用作拖放操作的源，也可以用作放置目标。
	5.没有信号和槽
⑦功能
	[1]每个item都有自己的背景画笔，使用setBackground（）函数设置。可以使用background（）找到当前背景画笔。
	[2]每个item的文本标签可以使用自己的字体和画笔进行渲染。
		使用setFont（）和setForeground（）函数指定的，并使用font（）和foreground（）读取。
	[3]可以通过调用setFlags（）来更改每个项目的标志。
	[4]可以使用setCheckState（）函数检查和取消选中可检查项目。checkState（）函数指示当前是否检查了该项。
	[5]调用setData（）将特定于应用程序的数据存储在item中。
	[6]多个item组成一个二维表
⑧应该在QStandardItemModel对象里面调用下列函数, 因为单个item向自己中增加item毫无意义, 也不能成功。
	[7]使用setRowCount（）和setColumnCount（）设置子表的维度。
	[8] 1.可以使用setChild（）将item放在子表中。使用child（）获取指向子项的指针。
		2.也可以使用insertRow（）和insertColumn（）插入新的子行和子列。
		3.或者附加appendRow（）和appendColumn（）。
		4.使用append和insert函数时，子表的维度将根据需要增长。
	[9]可以使用removeRow（）或takeRow（）删除现有的子行。
	[10]相应地，可以使用removeColumn（）或takeColumn（）删除列。
	[11]可以通过调用sortChildren（）对项目的子项进行排序。
⑨构造函数
	QStandardItem()
	QStandardItem(const QString &text)
	QStandardItem(const QIcon &icon, const QString &text)
	QStandardItem(int rows, int columns = 1)
##################################################################################################################	
【二】QStandardItemModel	
(1)概述
	①作用：QStandardItemModel将类QStandardItem表示的数据项组织起来，形成列表、表格、树甚至更复杂的数据结构。
	②说明: 
		1.QAbstractItemModel > QAbstractItemModel > QAbstractListModel, QAbstractProxyModel, and QAbstractTableModel(列表,树,表)	
		2.QStandardItemModel实现了QAbstractItemModel定义的接口函数,以使其他视图类能够访问模型中的数据项。
	③每个数据项是一个QStandardItem对象。
(2)为什么QStandardItemModel可以将类QStandardItem表示的数据项 \
	组织成列表、表格、树甚至更复杂的数据结构?
	①原因
		1.类QStandardItem在其内部定义了一个类型为QVector<QStandardItem*>的容器，
		  可以将每个容器元素所指的QStandardItem对象设定为子对象。
		2.类QStandardItem和自身具有“children”关系。(自关联)
		3.类QStandardItemModel定义了一个名为root的数据成员，逻辑上是一个指向QStandardItem对象的指针。
		4.这个对象可以设定多个QStandardItem的对象作为自己的子对象，而其中每个子对象又可以包含其他的子对象。
			依此类推，这棵树可以具有任意深度，每个父对象可以包含任意多个子对象。
		5.很自然地，QStandardItemModel可以使用QStandardItem表示具有树状数据结构的数据集
	②类QStandardItem使用自动关联形成的模型
		[1]list model(列表模型)
			QStandardItemModel
				  ↓
				 root	// invisibleRootItem()函数返回的不可见根Item
				  ↓	// 下面的第一层都是他的子对象
				 child_item1  
				 child_item2  
				 child_item3 
		[2]list model(表模型)
			QStandardItemModel
				  ↓
				 root	// invisibleRootItem()函数返回的不可见根Item
				  ↓	// 下面的第一层都是他的子对象
				 child_item1 →  item4 item5 item6	// item456是item1的子对象
				 child_item2 →  item7 item8 item9  // item789是item2的子对象
				 child_item3 →  itema itemb itemc  // itemabc是item3的子对象
		[3]list model(树模型)
			QStandardItemModel
				  ↓
				 root	// invisibleRootItem()函数返回的不可见根Item
				  ↓	// 下面的第一层都是他的子对象
				 item1 → item3  item4 ... 
				 item2		↓	  ↓
				 ...	  item5	 item7 	
						  item6	  ...
						  ..........
	③注意:
		对于数据量不是很大、对性能要求不是很高的场合，我们可以使用类QStandardItemModel来表示一个数据集。
		否则，用户应该从QAbstractItemModel、QAbstractListModel或者QAbstractTableModel派生新类，自行管理数据集的存放与访问。		
		
(3)数据集类型	
	①数据集被表示为一个列表
		1.调用类QStandardItemModel的成员函数appendRow()向列表中添加一个数据项。
			// 实质是找到视图模型的root_item, 然后调用root_item->appendRow函数。
		2.使用item(int row)读取一个item数据项。
		4.示例程序
			[1]等价[2]
				QIcon icon("../pic/111.jpg");
				QStandardItem item1(icon,"111");
				QStandardItem item2(icon,"222");
				QStandardItemModel listModel;
				QListView listView(&w);
				listModel.appendRow(&item1);	// // 实质是找到视图模型的root_item, 然后调用root_item->appendRow函数。
				listModel.appendRow(&item2);
				listView.setModel(&listModel);	
				// 读出item值中的文本(是一个Variant变量)
				qDebug()<<listModel.item(0)->data(Qt::DisplayRole).value<QString>();
				qDebug()<<listModel.item(1)->data(Qt::DisplayRole).value<QString>();
			[2]写法二
				QIcon icon("../pic/111.jpg");
				QStandardItem item1("111");
				QStandardItem item2("222");
				QStandardItemModel listModel;
				QListView listView(&w);
				QStandardItem *root_item = listModel.invisibleRootItem();
				root_item->appendRow(&item1);
				root_item->appendRow(&item2);
				listView.setModel(&listModel);	
			
	②数据集被表示为一个表格
		0.表格中的每一个item都有一个唯一的索引用QModelIndex表示,QModelIndex用行号和列号组成。
			用index（int row， int column）函数可以返回对应item的索引(QModelIndex)
			
		1.调用setRowCount(int row)和setColumnCount(int column)来设置表的行数,列数
		2.调用appendRow(rows)和appendColumn(columns);来附加一行或一列
			/*
			QStandardItemModel table_mode;
			QList<QStandardItem *> rows, columns;
			rows.append(&item0);
			rows.append(&item1);
			columns.append(&item2);
			columns.append(&item3);
			table_mode.appendRow(rows);
			table_mode.appendColumn(columns);		
			*/	
		3.调用类QStandardItemModel的成员函数setItem(int row, int column, QStandardItem *item)设定表格中的某个数据项
			使用item(int row, int column)获取item数据项
			/*
				QTableView table_view(&w);
				QStandardItem item0(icon, "000"), item1(icon, "111");
				QStandardItem item2(icon, "222"), item3(icon, "333");
				QStandardItemModel table_mode;
				table_mode.setItem(0,0,&item0);
				table_mode.setItem(0,1,&item1);
				table_mode.setItem(1,0,&item2);
				table_mode.setItem(1,1,&item3);			
			*/
		4.使用setHorizontalHeaderLabels()和setVerticalHeaderLabels()来给每一行和列增加一个文本标签
			QStandardItemModel table_mode;
			QStringList hlist, vlist;
			hlist<<"hlab1"<<"hlab2";
			vlist<<"vlab1"<<"vlab2";
			table_mode.setHorizontalHeaderLabels(hlist);
			table_mode.setVerticalHeaderLabels(vlist);	
	③如果数据集被表示为一个树，可以调用类QStandardItemModel的成员函数appendRow()向某个树节点添加子节点。
		1.可以调用类QStandardItemModel的成员函数appendRow()向某个树节点添加子节点。	
		2.通过多次调用appendRow(),生成调用者的子节点，可以构建一棵复杂的树。
		3.例:
		/*
			QStandardItem *root_item = tree_model.invisibleRootItem();
			root_item->appendRow(&item0);
			root_item->appendRow(&item1);
			item0.appendRow(&item2);
			item1.appendRow(&item3);
		*/
		生成了一颗这样的数
			invisibleRootItem
				item0 
					item2
				item1
					item3
⑤给QStandardItem添加上复选框
     item->setCheckable(true);
	 // 实际就是设置了item1的(可被用户选择)属性
		源码:  d->changeFlags(selectable, Qt::ItemIsSelectable);
	 注意: 复选框状态改变时发出: void QStandardItemModel::itemChanged(QStandardItem *item)信号
					
(4)向模型的不可见root_item中添加子节点(源码)
		QStandardItemModel::appendRow(QStandardItem *aitem)
			....
			// 最终： 调用模型的根节点(item)的appendRow函数，向根节点root_item中插入item
			invisibleRootItem()->appendRow(items); 	// 向	
(5)其他					
	1.可以使用setHorizontalHeaderLabels（）和setVerticalHeaderLabels（）设置模型的标题标签。
	2.可以使用findItems（）搜索模型中的项目，
	3.通过调用sort（）对模型进行排序。
	4.调用clear（）以从模型中删除所有项目。
	5.调用invisibleRootItem()返回调用模型的不可见root_item
			
##################################################################################################################	
【三】QAbstractItemView: (提供视图类的基本功能)
①概述	
	1.QAbstractItemView是视图类(QListView, QTreeView, TableView, ClomunView, UNdoView)的基类。
	2.它通过信号和插槽机制与模型进行互操作，使子类能够随着模型的变化而保持最新状态。 
	3.此类为键盘和鼠标导航，视口滚动，item编辑和选择提供标准支持。
②键盘导航实现的功能	
	  按键							功能
	Arrow keys					改变当前item并且选中
	Ctrl+Arrow keys				改变当前item不选择
	Shift+Arrow keys			改变当前item并且选中, 之前选中的item现在不选中
	Ctr+Space					切换当前选择的item
	Tab/Backtab					切换item
	Home/End
	Page up/Page down
	Ctrl+A	
③属性
	alternatingRowColors // 是否使用交替颜色绘制背景
	autoScroll			 // 是否启用了拖动移动事件的自动滚动
	autoScrollMargin 	 // 控制触发自动滚动的视口边缘区域的大小。
	defaultDropAction	 
	dragDropMode 		 // 视图将执行的拖放事件
	dragDropOverwriteMode// 保存视图的拖放行为
	dragEnabled 		 // item拖拽使能
	editTriggers 		 // 启动项目编辑的操作
	horizontalScrollMode // 视图如何在水平方向上滚动其内容 
	iconSize 			 // 图标大小
	selectionBehavior 	 // 视图使用的选择行为
	selectionMode 		 // 当前使用的视图模型	
	showDropIndicator 	 // 拖动项目和删除时是否显示拖放指示符。
	tabKeyNavigation 	 // 是否启用了带tab和backtab的item导航。
	textElideMode 		 // 此属性在省略的文本中保存“...”的位置。
	verticalScrollMode 	 // 垂直方向的滚动模式
④公有函数
	setModel(QAbstractItemModel *model)	// 设置要显示的视图的模型。
	void QsetSelectionModel(QItemSelectionModel *selectionModel) 
	// 将当前选择模型设置为给定的selectionModel。
		请注意，如果在此函数之后调用setModel（），则给定的selectionModel将替换为视图创建的一个。
		
⑤信号 
	void activated(const QModelIndex &index)	// 用户激活item指定的项目是发送
	void clicked(const QModelIndex &index)		// 单击item时发送
	void doubleClicked(const QModelIndex &index)// 双击item时发送
	void entered(const QModelIndex &index)		// 光标移动到item上时发送
	void iconSizeChanged(const QSize &size)		// item图标大小改变时发出信号
	void pressed(const QModelIndex &index)		// item被鼠标按下时发出
	void viewportEntered()						// 当鼠标光标进入视口时会发出此信号。 需要启用鼠标跟踪才能使此功能正常工作。
⑥槽
	void clearSelection()				// 取消选中的所有items, 当前选中的items不变
	void edit(const QModelIndex &index) // 开始在index处编辑项目，必要时创建编辑器，如果视图的State现在是EditingState，则返回true; 否则返回false。
	virtual void reset()						// 重置视图内部状态
	void scrollToBottom()						// 滚动视图到底部
	void scrollToTop()							// 滚动视图到顶部
	virtual void selectAll()					// 选择视图上的所有条目
	void setCurrentIndex(const QModelIndex &index)		// 设置当前的item为index
	virtual void setRootIndex(const QModelIndex &index)	// 将rootIndex设置为给定的index
	void update(const QModelIndex &index)				// 更新给定索引占据的区域
##################################################################################################################	
【四】QListView: 提供一个列表或者图标视图,比如QT项目文件的显示效果
①概述	
	1.QListView呈现存储在模型中的items，可以是简单的非分层列表，也可以是图标集合。
	2.此类用于提供先前由QListBox和QIconView类提供的列表和图标视图。
	3.此视图不显示水平或垂直标题;要显示带有水平标题的项目列表，请改用QTableView或者QTreeView。
②视图模式
	1.可通过setViewMode来更改视图模式, viewMode（）确定当前视图模式
	2.// enum ViewMode { ListMode, IconMode }; 
	[1]ListMode: 默认是ListMode(item的图标显示在前, item的文本显示在后)
	[2]IconMode: 用于: 显示Items管理器中的文件等图标
		Item的图标在上, 文字在下。
③其他列表视图显示模式操作
	[1]Item排列顺序setFlow（）函数设置
		1.可设置为从左到右或者从上到下
		2.enum Flow { LeftToRight, TopToBottom };
	[2]Item是否可拖动设置
		SetMovement(enum Movement)
		//  enum Movement { Static, Free, Snap };
		QListView::Static   0 	items不能被用户移动 (默认)
		QListView::Free 	1 	items能够被用户自由移动
		QListView::Snap 	2 	被移动时，item会捕捉到指定的网格; 请参阅setGridSize（）。
	[3]setWrapping(true)设置可环绕, 	isWrapping（）返回是否为可环绕状态。
	[4]resizeMode（）设置视图的大小是否固定， 默认为固定。
		// enum ResizeMode { Fixed, Adjust };
	[5]setLayoutMode（）控制视图的布局方式和时间。
		LayoutMode { SinglePass, Batched };	// 单通,批量
	[5]spacing()指定Item间的间隙大小。
	[6]使用setGridSize指定一个格子的长度和宽度。
	[7].这些项目可以根据其setIconSize（）设置图标大小。
④可以为每一个item指定一个索引窗口,(比如做一个下载界面)
③属性
	Movement		// 此属性用于保存item是否可以自由移动，是否可以捕捉到网格，还是根本无法移动。
	Flow			// item的排列方向
	isWrapping		// 可见区域中没有更多空间时item是否应该换行	
	ResizeMode		// 决定项目视图大小改变时,是否重新布置项目
	LayoutMode		// 确定项目布局时立即发生还是延迟(批处理)
	spacing			// item间距, 默认为0
	gridSize		// 设置视图为网格布局时的网格大小, 默认为空
	wordWrap		// 决定item是否被包裹
	ViewMode		// 列表模式: 从上到下布局。图标模式：从左到右布局
	modelColumn		// 默认显示的列
	uniformItemSizes// 决定所有item是否具有相同的大小
	batchSize		// 如果layoutMode设置为Batched，则此属性保存每个批次中布置的项目数默认值为100。
	selectionRectVisible	// 决定选择矩形是否可见
	itemAlignment	// 单元格中项目的对其方式。只有在具有TopToBottom流的ListMode中并且启用了包装时，才支持此功能。
(4)信号
	// 当指定的索引在视图中移动时触发该信号
	void QListView::indexesMoved(const QModelIndexList &indexes)
(5)示例:　使用QListView设置一个下载页面
	1.用QProgressBar做一个单文件的下载显示窗口
	2.在主窗口的构造函数中分配一个视图模型
		// ListModel = new QStandardItemModel(ui->listView);
	3.在主窗口中分配一个模型/视图显示窗口(QListView)
	4.在主窗口中添加一个按钮, 点一下添加一个下载栏, 按钮的槽函数如下:
	void Widget::on_pushButton_clicked()
	{
		Widget2 *w2 = new Widget2(ui->listView);	// 分配一个下载栏窗口
		QSize size = w2->size();					// 获取下载栏窗口的大小
		QStandardItem *item = new QStandardItem();	// 分配一个数据模型item
		item->setSizeHint(size+ QSize(1,1));		// 设置item的大小与下载栏窗口 + QSize（1,1）相同
		//item->setText(QString());					
		ListModel->appendRow(item);					// 将item加入列表模型/视图的不可见根节点(root_item), 及将item设置为root_item的子对象
		ui->listView->setModel(ListModel);			// 将数据模型设置到列表视图中	
		// 将(下载栏窗口)设置为(item的索引窗口), 这样下载栏窗口就显示在了item上
		ui->listView->setIndexWidget(item->index(), w2);
	}	
	
##################################################################################################################	
【五】QTableView : 提供表视图的默认 model/view 实现
	继承自QAbstractItemView
(1)概述
	1.QTableView实现QAbstractItemView类定义的接口。
	2.允许它显示由QAbstractItemModel类派生的模型提供的数据。
(2)item的定位
	可以通过使用鼠标单击单元格或使用箭头键来导航表格中的单元格。
(3)视觉外观
	①设置横向表头和纵向表头(不会)
		1.setVerticalHeader(QHeaderView *)
		2.setHorizontalHeader(QHeaderView *)
	②设置行高和列高
		setRowHeight（int row, int height）
		SetColumnWidth（int column, int height）
	③隐藏/显示一行/一列
		hide(int row)
		hide(int column)
		show(int row)
		show(int column)
	④选中一行或一列
		selectRow（）
		selectColumn（）
	⑤设置是否显示网格线
		tabView.setShowGrid(bool );
	⑥给表格中的某个索引Item设置窗口小部件
		// tabView.setIndexWidget(index, bt);
		// 使用item.index()返回item的索引
		QStandardItemModel table_model;
		table_model.setItem(0,0,&item0);
		table_model.setItem(0,1,&item1);
		QTableView tabView;
		tabView.setModel(&table_model);
		QModelIndex index = table_model.index(0, 0); // 找到Item的索引
		QPushButton *bt = new QPushButton("Test");	 // 给index为item设置窗口小部件
		tabView.setIndexWidget(index, bt);
(4)坐标系统
	1.默认情况下，表中的单元格不会展开以填充可用空间。
	2.可以通过拉伸最后一个标题部分使单元格填充可用空间。
	3.使用horizontalHeader（）或verticalHeader（）访问相关标头，并设置表头的stretchLastSection属性。
	4.要根据每个列或行的空间要求分配可用空间，请调用视图的resizeColumnsToContents（）或resizeRowsToContents（）函数。
##################################################################################################################	
【六】QFileSystemModel: 为本地文件系统提供数据模型。
	继承与QAbstractItemModel
(1)概述
	1.此类提供对本地文件系统的访问，提供重命名和删除文件和目录以及创建新目录的功能。
	2.在最简单的情况下，它可以与合适的显示小部件一起使用，作为浏览器或过滤器的一部分。
	3.可以使用QAbstractItemModel提供的标准接口访问QFileSystemModel，但它还提供了一些特定于目录模型的便捷函数。
	4. fileInfo（），isDir（），fileName（）和filePath（）函数提供有关与模型中的项相关的基础文件和目录的信息。 
	5.注意：QFileSystemModel需要一个QApplication实例。
(2)信号
	void directoryLoaded(const QString &path) // 收集线程完成该文件的加载时发出
	void fileRenamed(const QString &path, const QString &oldName, const QString &newName) // 文件名被替换时发出
	void rootPathChanged(const QString &newPath) // 根路径切换到newPath时发出
(3)用法介绍
	①将当前目录构造为文件系统模型
		QFileSystemModel file_model;
		file_model.setRootPath(QDir::currentPath());
	②使用树形视图来显示文件系统模型
		QTreeView treeView;
		treeView.setModel(&file_model);
		treeView.show();
	③设置树视图的根索引来显示特定目录的内容
		treeView->setRootIndex(model->index(QDir::currentPath()));
		注意:
			1.视图的根索引可用于控制显示多少层次模型。 
			2.QFileSystemModel提供了一个便捷函数，它为模型中的目录路径返回合适的模型索引。
##################################################################################################################	
【六】QTreeView : 提供树视图的默认model/view实现。
(1)可以用来显示文件系统模型
	/*
		QFileSystemModel *model = new QFileSystemModel;
		model->setRootPath(QDir::currentPath());
		QTreeView *tree = new QTreeView(splitter);
		tree->setModel(model);
	*/
(2)信号
	void collapsed(const QModelIndex &index)  // 目录折叠时发出信号, 参数时被折叠的索引	
	void expanded(const QModelIndex &index)	  // 目录展开时发出信号, 参数时被折叠的索引	
		/* 举例 
			Widget w;
			QIcon icon("../pic/111.jpg");
			QStandardItem item0(icon, "000"), item1(icon, "111");
			QStandardItem item2(icon, "222"), item3(icon, "333");

			/*     构造了一个树模型
				000
					222
				111
					333
			*/
			QStandardItemModel tree_model;
			tree_model.appendRow(&item0);   // 将item0设置为tree_model的不可见根节点的子对象
			tree_model.appendRow(&item1);

			item0.appendRow(&item2);        // 将item2设置为item0的的子对象
			item1.appendRow(&item3);        // 将item3设置为item1的的子对象

			QTreeView treeView(&w);
			treeView.setModel(&tree_model);
			QObject::connect(&treeView, SIGNAL(collapsed(const QModelIndex&)), &w, SLOT(slot(const QModelIndex&)));
			QObject::connect(&treeView, SIGNAL(expanded(const QModelIndex&)), &w, SLOT(slot(const QModelIndex&)));
			w.show();	
		*/
(3)视图说明	
	1.模型/视图体系结构确保在模型更改时更新树视图的内容。
	2.具有子项的项目可以处于展开状态（子项可见）或折叠（子项隐藏）状态。

	3.树视图中的表头是使用QHeaderView类构造的，可以使用header（） - > hide（）隐藏。
		请注意，每个标头都配置为其stretchLastSection属性设置为true，从而确保视图不会浪费为其标头分配给它的任何空间。
		如果此值设置为true，则此属性将覆盖标头中最后一部分上设置的调整大小模式。
	4.默认情况下，树视图中的所有列都可以移动，第一个除外。
		要禁用这些列的移动，请使用QHeaderView的setSectionsMovable（）函数。有关重新排列部分的详细信息，请参阅移动标题部分。	
	
▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃
							第9章  项目控件组
▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃
【一】QListWidgetItem // 提供了一个和QListWidget一起使用的item
(1)概述	
	①
		1.QListWidgetItem表示QListWidget中的单个项目。 每个项目可以包含多条信息，并将适当地显示它们。
		2.项目视图便利类使用经典的基于item的接口,而不是纯模型/视图方法。考虑将QListView类与标准模型一起使用。
	②构造方法
		1.在构造QListWidgetItem时,通过指定QListWidget,QListWidgetItem能够直接插入 QListWidgetItem中
			new QListWidgetItem(tr("Hazel"), listWidget);
		2.创建QListWidgetItem时,也可以不指定父窗口,构造好后用QListWidget::insertItem()插入QListWidget
	③典型的用法是用来显示文本,图标,可添加一个复选框
		setText()  setIcon()
		item->setCheckState(Qt::Unchecked);	// 打开item的复选框, 默认为没有选中状态
		item->setCheckState(Qt::Checked);	// 打开item的复选框, 默认为选中状态
		注意：
			1.可以用CheckState来返回item的复选框状态。
			2.CheckState通常在与QListWidget的itemChanged(QListWidgetItem *item)信号函数配合使用
				来确定用户是否选中了复选框。
	④自定义item的外观
		setFont(), setForeground(), and setBackground() setTextAlignment()
	⑤设置item的提示
		setToolTip()		// 工具提示
		setStatusTip()		// 状态提示
		setWhatsThis()		// 设置什么提示
	⑥item的默认状态
		1.enabled	2.selectable  3.checkable 4.可拖拽 5.可在上面放置窗口
	⑦isHidden()设置item是否隐藏
(2)属性
	1.每一个QListWidgetItem的状态都能通过调用 setFlags()来改变 // Qt :: ItemFlags, 跟QStandardItem中的属性一模一样
	③QListWidgetItem与QStandardItem 的实现原理相同, 同样可以给item启用复选框, 其实质是设置了item的(Qt::ItemIsUserCheckable)属性
		item->setCheckState(Qt::Unchecked);	// 打开item的复选框, 默认为没有选中状态
		item->setCheckState(Qt::Checked);	// 打开item的复选框, 默认为选中状态
		
###################################################################################################################
【二】QListWidget : 提供了一个基于item的窗口列表
(1)QListWidget 和 QListView的区别
	// 主要区别就是有木有自己的模型而已
	①QListView
		1.QListView继承于QAbstractItemView。
		2.QListView提供数据模型和视图分开的操作方法。
			QListView仅仅封装了数据模型(QStandardItemModel)的基本操作功能。并不包含数据模型本身(QStandardItemModel)。
		3.QListView中如果需要操作数据模型, 需要先调用统一的接口来给自己设置一个数据模型。
		  毕竟没有数据模型, 视图去操作什么呢?
			// QListView.setModel(QStandardItemModel *model);
		4.QListView支持为模型(QStandardItemModel)中的某一个QStandardItem对象添加一个窗口对象索引,
			这样就可以在某个item上显示一个窗口, 这使得继承他的子类QListWidget也具有该功能。
			（参阅笔记QListView）
		5.QListView提供数据模型和视图分开的操作方法，功能强大，操作繁琐不适合菜鸟使用（但是我不是菜鸟）
		
	②QListWidget
		1.QListWidget将视图和模型柔和在一起，使用户在item上显示窗口的操作更加简单。
		  但是他的功能就被局限于在item上显示窗口。
		2.分析源码：看QListWidget是如何同时封装视图和数据模型二者的。
			1.首先QListWidget继承于QListView，这就提供了视图的操作功能。
			2.分析提供数据模型的过程
				1. 增加一个item是QListWidgetItem对象
				  class QListWidget : public QListView
				  {	inline void addItem(QListWidgetItem *item);
				  }
				2.QListWidgetItem类里面封装的是一个QVector<QWidgetItemData>容器，实现了
					QWidgetItemData“自关联子对象”的方法。（跟QStandardItem的实现一模一样）
					class QListWidgetItemPrivate
					{    QVector<QWidgetItemData> values;	
					}	
				3.QWidgetItemData里面是一个[角色类型, 对象]的结构体（跟QStandardItem的实现一模一样）
					class QWidgetItemData
					{	int role;
						QVariant value;
					}
			3.QListWidget继承于QListView,也支持(将一个窗口设置为某个item的索引窗口)的方法
				setIndexWidget(const QModelIndex &, QWidget *)
				其实就是调用了QListView中的方法(和QListView是一样的)
					QAbstractItemView::setIndexWidget(index, widget);	
	③总结					
		在很多情况下，只需要把一小部分的项呈现给用户，这就没必要使用model这样重量级的组件。
			直接使用将数据模型和视图封装在一起的类QListWidget、QTableWidget、QTreeWidget
		（关于数据模型QStandardItemModel参考前面的笔记）
(2)构造方法
	QListWidgetItem(QListWidget *view = Q_NULLPTR, int type = Type); // 传入被被添加到的QListWidget
		// 传入显示的字符串和被添加到的QListWidget
	QListWidgetItem(const QString &text, QListWidget *view = Q_NULLPTR, int type = Type);
		// 传入显示的字符串、item的图标和被添加到的QListWidget
	QListWidgetItem(const QIcon &icon, const QString &text,
				 QListWidget *view = Q_NULLPTR, int type = Type);
		
(3)概述
	1.QListWidget是一个便利类，提供类似于QListView提供的列表视图，但具有用于添加和删除项的经典的基于项的界面。
	1.QListWidget是一个便利类，提供类似于QListView提供的列表视图，但具有用于添加和删除项的经典的基于项的界面。
	2.QListWidget内部使用了数据模型来管理列表中的每个QListWidgetItem。而QListView里面没有实现数据模型,需要用setModel(QStandardItemModel *)来添加一个模型
	3.构造方法与QListView相同。
(4)视图操作功能
	①.selectionMode()返回当前选中的item。
	②.向QListWidget中添加item的方法
		1.构造item是传入QListWidget
		2.构造好后使用 listWidget->insertItem(row, newItem)方法， 或者addItem()
		3.插入多个是使用： insertItems()
	③获取QListWidget中的item个数
	④从QListWidget中删除某个item
		takeItem(int row);
	⑤设置当前item和获取当前item
		1.currentItem()
		2.setCurrentItem()
		3.用户可以通过键盘导航或者在不同的item上点击来设置当前item
		4.当前item改变时会发出currentItemChanged(QListWidgetItem *current, QListWidgetItem *previous)信号。
	⑥QListWidget往某个item上放置一个窗口
		QListWidget::setItemWidget(QListWidgetItem *item, QWidget *widget)
	⑦设置显示模式
		ui->listWidget->setViewMode(QListView::IconMode);   //设置显示模式为图标模式
		ui->listWidget->setViewMode(QListView::ListMode);   //设置显示模式为列表模式
	
(5)信号
	void currentItemChanged(QListWidgetItem *current, QListWidgetItem *previous) // 当前条目改变
	void currentRowChanged(int currentRow)				// 当前条目改变
	void currentTextChanged(const QString &currentText) // 当前条目的文本改变
	void itemActivated(QListWidgetItem *item) 			// 条目被激活时(双击)
	void itemChanged(QListWidgetItem *item)				// 条目的数据被改变(复选框状态改变也会触发)
	void itemClicked(QListWidgetItem *item)				// 条目被单击
	void itemDoubleClicked(QListWidgetItem *item) 		// 条目被双击
	void itemEntered(QListWidgetItem *item)				// 鼠标光标进入条目
	void itemPressed(QListWidgetItem *item)				// 条目被按下
	void itemSelectionChanged()	// 选择的条目被改变
(6)槽
	void clear()	// 删除选中的所有条目
	// 如有必要, 滚动视图确保item可见
	void scrollToItem(const QListWidgetItem *item, QAbstractItemView::ScrollHint hint = EnsureVisible)
	
#################################################################################################################
【三】QTableWidgetItem	// 提供了一个和QTableWidget一起使用的item
	1.QTableWidgetItem通常用来显示文本,图标,和复选框
	2.QTableWidgetItem为QTableWidget提供了一个item
	3.其余与QListWidget使用类似, 并且也支持打开复选框
	
#################################################################################################################
【四】QTableWidget //  提供了一个基于item的表格视图和默认的数据模型。
(1)QTableWidget与QTableView的区别
	请参考QListWidget与QListView的区别
(2)概述
	1.QTableWidget为应用程序提供了一个标准的表格显示设备。
	2.QTableWidget中的items由QTableWidgetItem提供。
	3.如果我们想用自己的数据模型，应该用类QTableView，而不是QTableWidget。
	4.可通过行数和列数构造QTableWidget。
		tableWidget = new QTableWidget(12, 3, this);
(3)视图操作
	1.可以在构造好QTableWidget后，在指定表格大小
      tableWidget = new QTableWidget(this);
      tableWidget->setRowCount(10);
      tableWidget->setColumnCount(5);	
	2.Items在表外创建（不指定父窗口），并且用setItem()将item插入表中
		QTableWidgetItem *newItem = new QTableWidgetItem(tr("%1").arg((row+1)*(column+1)));
		tableWidget->setItem(row, column, newItem);	
	3.如果想在tableWidget中使能排序，应该用items填充之后在执行此操作, 否则排序可能会影响插入顺序
	4.QTableWidget同时给出水平表头和垂直表头
		1.创建表头最简单的方法是向 setHorizontalHeaderLabels() 和setVerticalHeaderLabels() 函数
		  提供一个字符串列表。这将为表的行和列提供一个提供一个简单的文本标题。
	5.rowCount()函数返回行数， columnCount()函数返回列数
	6.clear()清除表中的所有元素
	7.设置item中文本的对其方式
		cubesHeaderItem->setTextAlignment(Qt::AlignVCenter);
	8.item（int row, int column）可以返回列表中的item
	
(4)	QTableWidgetItem (提供了一个和QTableWidget类一起使用的item)
	QTableWidgetItem与数据模型QStandardItem一样, 
	
(4)QTableWidget继承于QTableView, 与可以为某个item设置一个索引窗口。(这样item上就可以显示一个窗口)
	参考QListView。
	void setIndexWidget(const QModelIndex &index, QWidget *widget);

#################################################################################################################
【五】QTreeWidgetItem	// 提供了一个和QTreeWidget一起使用的item
(1)概述
	1.QTreeWidgetItem通常用来填充QTreeWidget信息中的行, 一行通常包含几列数据
	2.每个Item都能够包含一个文本,图标,复选框
(2)构造方法
	1.构造时通常指定父对象。注意： 父对象既可以是QTreeWidgetItem也可以是QTreeWidget。
	  注意：如果构造时指定了父对象，那么被构造的对象时指定父对象的“子对象”，这样就构成了一个树形。
		QTreeWidgetItem *Item = new QTreeWidgetItem(treeWidget);	// 指定Item为treeWidget的子对象
		Item->setText(0, tr("new"));	
		QTreeWidgetItem *Item2 = new QTreeWidgetItem(Item);
		osloItem->setText(0, tr("Oslo"));// 给自己这一样设置文本	// 指定Item为Item2的子对象
		/* 结果:
			treeWidget窗口
				Item
					Item2
		*/
	2.上面指定父对象(QTreeWidget)进行构造的方法, 相当于是指定QTreeWidget的不可见根节点为父对象
		QTreeWidgetItem *rootItem = ui->treeWidget->invisibleRootItem();
		QTreeWidgetItem *item4 = new QTreeWidgetItem(rootItem);
		item4->setText(0,"4");
	3.要显示图标请使用item->setIcon();
(3)背景和文本渲染
		setBackground()	background()
		setFont()		setForeground()
		font() 			foreground()
(4)与QTreeWidgetItem与(QListWidgetItem和QtTableWidgetItem)的区别与共同点	
	1.QTreeWidgetItem与QListWidgetItem大体一致, 也支持设置QTreeWidgetItem的属性和显示复选框。
		1.setFlags()		//设置属性
		2.setCheckState()
	2.QTreeWidgetItem与（QListWidgetItem和QTableWidgetItem）最根本的区别是，后两者没有"子对象"。
(5)插入和删除子对象的方法
	①构造时指定父对象
	②insertChild()插入"子对象"
		// void insertChild(int index, QTreeWidgetItem *child);
	③takeChild()删除"子对象"
		// QTreeWidgetItem *takeChild(int index);
	
void QTreeWidgetItem::setText(int column, const QString &text)	// 将要在给定列中显示的文本设置为给定文本。	
#################################################################################################################
【五】QTreeWidget	// 提供了一个树形视图和一个树形数据模型(注意: QTreeView仅仅是一个视图,而没有数据模型)
	1.如果用户需要构造更加复杂的数据模型, 请使用QTreeView,然后QTreeView->setModel
	2.在用法上和前面叙述的QListWidget, QTableWidget是一样的, 只是某些接口和参数不同而已。
	

	
▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃
							第10章  定时器事件(QTimer)
▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃
①概述
	1.QTimer类提供重复和单次定时器。
	2.要使用它，请创建一个QTimer，将其timeout（）信号连接到相应的插槽，然后调用start（）。
	  从那时起，它将以恒定的间隔发出timeout（）信号。
	/*	  QTimer *timer = new QTimer(this);
		  connect(timer, SIGNAL(timeout()), this, SLOT(update()));
		  timer->start(1000);
	*/  
②创建单超时定时器
	1.QTimer默认是循环超时,我们可以调用setSingleShot（true）将计时器设置为仅超时一次。
	2.可以使用静态函数:QTimer::singleShot（）, 在指定的时间间隔后仅发出一次超时信号。
			/*  QTimer::singleShot(200, this, SLOT(updateCaption())); */
③在多线程中使用定时器
	1.可以在任何具有事件循环的线程中使用QTimer。
	2.要从非GUI线程中使用QThread :: exec（）来启动事件循环。
	3.Qt使用计时器的线程亲和性来确定哪个线程将发出timeout（）信号。
	4.因此: 必须在定时器所在线程来启动或者停止定时器; 无法从另一个线程启动或停止定时器。
④定时器的精度与分辨率： 取决于硬件
⑤槽
	void QTimer::start(int msec)
		1.以msec毫秒超时启动或者重启定时器。
		2.如果定时器正在运行，他将停止，然后重启
		3.如果定时器调用了setSingleShot（true）， 那么这个定时器仅激活一次。
	void QTimer::start()	
		1.使用interval中指定的超时启动或重新启动计时器。
		2.如果定时器正在运行，他将停止，然后重启
		3.如果定时器调用了setSingleShot（true）， 那么这个定时器仅激活一次。
	void QTimer::stop()
		1.停止定时器
⑥信号
	void QTimer::timeout()	// 超时时发送该信号
	注意：这是一个私有信号。 它可以用于信号连接，但不能由用户发出。
	
⑦其他函数
	bool QTimer::isActive() const	// 如果定时器正在运行返回ture, 反之返回false
▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁
(4)事件过滤器与事件的发送


▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃
						第11章  文件、目录、输入输出
▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃
(1)QIODevice
	①作用: 
		1.QIODevice类是Qt中所有I/O设备的基础接口类, 
		2.为诸如QFile QBuffer和QTcpSocket等支持读/写数据块的设备提供了一个抽象接口。
		3.一般是使用它所定义的接口来提供设备无关的I/O功能。
	②打开、读写、关闭设备:
		1.在访问设备之前，必须调用open（）打开设备并来设置正确的OpenMode（例如ReadOnly或ReadWrite）。 
		2. 然后，您可以使用write（）或putChar（）写入设备，并通过调用read（），readLine（）或readAll（）来读取。
		3.完成设备后，请调用close（）来关闭设备。
	③QIODevice支持随机访问设备和顺序访问设备
		1.随机访问设备支持使用seek（）寻找任意位置。 通过调用pos（）可以获得文件中的当前位置。
			// QFile和QBuffer是随机访问设备的示例。
		2.顺序设备不支持寻找任意位置。 必须一次读取数据。 函数pos（）和size（）不适用于顺序设备。
			// QTcpSocket和QProcess是顺序设备的示例。
		3.您可以使用isSequential（）来确定设备是否是顺序设备。
	④可读写信号:
		1.当新数据可供读取时，QIODevice会发出readyRead（）信号; 
		2.您可以调用bytesAvailable（）来确定当前可用于读取的字节数。	
		3.每次将数据有效负载写入设备时，QIODevice都会发出bytesWritten（）信号。
		4.使用bytesToWrite（）来确定等待写入的当前数据量。
	⑤实现自己的IO设备
		1.通过子类化QIODevice，您可以为自己的I / O设备提供相同的接口。 
		2.QIODevice的子类只需要实现受保护的readData（）和writeData（）函数	
		3.在继承QIODevice时，请记住绕过在无缓冲模式下打开设备时可能使用的任何缓冲区。
	⑥异步设备处理
		通常，来自异步设备的输入数据流是分段的，并且数据块可以在任意时间点到达。 
	  要处理数据结构的不完整读取，请使用QIODevice实现的事务机制。
	  有关更多详细信息，请参阅startTransaction（）和相关函数。
	⑦多通道处理
		1.一些顺序设备支持通过多个通道进行通信,这些通道代表具有独立排序传递特性的独立数据流。
		  打开设备后，您可以通过调用readChannelCount（）和writeChannelCount（）函数来确定通道数。
		2.要在通道之间切换，请分别调用setCurrentReadChannel（）和setCurrentWriteChannel（）。
			QIODevice还提供额外的信号来处理每个通道的异步通信。另请参见QBuffer，QFile和QTcpSocket。	
▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁
(1)QFile
	作用:　QFile类提供了用于读取和写入文件的接口。
	①概述
		1.QFile是一个用于读写文本和二进制文件和资源的I / O设备。 
		2.QFile可以单独使用，或者更方便地使用QTextStream或QDataStream。
		3.文件名通常在构造函数中传递，但可以使用setFileName（）随时设置。
		4.无论操作系统如何，QFile都希望文件分隔符为“/”。不支持使用其他分隔符（例如,'\'）。
	②功能
		1.您可以使用exists（）检查文件是否存在，并使用remove（）删除文件。（更高级的文件系统相关操作由QFileInfo和QDir提供。）
		2.该文件用open（）打开，用close（）关闭，用flush（）刷新。
			//重要：当使用缓存的文件工作时，数据没有被立刻写到文件中。调用flush()可以确保数据被真正地写完。 
		3.通常使用QDataStream或QTextStream读取和写入数据。
		4.但您也可以调用QIODevice继承的函数read（），readLine（），readAll（），write（）。 QFile还继承了getChar（），putChar（）和ungetChar（），它们一次只能处理一个字符。
		5.文件大小由size（）返回。您可以使用pos（）获取当前文件位置，或使用seek（）移动到新文件位置。如果已到达文件末尾，则atEnd（）返回true。
		6.QFile创建新文件：
			在open时带上WriteOnly或者ReadWrite标志时，如果文件为空，那么系统尝试新建一个文件
	③注意：
		1.传递给open（）的QIODevice :: Text标志告诉Qt将Windows样式的行终止符（“\ r \ n”）转换为C ++样式的终止符（“\ n”）。
		  默认情况下，QFile采用二进制，即它不对文件中存储的字节执行任何转换。
		2.打开文件时, 如果要清空文件内容,需要加上QIODevice::Truncate标志
	④转换	  
		1.QTextStream负责将存储在磁盘上的8位数据转换为16位Unicode QString。
			默认情况下，它假定使用用户系统的本地utf8位编码(但是windows文件默认编码为GBK2312)。 
		  
	⑤QTextStream读写文件(适用于读写普通文本文件)	// 效率高
		(1)读文件
			QFile file("in.txt");
			if (!file.open(QIODevice::ReadOnly | QIODevice::Text))
				return;
			QTextStream in(&file);
			while (!in.atEnd()) {
				QString line = in.readLine();
				process_line(line);
			}
		(2)写文件
			QTextStream out(&file);
			out << "The magic number is: " << 49 << "\n";
	⑥QDataStream读写文件(适用与读写带有特定格式的文件) // 效率高
		跟QTextStream读写相似,可以使用operator <<（）来写数据，使用operator >>（）来读回它。
	⑦信号
		1.与其他QIODevice实现（如QTcpSocket）不同，
		2.QFile不会发出aboutToClose（），bytesWritten（）或readyRead（）信号。
		3.此实现细节意味着QFile不适合读取和写入某些类型的文件，例如Unix平台上的设备文件。	
	⑧pulic函数
		QFile::QFile()
		QFile::QFile(fd)	// 用来处理linux打开的文件
		bool QFile::copy(const QString &newName) 	//将fileName（）当前指定的文件复制到名为newName的文件中。
			// 请注意，如果名为newName的文件已存在，则copy（）将返回false（即QFile不会覆盖它）。
		bool QFile::link(const QString &linkName)	// 创建文件链接
		bool QFile::remove()						// 删除指定的文件
		bool QFile::rename(const QString &newName)	// 文件重新命名
		void QFile::setFileName(const QString &name)// 设置文件名
		
	⑨静态函数
		[static] bool QFile::copy() 		//拷贝文件	
		// 将fileName转换为由用户的语言环境确定的本地8位编码。 
		[static] QString QFile::decodeName()
		[static] QByteArray QFile::encodeName()
		[static] bool QFile::exists(const QString &fileName)	// 判断文件是否存在
		[static] Permissions QFile::permissions(const QString &fileName) // 返回文件权限
		[static] bool QFile::resize(const QString &fileName, qint64 sz)	 // 设置文件大小		
	10.虚函数	
		[virtual] QString QFile::fileName() const	// 获取文件名
		[virtual] bool QFile::open(OpenMode mode)
			//是从QIODevice :: open（）重新实现。
		  使用OpenMode模式打开文件，如果成功则返回true; 否则是假的。
		  模式必须是QIODevice :: ReadOnly，QIODevice :: WriteOnly或QIODevice :: ReadWrite。 它还可能有其他标志，例如QIODevice :: Text和QIODevice :: Unbuffered。
	11.获取文件大小
		1.对于随机访问设备用size(), // 注意: 设备必须先打开才能获取到正确的值
		2.对于打开的顺序访问设备, 用bytesAvailable()获取文件大小
		注意: 普通文本文件是随机访问设备, /dev/fb等,或者管道文件是顺序设备
▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁
(1)QDir
	①作用:　QDir类提供对目录结构及其内容的访问。
		QDir用于操作路径名，访问有关路径和文件的信息，以及操作底层文件系统。它还可以用于访问Qt的资源系统。
	②概述
		1.目录格式: Qt使用“/”作为通用目录分隔符
			如:	QDir("/home/user/Documents")
				QDir("C:/Documents and Settings")	// 将被转换为C：\ Documents and Settings。
	③功能函数
		1.isRelative(), isAbsolute()检查目录是相对路径还是绝对路径
		2.makeAbsolute()	// 将一个相对路径转换为绝对路径
		3.可以使用path（）函数获取目录的路径，并使用setPath（）函数设置新路径。 通过调用absolutePath（）找到目录的绝对路径。
		4.count（）返回目录中的条目数。 可以使用entryList（）获取目录中所有条目的名称的字符串列表。
		5. 如果需要有关每个条目的信息，请使用entryInfoList（）来获取QFileInfo对象的列表。
		6.可以使用filePath（）和absoluteFilePath（）构建目录中文件和目录的路径。
		7. filePath（）函数返回指向相对于QDir对象路径的指定文件或目录的路径; absoluteFilePath（）返回指定文件或目录的绝对路径。 
		8.可以使用remove（）函数删除文件。rmdir（）来删除目录。
		9.通过将过滤器应用于QDir对象，可以减少entryList（）和entryInfoList（）返回的条目数。 
		10.选择条目属性并可以区分文件和目录的属性过滤器以及排序顺序。
	④	  
	

▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃
						第12章  Qt对象模型
▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃
#####################################################################################################
【一】QT5元对象系统
	1.元对象系统提供了对象间的通信机制（信号和槽）、运行时的类型信息和动态属性系统的支持
	2.Qt元对象系统不支持C++模板
	3.Qt元对象基于以下三个事实：
		(1)基于QObject: 对和对象使用元对象系统功能的类必须继承自QObject
		(2)Q_OBJECT宏:　Q_OBJECT宏必须出现在类的私有声明区，用于启动元对象的特性
		(3)元对象编译器（Meta-Object Compiler, moc）: 为QObject子类实现元对象特性提供了必要的代码支持。
#####################################################################################################
【二】信号和槽机制:
(1)概述
	1.信号和槽用于两个对象之间的通信。
	2.信号和槽机制是QT的核心特征,也是QT不同于其他工具最突出的特征。
	3.槽函数是一个函数,他在信号发射后被滴啊用来响应这个信号。
	4.信号和槽的关联。
		1.一个信号可以和一个槽关联。
		2.多个信号可以关联到一个槽上。
		3.一个信号与多个槽关联(多个槽的执行顺序与关联顺序相同)。
		4.一个信号可以和另外一个信号关联(当信号发射时,导致被关联的信号被发射)。
		5.如果同一个信合和同一个槽函数多次关联, 那么触发信号时, 槽函数会被多次执行
	5.信号和槽的实现
		1.用connect关联的信号和槽被加入到一个队列中
		2.QApplication.exec()运行时,一旦有信号被触发,就会遍历关联了信号和槽的队列。
		3.因为队列中的信号和槽可以重复， 自然一次触发就有可能导致同一个槽函数被调用多次
(2)定义信号
	1.声明一个信号要使用signal关键字。
	2.在 signals 前面不能用public private 和 protected 等限定符，
		因为信号默认是public 函数，可以从任何地方进行发射。
	3.但是建议只在定义该信号的类及其子类中发射该信号 。
	4.信号只用声明 ，不需要也不能对它进行定义实现 。
	5.信号没有返回值. 只能是void类型的。因为只有元对象QObject类及其子类派生的类才能使用信号和槽机制
	6.手动发送一个信号
		emit signal_func(arg...);
(3)槽的类型
	public slots：
		1.在这个区内声明的槽意味着任何对象都可将信号与之相连接。
		2.这对于组件编程非常有用，你可以创建彼此互不了解的对象，将它们的信号与槽进行连接以便信息能够正确的传递。
	protected slots：
		1.在这个区内声明的槽意味着当前类及其子类可以将信号与之相连接。
		2.这适用于那些槽，它们是类实现的一部分，但是其界面接口却面向外部。
	private slots：
		1.在这个区内声明的槽意味着只有类自己可以将信号与之相连接。
		2.这适用于联系非常紧密的类。

	// 声明号槽函数后, 在函数上右击，选择Refactor菜单项,选择“在 mywidget. cpp 添加定义 ”选项 编辑
		器便会转到 mywidget.cpp 文件中，并 且自 动创建 howChildDialog ( ) 槽 的定义 ，
	
(3)注意:
	1.Qt元对象QObject提供了信号和槽的支持, 任何需要使用信号槽机制的对象都必须继承自QObject
	2.要使用信号和槽, 必须在类的私有声明去声明Q_OBJECT宏, 来启动元对象特征。
	3.槽中阐述的类型要和信号参数的类型相对于, 且不能比信号的参数多。
	4.信号函数只用声明， 没有定义， 且返回值必须为void类型。
(4)关联信号槽
	①手动关联
		①SIGNAL和SLOT两个宏的目的是返回函数的字符串
			# define SLOT(a)     qFlagLocation("1"#a QLOCATION)
			# define SIGNAL(a)   qFlagLocation("2"#a QLOCATION)		// 拼接字符串
				const char *qFlagLocation(const char *method);		// 返回函数名字符串
		②关联方式
			// QT4
			QObject::connect(button, Signal(clicked()), this, SLOT(slot_func()));
			
			// QT5
			QLabel *label = new QLabel;
			QLineEdit *lineEdit = new QLineEdit;
			QObject::connect(lineEdit, &QLineEdit::textChanged, label,  &QLabel::setText);
			注意： 如果我们是使用的“转到槽”， 则信号和槽不需要我们手动关联， 系统将自动关联
				// QMetaObject::connectSlotsByName(MainWindow); //在ui_**.h文件中
		③断开关联
			QObject::disconnect	(const QObject *sender, const char *signal,const QObject *receiver, const char *member);
	②自动关联
		1.槽可以重命名为:  由 "on" "发射信号的部件对象名" "信号名"  组成
		 这样就可以去掉 connect ) 关联 函数了 ，		
		2.若需要修改槽函数的名字: 在 showChildDialog上右击，在弹 出的级联菜单中选择refactor->Rename Symbol Under Cursor,	
			再单击 Replace 就可 以了。这时源文件和头文件中相应的函数名都进行了更改。
(5)信号和槽的连接类型
	①Qt::AutoConnection(0)		// 自动连接
		1.这是默认的连接类型
		2.连接类型是在信号发出时确定的
			1.如果接收者与信号发出者是同一线程, 连接类型为Qt::DirectConnection
			2.如果接收者与信号发出者不在同一线程, 连接类型为Qt::QueuedConnection
	②Qt::DirectConnection(1)		// 直接连接
		1.发出信号时, 立即调用槽函数
		2.槽函数是在信号的发送线程中被调用的
		3.只有槽函数执行完成返回后，发射信号处后面的代码才可以执行, 因为(信号函数和槽函数必须在同一线程被调用)
		4.一般用于单线程或者私有信号(QPrivateSignal)的连接
	③Qt::QueuedConnection(2)		// 队列连接
		1.发送信号之后，槽函数不会立刻被调用，等到接收者的当前函数执行完，进入事件循环之后，槽函数才会被调用。
		2.槽函数运行于信号接收者所在线程。
		3.一般用于多线程间的连接
	④Qt::BlockingQueuedConnection(3)	// 阻塞队列连接
		1.槽函数的调用时机与Qt::QueuedConnection一致，不过发送完信号后发送者所在线程会阻塞，直到槽函数运行完。
		2.接收者和发送者绝对不能在一个线程，否则程序会死锁。在多线程间需要同步的场合可能需要这个。
	⑤Qt::UniqueConnection(0x80)	
		1.当这个flag设置时，当某个信号和槽已经连接时，再进行重复的连接就会失败。也就是避免了重复连接。
		2.Qt::UniqueConnection：这个flag可以通过按位或（|）与以上四个结合在一起使用。
(6)私有信号(QPrivateSignal)
	1.QPrivateSignal是一个在Q_OBJECT宏中声明为私有的虚拟（空）结构。
	2.它可以用作信号的最后一个参数。
	3.因为它是私有的，所以只有对象才有权构造QPrivateSignal来调用信号。
	4.私有信号只能用于连接, 不能被用户触发
	5.连接私有信号时只能用Qt::DirectConnection, 所以信号和槽在同一线程中被执行。
	
(7)获取信号的发送者 (多个信号绑定同一个槽时)
	①通过信号函数传参数, 来判断信号的发送者
	②通过sender()函数来获取信号的发送者
		void Widget::slot()
		{	qDebug()<<(this->sender())->objectName();
		}	
################################################################################################################
【三】对象树与拥有权
1.Qt中使用对象树tree来组织和管理所有的 QObject 类及其子类的对象。
2.当创 建一个 QObject 时，如果使用了其他的对象作为其父对象 parent，那么个 QObject 就会被添 加到父对象的 children 列表中
  当父 象被销毁时，这个 QObject也会被销毁 。
  
▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃
				第13章  容器类
▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃


▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃
				第14章  多进程
▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃
【一】QProcess	// 启动外部程序并与它们通信。
(1)概述
		1.QProcess继承于QIODevice
		2.注意: VxWorks，iOS，tvOS，watchOS或通用Windows平台不支持QProcess。
	①启动一个进程的流程
		1.将程序名或命令行传给start()
			1. 程序路径	  运行参数
			2. 命令
		2.或者使用setProgram（）和setArguments（）运行，然后调用start（）或open（）。
		3.void QProcess::kill()杀死一个进程
	②进程可被视为"视为顺序I / O设备"	
		1.可以像使用QTcpSocket访问网络连接一样写入和读取进程。
		2.写入进程的标准输入
			write（）
		3.读出进程的标准输出
			read（），readLine（）和getChar（）
	③QProcess的状态
		QProcess::NotRunning	// 这个进程没有运行
		QProcess::Starting		// 进程已经启动, 但是传入的参数(程序/命令)尚未被调用
		QProcess::Running		// 进程已经启动, 并且可进行读写
		调用state（）来查找当前进程状态。
		
	④信号
		started()
			1.进程中的程序启动时, QProcess进入Running状态并发出started()信号。
			2.这是一个私有信号, 只能连接,不能由用户发出。只能用直接连接。
		finished(int exitCode, QProcess::ExitStatus exitStatus)
			1.当进程退出时，QProcess重新进入NotRunning状态（初始状态），并发出finished()信号。
			2.要连接这个信号必须使用下面的代码
			   QObject::connect(
						myProcess,
						QOverload<int, QProcess::ExitStatus>::of(&QProcess::finished),
				[=](int exitCode, QProcess::ExitStatus exitStatus){qDebug()<<"finished_slots"; });

		readyReadStandardError()					 // 标准输出可写时发出
		readyReadStandardOutput()					 // 标准输入可读时发出
		stateChanged(QProcess::ProcessState newState)// 状态改变时发出该信号
		errorOccurred(QProcess::ProcessError error)	 // 进程运行错误时发出
(2)进程做为IO顺序设备的读写
	①进程的预定义通道
		1.标准输出通道(stdout):		提供控制台输出
		2.标准错误通道（stderr）：	提供进程打印的错误。
	②发出的信号
		1.当前读取通道上的数据可用时，Qprocess会发出readyRead（）信号。
		2.当新的标准输出数据可用时，它还会发出readyReadStandardOutput（）信号。
	③通道相关的API
		closeReadChannel(QProcess::ProcessChannel channel) // 关闭进程的读通道
		closeWriteChannelcloseWriteChannel()			   // 关闭进程的写通道
		inputChannelMode() const						   // 获取输入通道的模式
		processChannelMode() const						   // 返回进程标准输出和标准错误通道
		processEnvironment() const						   // 设置进程的环境变量
		setProcessChannelMode(QProcess::ProcessChannelMode mode) // 改变通道
	④进程通道的模式
		QProcess::SeparateChannels // 默认
			1.QProcess管理正在运行的进程的输出，将标准输出和标准错误数据保存在单独的内部缓冲区中。
			2.您可以通过调用setReadChannel（）来选择QProcess的当前读取通道。
		QProcess::MergedChannels
			1.QProcess将正在运行的进程的输出合并到标准输出通道（stdout）中。
			2.标准错误通道（stderr）不会接收任何数据。 
			3.正在运行的进程的标准输出和标准错误数据是交错的。		
		QProcess::ForwardedChannels	
			1.QProcess将正在运行的进程的输出转发到主进程。 
			2.子进程写入其标准输出和标准错误的任何内容都将写入主进程的标准输出和标准错误。		
		QProcess::ForwardedErrorChannel	
			1.QProcess管理正在运行的进程的标准输出，但将其标准错误转发到主进程。
			2.这反映了命令行工具作为过滤器的典型用法，其中标准输出被重定向到另一个进程或文件，而标准错误被打印到控制台以用于诊断目的。 （这个值是在Qt 5.2中引入的。）		
		QProcess::ForwardedOutputChannel	
			1.ForwardedErrorChannel的补充。 
(3)同步进程的API
	①注意:
		1.允许在没有时间循环的情况下使用, 通过挂起线程直到发出某些信号。
		2.从主线程（调用QApplication :: exec（）的线程）调用这些函数可能会导致用户界面冻结。
	②API
		waitForStarted()		// 阻塞，直到进程开始。
		waitForReadyRead（）	// 阻塞，直到新数据可用于在当前读取通道上读取。
		waitForBytesWritten（） // 阻塞，直到已将一个数据有效负载写入进程。
		waitForFinished（）		// 阻塞，直到进程完成。
	③例子
	
(3)进程退出值和状态	
	1.当进程退出时，QProcess重新进入NotRunning状态（初始状态），并发出finished（）信号。
	2.finished（）信号提供进程的退出代码和退出状态作为参数.
	3.或者调用,调用exitCode（）来获取完成的最后一个进程的退出代码，并使用exitStatus（）来获取其退出状态。
▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁
【二】利用QProcess在cmd窗口中执行命令
	QProcess  *mprocess = new QProcess(this);
	QString ffplaycmd = "ffplay -i rtmp://hdlcontrol.com/live/stream  -fflags nobuffer -flags low_delay  -strict experimental";
    mprocess->start("cmd", QStringList()<<"/c"<<ffplaycmd);
	注意:
		"cmd" "/c" 必须要有, 表示执行ffplaycmd命令后,关闭dos窗口

▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁



################################################################################################################
进程间的通信 // 参考: Inter-Process Communication in Qt文档
TCP/IP
Shared Memory
D-Bus protocol
QProcess Class
Session Management

进程


▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃
				第15章  多线程
▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃
【一】QThread	// QThread类提供了一种独立于平台的管理线程的方法。
(1)概述
	1.QThread的执行方法为run()
	2.默认情况下，run（）通过调用exec（）启动事件循环并在线程内运行Qt事件循环。
	3.可以使用QObject :: moveToThread（）将工作对象移动到线程来使用它们。
(2)管理线程
	①线程启动和停止
		1.当线程started() 和 finished()时会发出信号
		2.查询线程是否在运行
			isFinished() isRunning()
	②线程的停止和终止
		1.线程停止
			exit（）或quit（）
		2.强制终止线程
			terminate() 
		3.通过将finished（）信号连接到QObject :: deleteLater（），可以释放生活在刚刚结束的线程中的对象。
	③等待线程
		使用wait（）来阻塞调用线程，直到另一个线程完成执行（或直到指定的时间已经过去）。
		// 相当于调用pthread_join()函数
	④返回当前线程
		currentThreadId（）	// 返回的当前线程ID(特定平台)
		currentThread（）	// 返回当前线程的QThread指针
	⑤设置线程对象的名字
		1.setObjectName（）
		2.如果不设置, 默认为类名
(3)调度优先级	// enum QThread::Priority
	常量							值			描述
	QThread::IdlePriority 			0		// 仅在没有其他线程正在运行时调度。
	QThread::LowestPriority 		1		// 的调度次数低于LowPriority。
	QThread::LowPriority 			2		// 的调度次数低于NormalPriority。
	QThread::NormalPriority 		3		// 是操作系统的默认优先级。
	QThread::HighPriority 			4		// 比NormalPriority更经常安排。
	QThread::HighestPriority 		5		// 的调度频率高于HighPriority。
	QThread::TimeCriticalPriority 	6		// 尽可能经常安排。
	QThread::InheritPriority 		7		// 使用与创建线程相同的优先级。 这是默认值。


(4)公有函数
	QAbstractEventDispatcher *eventDispatcher() const	// 返回指向线程的事件调度程序对象的指针。 如果该线程不存在事件调度程序，则此函数返回0。
	void exit(int returnCode = 0)			// 线程退出, 并返回退出码
	bool isFinished() const					// 如果线程退出了就返回真
	bool isRunning() const					// 如果线程正在就返回真
	bool isInterruptionRequested() const	// 如果应该停止在此线程上运行的任务，则返回true。 requestInterruption（）可以请求中断。
	int loopLevel() const					// 返回线程的当前事件循环级别。注意：这只能在线程本身内调用，即当它是当前线程时。
	QThread::Priority priority() const 		// 返回正在运行线程的优先级, 如果线程停止了,那么它返回继承的优先级
	void requestInterruption()				// 请求中断线程(但这取决于系统的调度策略)
	void setEventDispatcher(QAbstractEventDispatcher *eventDispatcher)	// 将线程的事件调度程序设置为eventDispatcher。 只有当没有为该线程安装事件调度程序时，才可以执行此操作。
	void setPriority(QThread::Priority priority)	// 设置正在运行线程的优先级, 如果线程没有运行着函数立即返回。
	void setStackSize(uint stackSize)				// 设置线程栈大小
	uint stackSize() const							// 获取线程栈的大小
	bool wait(unsigned long time = ULONG_MAX)		// 阻止线程，直到满足以下任一条件：
		// 与此QThread对象关联的线程已完成执行（即从run（）返回时）。 如果线程已完成，此函数将返回true。 如果线程尚未启动，它也会返回true。
		// 时间毫秒已过。 如果时间是ULONG_MAX（默认值），那么等待将永远不会超时（线程必须从run（）返回）。 如果等待超时，此函数将返回false。
		// 这提供了与POSIX pthread_join（）函数类似的功能。
(5)重新实现的函数
	virtual bool event(QEvent *event) override		// 此虚函数接收事件到对象，如果事件e被识别和处理，则应返回true。
(6)静态函数
	// 使用静态方法创建QThread对象
	// 5.9以上的版本才有create函数
	QThread *create(Function &&f, Args &&... args) // 创建一个新的QThread对象，该对象将使用参数args执行函数f。
	QThread *create(Function &&f)		// 创建一个将执行函数f的新QThread对象。
		1.Args, Function是一个模板类型
	QThread *currentThread()			// 返回指向QThread的指针，该QThread管理当前正在执行的线程。
	Qt::HANDLE currentThreadId()		// 返回当前正在执行的线程的线程句柄。
	int idealThreadCount()				// 能创建线程的最大数
	void msleep(unsigned long msecs)	// 强制线程睡眠msecs毫秒
	void sleep(unsigned long secs)		// 强制线程睡眠secs秒
	void usleep(unsigned long usecs)	// 强制线程睡眠sleep微妙
	const QMetaObject staticMetaObject	// 元对象
	void yieldCurrentThread()			// 如果有的话，将当前线程的执行产生到另一个可运行的线程。 请注意，操作系统决定切换到哪个线程
(7)保护成员
	int exec()			// 运行对象的时间循环，直到关闭对象才会返回
	virtual void run()	// 默认调用QThread的exec()函数
(8)槽
	void quit()	// 告诉线程的事件循环退出并返回代码0（成功）。 相当于调用QThread :: exit（0）。
	void start(QThread::Priority priority = InheritPriority) // 通过调用run（）开始执行该线程。 操作系统将根据优先级参数调度线程。 如果线程已在运行，则此函数不执行任何操作。
	void terminate()	// 终止线程的执行。 根据操作系统的调度策略，线程可能会立即终止也可能不会立即终止。 在terminate（）之后使用QThread :: wait（），以确保。
(9)信号
	void finished()	
		1.该函数在线程退出时发出该信号
		2.该信号在新创建的子线程中发出
		3.这是一个私有信号只能被连接, 不能被用户发出
	void started()		
		1.该信号在执行run函数前发出
		2.该信号在新创建的子线程中发出
		3.这是一个私有信号只能被连接, 不能被用户发出，且连接类型必须为私有连接
(10)函数
	分离线程

#####################################################################################################
【二】QMutex（互斥锁）
①原理和Linux中的互斥量一样
②接口
	QMutex::QMutex(QMutex::RecursionMode mode = NonRecursive)
		1.创建一个处于解锁状态互斥锁
		2.如果mode是QMutex :: Recursive：
			则线程可以多次锁定相同的互斥锁，并且在完成相应数量的unlock（）调用之前，互斥锁将不会被解锁。
		3.如果mode是QMutex :: NonRecursive。
			线程可能只锁定一次互斥锁。
	lock（）// 获取互斥锁， 如果锁已经被锁定， 那么调用线程会柱塞
	unlock（）// 释放互斥锁
	tryLock（） // 尝试获取互斥锁， 如果互斥锁已经被锁定，则立即返回
	tryLock（int timeout = 0）// 如果到了timeout时间还是没有拿到锁就返回
	isRecursive // 如果互斥锁时递归模式则返回真
#####################################################################################################
【二】QReadWriteLock (读写锁)	// 用于线程的同步
递归所定时无法改变锁的类型

	// 实例化读写锁, recursionMode: 是否为递归锁
	QReadWriteLock(QReadWriteLock::RecursionMode recursionMode = NonRecursive)
	lockForRead()		// 以"读模式"锁定互斥锁, 如果另一个线程以写模式锁定,当前线程会阻塞
	lockForWrite()		// 以写模式锁定互斥锁, 如果其他线程以"读模式"或者"写模式"锁定这把锁时, 当前线程会阻塞。
	tryLockForRead()	// 尝试以"读模式"锁定互斥锁, 如果失败立即返回,不会阻塞
	tryLockForWrite()	// 尝试以"写模式"锁定互斥锁, 如果失败立即返回,不会阻塞
	tryLockForRead(int timeout) // 指定等待的时间
	tryLockForWrite(int timeout)// 指定等待的时间
	unlock()			// 解锁"读锁"或者写锁

创建读写锁的模式
QReadWriteLock::Recursive		// 递归模式		: 同一线程只能锁定一次, 直到之前的锁定被解除
QReadWriteLock::NonRecursive	// 非递归模式	: 同一线程能锁定多次
	

#####################################################################################################
【三】QSemaphore (信号量)	// 多用于生产者/消费者模型
(1)概述
	//相当于Linux的Posix无名信号量（用于线程间资源访问的同步于互斥）
	0.典型的应用是"生产者/消费者模型"的环形缓冲区
	1.QSemaphore类提供通用计数的信号量。
	2.信号量是互斥体的推广。
	3.信号量可以多次获取
	4.信号量通常用于保护一定数量共享资源。
	5.信号量支持两个基本操作：
		acquire(int n = 1)			// 尝试获取n个资源, 如果资源数<n, 则调用线程阻塞, 直到条件满足
		release(int n = 1)			// 发布n个资源
		tryAcquire(int n = 1)		// 如果无法获取资源立即返回
		tryAcquire(int n, int timeout) // 如果在timeout时间内,无法获取资源立即返回
		available()					// 返回可用资源的数量
(2)示例
	QSemaphore sem(5);      // sem.available() == 5
	sem.acquire(3);         // sem.available() == 2
	sem.acquire(2);         // sem.available() == 0
	sem.release(5);         // sem.available() == 5
	sem.release(5);         // sem.available() == 10
	sem.tryAcquire(1);      // sem.available() == 9, returns true
	sem.tryAcquire(250);    // sem.available() == 9, returns false
	
(3)使用信号量来模拟环形缓冲区的, 可写资源和可读资源
		#define DATA_SIZE 26        // 要放入环形缓冲区的数据为26个, a-z
		#define RING_BUF_SIZE 5    // 环形缓冲区为10个字节
		static QSemaphore semProductor(RING_BUF_SIZE);   // 生产者的资源(未填充区域, 或者已经被消费者读取过的区域)
		static QSemaphore semCustome(0);   // 消费者的资源(被生产者填充且未被消费者读取的区域)
		static char buf[RING_BUF_SIZE];

		// 消费者
		void work_customer()
		{    for(int i = 0; i < DATA_SIZE; i++) {
				semCustome.acquire();   // 获取可读资源
				qDebug()<<"cus: "<<buf[i % RING_BUF_SIZE];
				QThread::msleep(1000);  // 模拟读取速度
				semProductor.release(); // 发布可写资源
			}
		}
		int main(int argc, char *argv[])
		{
			QThread *custom_thread = QThread::create(work_customer);
			custom_thread->start();
			memset(buf, 0, sizeof(buf));
			char data = 'a';
			// 生产者
			for(int i = 0; i < DATA_SIZE; i++) {
				semProductor.acquire(); // 获取可写资源
				buf[i % RING_BUF_SIZE] = data++;        // 在环形缓冲区循环写入: a-z
				qDebug()<<"pro: "<<buf;
				QThread::msleep(500);  // 模拟写入速度
				semCustome.release();   // 发布可读资源
			}
		}
	
#####################################################################################################
【三】条件变量	// 用于同步线程的条件变量。
(1)概述
	1.是"是生产者/消费者"模型的另一种用法
	2.跟Linux中的条件变量一模一样
	3.条件不会无缘无故地突然变得满足了，必然会牵扯到共享数据的变化。
		所以一定要有互斥锁来保护。
	
(2)原理(和Linux中的一样)
	1.多个线程可以阻塞等待在条件变量上
	2.当某一条件满足时, 可以唤醒在等待在条件变量上的线程。也可以广播所有等待的线程来争抢互斥锁
(3)接口
	QWaitCondition()	// 实例化一个条件变量
	wakeAll() 
		唤醒等待着条件变量上的所有线程(但是只有一个线程能抢到互斥锁)
	wakeOne()
		唤醒在条件变量上阻塞的线程
	notify_all()		// 用于STL兼容性。 它相当于wakeAll（）。
	notify_one()		// 用于STL兼容性。 它相当于wakeOne（）。
	wait(QMutex *lockedMutex, QDeadlineTimer deadline)
	wait(QMutex *lockedMutex, unsigned long time = ULONG_MAX)
		1.lockedMutex是已经上锁的互斥锁， 如果是递归锁立即返回错误
		2.ULONG_MAX是超时时间, 如果为默认值则永远等待。
		3.wait函数会将当前线程挂入等待队列上， 然后解锁互斥锁
		4.返回返回时将从新持有这把互斥锁
	wait(QReadWriteLock *lockedReadWriteLock, QDeadlineTimer deadline)
	wait(QReadWriteLock *lockedReadWriteLock, unsigned long time = ULONG_MAX)
		1.lockedReadWriteLock是已经上锁的读写锁， 如果是递归锁立即返回错误
		2.ULONG_MAX是超时时间, 如果为默认值则永远等待。
		3.wait函数会将当前线程挂入等待队列上， 然后解锁读写锁
(1)用条件变量实现环形缓冲区
	1.生产者和消费者可同时操作环形缓冲区的不同位置
	2.用条件变量来模拟: 缓冲区可写入条件,  缓冲区可读取条件
	3.用互斥量来维护共享数据"缓冲区可读字节数/缓冲区可写字节数"
		#define DATA_SIZE 26        // 要放入环形缓冲区的数据为26个, a-z
		#define RING_BUF_SIZE 5     // 环形缓冲区为10个字节
		static char buf[RING_BUF_SIZE]; // 环形缓冲区
		static int readyableBytes = 0;  // 可读取的字节数
		static QWaitCondition condReadyable;    // 条件变量: 缓冲区可读取
		static QWaitCondition condWriteable;    // 条件变量: 缓冲区可写入
		static QMutex mutex;                    // 互斥量: 保护readyableBytes

		// 消费者
		void work_customer()
		{
			for(int i = 0; i < DATA_SIZE; i++) {
				mutex.lock();
				if (readyableBytes == 0)        // 缓冲区中没有数据可读
					condReadyable.wait(&mutex); // 等待生产者写入新数据后唤醒
				mutex.unlock(); // 环形缓冲区的写入和读取在不同区域, 为了读写能同时进行故不加锁

				qDebug()<<"cus: "<<buf[i % RING_BUF_SIZE];
				QThread::msleep(1000);  // 模拟读取速度

				mutex.lock();
				readyableBytes--;       // 可读数据-1
				condWriteable.wakeAll();// 唤醒阻塞的写入线程
				mutex.unlock();
			}
		}

		int main(int argc, char *argv[])
		{
			QCoreApplication a(argc, argv);
			QThread *custom_thread = QThread::create(work_customer);
			custom_thread->start();
			memset(buf, 0, sizeof(buf));
			char data = 'a';
			// 生产者
			for(int i = 0; i < DATA_SIZE; i++) {

				mutex.lock();
				if (readyableBytes == RING_BUF_SIZE)    // 缓冲区中一个数据都没被读取, 这时不可再写入
					condWriteable.wait(&mutex);         // 等待缓冲区可写时唤醒

				mutex.unlock(); // 环形缓冲区的写入和读取在不同区域, 为了读写能同时进行故不加锁
				buf[i % RING_BUF_SIZE] = data++;        // 在环形缓冲区循环写入: a-z
				qDebug()<<"pro: "<<buf;
				QThread::msleep(500);  // 模拟写入速度

				mutex.lock();
				readyableBytes++;           // 可读字节数+1
				condReadyable.wakeAll();    // 唤醒阻塞的读取线程
				mutex.unlock();
			}
		}
#####################################################################################################
【三】QRunnable (线程池中的可运行对象)	
(1)概述
	1.QRunnable类是一个接口，用于表示需要执行的任务或代码段
	2.需要重新实现run函数, run函数中填充要执行的任务或代码段
(2)任务的删除
	autoDelete()	// 
		1.如果返回真(默认), 任务被执行完后，QThreadPool会自动删除QRunnable。
	setAutoDelete（）更改自动删除标志。
#####################################################################################################
【三】QThreadPool(线程池)
(1)概述
	每个Qt应用程序都有一个全局QThreadPool对象，通过调用QThreadPool::globalInstance（）来访问它。
	// QThreadPool *poll = QThreadPool::globalInstance()
(2)任务的创建和投递
	①任务的创建
		1.继承QRunnable并实现run（）虚函数, run函数中时即将执行的任务。
		2.然后创建该类的对象并将其传递给QThreadPool::star（Runnable *）。
	②示例
		class HelloWorldTask : public QRunnable
		{   void run() override
		  { qDebug() << "Hello world from thread" << QThread::currentThread();
		  }
		};
		HelloWorldTask *hello = new HelloWorldTask();
		QThreadPool::globalInstance()->start(hello);
(3)任务的自动删除与不自动删除		
	1.QThreadPool执行任务QRunnable后, 默认自动删除QRunnable。
	2.使用QRunnable :: setAutoDelete（）更改自动删除标志。
	3.QThreadPool支持通过从QRunnable :: run（）中调用tryStart（this）多次执行相同的QRunnable。
		如果启用了autoDelete，则当最后一个线程退出运行功能时，将删除QRunnable。	
	4.启用autoDelete时，使用相同的QRunnable多次调用start（）会创建竞争条件，不建议这样做。	
(4)线程的超期
		expiryTimeout() const				// 获取线程超期时间
		setExpiryTimeout(int expiryTimeout)	// 设置线程超期时间
	1.线程的超期时间默认为expiryTimeout(30ms), 如果在默认超期时间内线程未被使用, 线程将退出。且将根据需要重新启动。
	2.如果expiryTimeout为负，则新创建的线程将不会过期。在线程池被销毁之前它们不会退出。
	3.注意: 
		1.设置expiryTimeout对已经运行的线程没有影响。只有新创建的线程才会使用新的expiryTimeout。
		2.建议在创建线程池之后立即设置expiryTimeout，但在调用start（）之前。	
(5)供外部使用的线程
	1.reserveThread（）函数保留一个供外部使用的线程。
	2.完成线程后使用releaseThread（），以便可以系统重用它。
(6)公有函数
	QThreadPool(QObject *parent = nullptr)	// 管理一个QThread集合。
	activeThreadCount() const				// 线程池中活动线程的数量。
	clear()									// 删除尚未从队列中启动的runnable。 runnable-> autoDelete（）返回true的runnables将被删除。
	maxThreadCount() const					// 线程池中能够使用的最大线程数, 
	setMaxThreadCount(int maxThreadCount)	// 即使maxThreadCount限制为零或为负，线程池也将始终使用至少1个线程。
	reserveThread()				// 创建一个活动线程
	releaseThread()				// 释放以前通过调用reserveThread()创建的线程。 
	setStackSize(uint stackSize)// 线程池工作线程的堆栈大小。仅在线程池创建新线程时使用该属性的值。 更改它对已创建或正在运行的线程没有影响。
	stackSize() const
	start(QRunnable *runnable, int priority = 0)
		1.创建一个线程来运行Runnable。
		2.当线程数超过maxThreadCount时, Runnable被挂入运行队列。
		3.priority参数可用于控制运行队列的执行顺序。
		4.如果runnable-> autoDelete（）返回true，则线程池将获取runnable的所有权，并且runnable-> run（）返回后，线程池将自动删除runnable。
		5.如果runnable-> autoDelete（）返回false，则runnable的所有权将保留在调用者处。
	tryStart(QRunnable *runnable)
		1.如果在调用时没有可用的线程，则此函数不执行任何操作并返回false。
		2.否则，使用一个可用线程立即运行runnable，此函数返回true。
		3.如果runnable-> autoDelete（）返回true，则线程池将获取runnable的所有权，并且runnable-> run（）返回后，线程池将自动删除runnable。 
		4.如果runnable-> autoDelete（）返回false，则runnable的所有权将保留在调用者处。 
	tryTake(QRunnable *runnable)
		1.尝试从队列中删除指定的runnable（如果尚未启动）。
		2. 如果runnable尚未启动，则返回true，并将runnable的所有权转移给调用者（即使runnable-> autoDelete（）== true）。 否则返回false。
	waitForDone(int msecs = -1)
		1.等待所有线程退出的最多msecs毫秒，并从线程池中删除所有线程。 如果删除了所有线程，则返回true; 否则返回false。 
		2.如果msecs为-1（默认值），则忽略超时（等待最后一个线程退出）。

(7)静态函数
	QThreadPool *globalInstance()		// 返回全局的QThreadPool实例(当前线程所在的线程池)
	const QMetaObject staticMetaObject  // 元对象
	
▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃
							第18章  TCP网络编程
▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃
QNetworkSession		// 在多个客户端访问同一访问点时进行会话管理。
(1)QNetworkSession可以控制系统的网络接口。
	1.会话的配置参数是通过它绑定的QNetworkConfiguration对象确定的。
	2.根据会话的类型（单个接入点或服务网络），会话可以链接到一个或多个网络接口。
	3.通过打开和关闭网络会话，开发人员可以启动和停止系统网络接口。
	4.如果配置代表多个接入点（请参阅QNetworkConfiguration :: ServiceNetwork），则可能支持更多高级功能，例如漫游。
QNetworkSession支持同一进程内的会话管理，并且根据平台的功能可能支持进程外会话。
	1.如果多个打开会话使用相同的网络配置，则只有在最后一个会话关闭后才终止底层网络接口。
▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁	
QHostAddress	// 此类以独立于平台和协议的方式保存IPv4或IPv6地址。
(1)概述
	QHostAddress通常与QTcpSocket，QTcpServer和QUdpSocket一起使用，以连接到主机或设置服务器。
	主机地址使用setAddress（）设置，并使用toIPv4Address（），toIPv6Address（）或toString（）进行检索。 您可以使用protocol（）检查类型。
	
(2)枚举类型
	QHostAddress::StrictConversion	
	QHostAddress::ConvertV4MappedToIPv4
	QHostAddress::ConvertV4CompatToIPv4
	QHostAddress::ConvertLocalHost
	QHostAddress::ConvertUnspecifiedAddress
	QHostAddress::TolerantConversion
	Sets all three preceding flags.
▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁	
QHostInfo	// 为查找主机名提供静态函数
void abortHostLookup(int id)			// 终止查找id为id的主机名
QHostInfo fromName(const QString &name) // 根据主机名查找QHostInfo
QString localDomainName()				// 返回计算机的主机域名	
QString localHostName()					// 返回计算机的主机名
	请注意，主机名不能保证全局唯一，特别是如果它们是自动配置的。
int lookupHost(...)						// 查找主机信息
▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁	
QNetworkAddressEntry // QNetworkAddressEntry类存储网络接口支持的一个IP地址，以及其关联的网络掩码和广播地址。
每个网络接口可以包含零个或多个IP地址，这些IP地址又可以与网络掩码和/或广播地址相关联（取决于操作系统的支持）。
这个类代表一个这样的组。
▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁	
QNetworkInterface	// 提供主机的IP地址和网络接口的列表。
(1)概述:
	1.每个网络接口可以包含零个或多个IP地址，每个IP地址可选地与网络掩码和/或广播地址相关联。
	2.可以使用addressEntries（）获得此类三元组的列表。 
	3.当不需要网络掩码或广播地址时，使用allAddresses（）便利功能仅获取IP地址。
	4.QNetworkInterface还使用hardwareAddress（）报告接口的硬件地址。
	注意: 并非所有操作系统都支持报告所有功能。 在所有平台中，只保证此类列出IPv4地址。
		特别是，IPv6地址列表仅在Windows，Linux，macOS和BSD上受支持。
(2)静态函数
	QList<QHostAddress> allAddresses()		 		// 返回主机上的所有IP地址
	QList<QNetworkInterface> allInterfaces() 		// 返回在主机上发现的所有网络接口
	QNetworkInterface interfaceFromIndex(int index) // 返回内部ID为index的接口的QNetworkInterface对象。
		// 注意:接口被删除然后再次添加，每次都会获得不同的值。
	QNetworkInterface interfaceFromName(const QString &name)　// 根据主机名获取QNetworkInterface对象
	int interfaceIndexFromName(const QString &name) // 根据主机名获取网络接口的索引值
		// 相当于QNetworkInterface::interfaceFromName(name).index()
	QString interfaceNameFromIndex(int index)// 根据index返回主机名
(3)获取网卡名称和网卡的mac地址
    QList<QNetworkInterface> nets = QNetworkInterface::allInterfaces();// 获取所有网络接口列表
    int nCnt = nets.count();
    qDebug()<<nCnt;
    QString mac, name;
    for(int i = 0; i < nCnt; i ++)
    {
       qDebug()<<"name: "<<nets.at(i).name();
       qDebug()<<"mac: "<<nets.at(i).hardwareAddress();
       // 如果此网络接口被激活并且正在运行并且不是回环地址，则就是我们需要找的Mac地址
       if(nets.at(i).flags().testFlag(QNetworkInterface::IsUp) && nets.at(i).flags().testFlag(QNetworkInterface::IsRunning)
               && !nets.at(i).flags().testFlag(QNetworkInterface::IsLoopBack))
       {
           name =nets.at(i).name();
           mac = nets.at(i).hardwareAddress();
       }
    }


		
▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁	
【一】QAbstractSocket 	// 提供所有套接字类型共有的基本功能。
(1)概述
	1.QAbstractSocket是QTcpSocket和QUdpSocket的基类，包含这两个类的所有常用功能。
	2.QAbstractSocket的API统一了TCP/UDP之间的大部分差异。
		1.尽管UDP是无连接的，但connectToHost（）为UDP套接字建立了虚拟连接
	3.无论基础协议如何，都可以使用大致相同的方式。
	4.获取客户端端口和地址
		在内部，QAbstractSocket记住传递给connectToHost（）的地址和端口，而read（）和write（）等函数使用这些值。	
	5.使用套接字的方法
		方法一: 实例化QTcpSocket或QUdpSocket。
		方法二: 创建本机套接字描述符，实例化QAbstractSocket，并调用setSocketDescriptor（）来包装本机套接字。
(2)状态改变和信号
	1)QAbstractSocket在任何时候都有一个状态（由state（）返回）。
	2)初始状态为UnconnectedState。
	3)在调用connectToHost（）之后，套接字首先进入HostLookupState。
		1.如果找到主机，QAbstractSocket将进入ConnectingState并发出hostFound（）信号。
		2.注意: connectToHost是一个非阻塞函数。
	4)建立连接后，它将进入ConnectedState状态并发出connected（）信号。
	5)每当状态改变时，都会发出stateChanged（）信号。
	5)如果在任何阶段发生错误，则发出error（）信号。
	//为方便起见，如果套接字已准备好进行读写，则isValid（）返回true，但请注意，在读取和写入之前，套接字的状态必须为ConnectedState。	
(3)QAbstractSocket的读写
	①读
		1.通过调用read、readLine、和readAll，从QIODevice继承了getChar，putChar和ungetChar，它们处理单个字节。
		2.套接字可读时将发出发出readyRead信号	//（通常，您可以将readyRead（）信号连接到插槽并读取其中的所有可用数据。）
		3.bytesAvailable（）然后返回可供读取的字节数。
		4.如果读缓存区的数据未被一次读完, 那么新数据将追加到缓存区后面。
		5.调用setReadBufferSize（）。来设置读缓存区的大小。
	②写
		1.调用write来写入数据
		2.将数据写入套接字时会发出bytesWritten（）信号。
		3.请注意，Qt不限制写缓冲区大小。您可以通过收听此信号来监控其大小。	
(4)关闭套接字disconnectFromHost（）// 尝试关闭套接字
		套接字被关闭的步骤
		1.套接字首先进入QAbstractSocket :: ClosingState状态。
		2.随后缓冲区中的数据将被写入套接字。
		3.关闭套接字， 进入QAbstractSocket :: UnconnectedState状态。
		4.发出disconnected（）信号
	在将所有挂起数据写入套接字后，QAbstractSocket实际上关闭套接字，进入，并发出。
	如果要立即中止连接，丢弃所有待处理数据，请调用abort（）。
(5)获取端口和主机信息
	peerPort（）		// 获取连接对方的端口
	peerAddress（）		// 获取连接对方的地址
	peerName（）		// 获取连接对方的主机名
	localPort（）		// 获取本机使用的端口
	localAddress（）	// 获取本机使用的地址
(5)以下函数使调用线程被挂起, 直到相应的信号被触发。
	waitForConnected() 		// 阻塞, 直到连接建立
	waitForReadyRead()		// 阻塞, 直到有新数据可读
	waitForBytesWritten() 	// 阻塞, 直到套接字中已经写入了数据
	waitForDisconnected() 	// 阻塞, 直到套接字关闭
	1.注意: 阻塞套接字仅能在非GUI线程中使用, 否则界面在阻塞过程中会卡死
(6)QAbstractSocket可以与QTextStream和QDataStream的流运算符（运算符<<（）和运算符>>（））一起使用。
	但是有一个问题需要注意：在尝试使用operator >>（）读取之前，必须确保有足够的数据可用。

▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁	
【二】QTcpSocket:	// QTcpSocket类提供TCP客户端套接字。
(1)概述
	1.注意:
		TCP套接字不能用QIODevice::Unbuffered mode模式打开(因为该模式会绕过所有缓冲区)
		
▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁	
【三】QTcpServer	// 该类提供了TCP服务端的套接字
①概述
	1.QTcpServer可以监听指定的地址和端口, 或者监听所有的网络地址
	2.每次新连接都会触发newConnection()信号
	3.调用nextPendingConnection（）以将挂起的连接作为连接的QTcpSocket接受。	   
	  该函数返回一个指向QAbstractSocket :: ConnectedState中QTcpSocket的指针，使用该指针与客户端进行通信。
	4.当监听的地址和端口连接时, 可以用serverAddress（）和serverPort（）。获取对方的地址和端口
	5.调用close()会使QTcpServer停止侦听传入的连接。
②监听
	QTcpServer::listen(const QHostAddress &address = QHostAddress::Any, quint16 port = 0) // 监听
	1.如果port==0, 套接字监听address上的所有端口
	2.如果address==QHostAddress::Any, 套接字将监听所有网络地址
	3.注意:
		1.listen函数不是一个阻塞函数。
		2.当监听的的地址和端口被连接时，将发出newConnection()信号。
③接受连接
	QTcpServer::nextPendingConnection()
	1.接受挂起的连接, 并返回一个QTcpSocket对象
	2.用返回的QTcpSocket对象和已经建立连接的客户端进行通信。
④读写
	QTcpSocket继承于QIODevice, 写入数据或者数据可读时会发出相应的信号。
		// void readyRead()

▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁	
【四】TCP双向通信流程
①分析: 
	因为Qt的可读写状态是由信号触发的,而不是阻塞的,	,
		==>所以服务器与客户端双向通信仅需单线程就OK。
②服务端流程	
	tcpserver = new QTcpServer(this);			// 创建TCP服务端套接字
	tcpserver->listen(QHostAddress::Any, 5000); // 监听, 不是一个阻塞函数

	// 有新连接时套接字发出newConnection信号
	QObject::connect(tcpserver, &QTcpServer::newConnection, this, &Widget::accept_connect);
	
	// 成功连接后, 如果套接字可读将发出readyRead信号, 我们在槽函数中读取数据
	void Widget::accept_connect()
	{	tcpsocket = tcpserver->nextPendingConnection();		// tcpsocket用于与新连接的客户端进行通信
		QObject::connect(tcpsocket, &QTcpSocket::readyRead, this, &Widget::read_slot);
	}
	// 读取数据
	void Widget::read_slot()
	{	ui->textBrowser->append(QString::fromUtf8(tcpsocket->readAll()));
	}
	// 发送数据
	void Widget::on_pushButton_clicked()
	{	tcpsocket->write(ui->lineEdit->text().toUtf8());
	}
③客户端流程
	// 创建套接字
    tcpsocket = new QTcpSocket(this);
	// 连接到主机
    tcpsocket->connectToHost(QString("192.168.1.111"), 5000);
	// 连接成功好发出connected信号
    QObject::connect(tcpsocket, &QTcpSocket::connected, this, &Widget::connect_ok_slot);
	// 数据可读后发出readyRead信号
	void Widget::connect_ok_slot()
	{	QObject::connect(this->tcpsocket, &QTcpSocket::readyRead, this, &Widget::read_slots);
	}
	// 读数据
	void Widget::read_slots()
	{    ui->textBrowser->append(QString::fromUtf8(tcpsocket->readAll()));
	}
	// 发送数据
	void Widget::on_btSend_clicked()
	{  tcpsocket->write(ui->lineEdit->text().toUtf8());
	}
▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃
							第19章  UDP网络通信
▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃
【一】QNetworkDatagram 	// 提供UDP数据报和元对象
①概述
	1.QNetworkDatagram通常与QUdpSocket一起使用
	2.QNetworkDatagram包含以下内容
		1.数据报内容
		2.发送地址及端口号
		3.目的地址和端口号
		4.剩余的跳数限制（在IPv4上，此字段通常称为“生存时间” -  TTL）;
		5.接收或发送数据报的网络接口索引。
	3.QNetworkDatagram 并不支持所有的平台，比如IOS
②注意：但平台无法支持QNetworkDatagram时， 构建的数据报会被丢弃
	1.senderAddress（）和senderPort（）包含发送者的信息
	2.destinationAddress（）和destinationPort（）包含接收者信息，这通常是当前机器本地的地址，但它也可以是IPv4广播地址（例如“255.255.255.255”）或IPv4或IPv6多播地址

▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁	
【二】QUdpSocket:	// QTcpSocket类提供TCP套接字。
(1)概述
	1.QUdpSocket是QAbstractSocket的子类，
	2.可以使用QUdpSocket来进行数据报的发送和接受。
	3.注意: 如果QUdpSocket收到readyRead信号时, 应该立即读出传入的数据包, 否则下一个数据报到来时, 套接字将不会发出QUdpSocket信号
(2)数据报的读写
	服务端:
		1.创建QUdpSocket
		2.调用writeDatagram()函数写
	客户端
		1.创建QUdpSocket
		2.bind本地主机地址
		3.连接readyRead信号（当数据报到达时，该信号会被触发）
		4.调用pendingDatagramSize（）来确定挂起的第一个数据报的大小
		5.调用readDatagram或者receiveDatagram来读取数据报
(3)QUdpSocket广播
	// 发送端
	//  QHostAddress::Broadcast == 255.255.255.255	或者192.168.1.255(示例)
	udpSocket->writeDatagram(datagram.data(), datagram.size(), 广播地址, 45454);
	// 接收端
	udpSocket->bind(45454, QUdpSocket::ShareAddress);// mac上必须绑定广播地址, window平台上可以绑定本机地址
	connect(udpSocket, SIGNAL(readyRead()),	this, SLOT(processPendingDatagrams()));
(4)QUdpSocket组播
	// 发送者
	groupAddress = QHostAddress("224.0.0.100");		// D类地址
	udpSocket->writeDatagram(datagram.data(), datagram.size(),
                               groupAddress, 45454);
	// 接收者
	groupAddress = QHostAddress("239.255.43.21");
	udpSocket = new QUdpSocket(this);
	udpSocket->bind(QHostAddress::AnyIPv4, 45454, QUdpSocket::ShareAddress);
	udpSocket->joinMulticastGroup(groupAddress);
	connect(udpSocket, SIGNAL(readyRead()),	this, SLOT(read_PendingDatagrams()));
	void read_PendingDatagrams()	// 读数据报	
	{
		qint64 size = socket->pendingDatagramSize();
		char buf[size+1];
		memset(buf, 0, sizeof(buf));
		socket->readDatagram(buf, size);
		buf[size] = '\0';
		qDebug()<<buf;
		ui->textBrowser->append(QString(buf));
	}
	
(5)QUdpSocket的读写函数
	qint64 QUdpSocket::readDatagram(char *data, qint64 maxSize, QHostAddress *address = Q_NULLPTR, quint16 *port = Q_NULLPTR)
		1.从挂起的数据包中读取maxSize字节,存放到data中。发送者的信息存储在address和port中。
		2.如果maxSize太小, 数据报的剩余部分将会丢失。
		3.避免丢失数据，在调用readDatagram之前，应该先调用pendingDatagramSize()来获取挂起的数据报的大小。
		4.如果maxSize==0，那么当前挂起的数据报将被丢弃。
	qint64 QUdpSocket::writeDatagram(const char *data, qint64 size, const QHostAddress &address, quint16 port)
		1.发送大小为size的data数据到address地址的port端口上
		2.警告：
			1.通常不会发送大于512字节的数据报
			2.如果使用连接的套接字，请使用write（）发送数据报。否则会出错。
	QNetworkDatagram QUdpSocket::receiveDatagram(qint64 maxSize = -1)
		1.接收不大于maxSize字节的数据报，并将其与QNetworkDatagram对象一起返回，以及发送方的主机地址和端口。
		2.如果可能，此功能还将尝试确定数据报的目标地址，端口和接收时的跳数。
		3.失败时，返回报告无效的QNetworkDatagram。
		4.如果maxSize太小，则数据报的其余部分将丢失。 
		5.如果maxSize为0，则丢弃数据报。
		6.如果maxSize为-1（默认值），则此函数将尝试读取整个数据报。

▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃
							第20章  Http网络通信（Qt使用以下3个类来管理Http通信）
▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃
【一】简介:
①Linux,http服务器搭建(apache2)。
	1.sudo apt-get install apache2
	2.修改/etc/network/interfaces为:
		auto lo
		iface lo inet loopback
	3.重启网络管理
		sudo service network-manager restart
	4.编辑新静态网络连接(示例)
		address: 192.168.1.107
		netmask: 255.255.255.0
		gateway: 192.168.1.1
		DNS domains: 192.168.1.1
	5.sudo apt-get update
	6.sudo apt-get install apache2
	安装好后会生成/var/www目录, 这就是http的根目录
②测试http服务器
	1.在/var/www/目录下新建一个文件list
	2.在浏览器中输入192.168.1.107/list看是否能访问到list中的文本, 如果能够访问到就说明服务器是OK的
③http协议简介
	// https://www.cnblogs.com/ranyonsue/p/5984001.html
	1.HTTP协议是超文本传输协议,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。
	2.HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。
		一次请求得到回复后,服务器随即断开连接。
	3.HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展。目前在WWW中使用的是HTTP/1.0的第六版，HTTP/1.1的规范化工作正在进行之中，而且HTTP-NG(Next Generation of HTTP)的建议已经提出。
	4.HTTP协议工作于客户端-服务端架构为上。
	5.浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。
▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁	
【二】Http天气预报
(1)天气api
	①获取到JSON字符串
		1.通过城市名字获得天气数据，json数据
			http://wthrcdn.etouch.cn/weather_mini?city=北京
		2.通过城市id获得天气数据，json数据
			http://wthrcdn.etouch.cn/weather_mini?citykey=101010100
	②获取到XML字符串
		1.通过城市名字获得天气数据，xml文件数据
			http://wthrcdn.etouch.cn/WeatherApi?citykey=101010100
		2.通过城市id获得天气数据，xml文件数据,
			http://wthrcdn.etouch.cn/WeatherApi?city=北京
		原文地址http://blog.csdn.net/wyb112233/article/details/49535049	
		
▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁	
【三】QNetworkAccessManager	
(1)概述
	①.QNetworkAccessManager类允许应用程序发送网络请求并接收回复
	②.网络访问API由QNetworkAccessManager对象构建
		1.它包含其发送的请求的通用配置和设置。
		2.它包含代理和缓存配置，以及与此类问题相关的信号，以及可用于监控网络操作进度的回复信号。
		3.一个QNetworkAccessManager足以用于整个Qt应用程序。
		
	③一旦创建了QNetworkAccessManager对象，应用程序就可以使用它通过网络发送请求。 
		1.它提供了一组标准函数，它们接收请求和可选数据，每个函数都返回一个QNetworkReply对象。 
		2.返回的对象用于获取响应相应请求而返回的所有数据。

(2)HTTP请求方法
	①概述
		根据HTTP标准，HTTP请求可以使用多种请求方法。
		HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。
		HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法	
	②请求方法
		//方法		// 描述
		GET			请求指定的页面信息，并返回实体主体。
		HEAD		类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头
		POST		向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。
		PUT			从客户端向服务器传送的数据取代指定的文档的内容。
		DELETE		请求服务器删除指定的页面。
		CONNECT		HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。
		OPTIONS		允许客户端查看服务器的性能。
		TRACE		回显服务器收到的请求，主要用于测试或诊断。
	③接口
		QNetworkReply *QNetworkAccessManager::get(const QNetworkRequest &request)
			1.发布获取目标请求内容的请求
			2.当服务器回复完成时,QNetworkAccessManager将发出finished(QNetworkReply*)信号, QNetworkReply中包含回复的所有数据
		QNetworkReply *QNetworkAccessManager::head(const QNetworkRequest &request)
			1.发布获取请求的网络标头的请求
			2.当服务器回复完成时,QNetworkAccessManager将发出finished(QNetworkReply*)信号, QNetworkReply中包含回复的所有数据
		QNetworkReply *QNetworkAccessManager::post(const QNetworkRequest &request, const QByteArray &data)
			1.将数据字节数组的内容发送到请求指定的目标。
			2.当服务器回复完成时,QNetworkAccessManager将发出finished(QNetworkReply*)信号, QNetworkReply中包含回复的所有数据
		..........
	④Qt HTTP POST json 访问服务器
		[1]form格式
			QByteArray postArray;
			// 示例json串
			postArray.append("grant_type=authorization_code");	
			postArray.append("&client_id=32u2w95f200D4d27");

			QNetworkRequest request(QUrl("http://kk.bigk2.com:8080/KOAuthDemeter/accessToken"));
			request.setHeader(QNetworkRequest::ContentTypeHeader,"application/x-www-form-urlencoded");
			request.setHeader(QNetworkRequest::ContentLengthHeader,postArray.size());
			manager->post(request,postArray);

		[2]json格式
			QUrl url("http://kk.bigk2.com:8080/KOAuthDemeter/User/getKSceneList");
			QByteArray array("{\"userid\":\"1538822184@qq.com\"}");
			QNetworkRequest request(url);
			request.setHeader(QNetworkRequest::ContentTypeHeader,QVariant("application/json"));
			request.setRawHeader("Authorization","Bearer 49152bfddae0c5b5d492d3d9871f8c11");//服务器要求的数据头部
			manager->post(request,array);
	
	
(4)使用示例(获取天气的json串)
	manager = new QNetworkAccessManager(this);					// 初始化一个QNetworkAccessManager来管理客户端
		 // 请求回复完成后QNetworkAccessManager将发出finished(QNetworkReply *reply)信号
	QObject::connect(manager, &QNetworkAccessManager::finished, this, &Widget::reply_finished_slot);
	void Widget::on_pushButton_clicked()		// 请求
	{
		manager->get(QNetworkRequest(QUrl(ui->lineEdit->text())));
	} 
	void Widget::reply_finished_slot(QNetworkReply *reply)		// 回复完成,读取数据
	{	ui->textBrowser->append(QString::fromUtf8(reply->readAll()));
	}
	
▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁	
	
【一】QNetworkRequest			// 客户端请求对象
(1)概述
	1.QNetworkRequest用于给QNetworkAccessManager的get函数提供一个http请求。
	2.QNetworkRequest是Network Access API的一部分，是通过网络发送请求所必需的信息的类。
		它包含一个URL和一些可用于修改请求的辅助信息。
	
▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁	
【二】QNetworkReply 			// 应答对象(服务端)
	1.QNetworkReply类包含使用QNetworkAccessManager发送的请求的数据和标头
	2.QNetworkAccessManager::finished(QNetworkReply*)信号中的QNetworkReply参数包含回复的所有数据和元对象
	3.当QNetworkReply中数据可读时将发出readyRead信号(继承自QIODevice)



▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁	
【四】HTTP通信例子（获取自己搭建的apache2服务器数据）
看： http服务器搭建笔记
1.实现动态动态获取图片列表，并显示出来
2.app远程自动更新
3.手动点击检查更新

▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃
							第21章  Qt Json
▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃
QJsonValue		// QJsonValue是JSON对象封装的一个值。
	JSON是一种存储结构化数据的格式。
(1)JSON中的键值类型,是6种基本类型之一：
	QJsonValue::Null		空值
	QJsonValue::Bool	 	bool类型, 
	QJsonValue::Double	 	Double类型, 
	QJsonValue::String 		字符类型, 
	QJsonValue::Array		JSON数组, 
	QJsonValue::Object		JSON对象, 
	QJsonValue::Undefined	这个值未定义,
(2)验证QJsonValue的类型
	bool isArray() const
	bool isBool() const
	bool isDouble() const
	bool isNull() const
	bool isObject() const
	bool isString() const
	bool isUndefined() const
(3)转换QJsonValue为JSON类型和基本类型(用于嵌套剥离)
	QJsonObject toObject() const	
	QJsonArray  toArray() const
	QVariant 	toVariant() const
	double 		toDouble(double defaultValue = 0) const
	QString 	toString() const
	bool 		toBool(bool defaultValue = false) const
▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁	
【一】QJsonObject		// QJsonObject类封装了一个JSON对象。
①概述
	1.JSON对象是键值对的列表(之间通过逗号分开)，其中键(key)是唯一字符串，值(value)由QJsonValue表示, 一般有6种基本类型。
	2.可以将QJsonObject转换为QVariantMap和从QVariantMap转换。
	3.您可以使用size（），insert（）和remove（）条目查询（键，值）对的数量，并使用标准C ++迭代器模式迭代其内容。
	4.QJsonObject是一个隐式共享类，只要它没有被修改，就会与创建它的文档共享数据。
	5.您可以通过QJsonDocument将对象转换为基于文本的JSON。
②常见操作
	1.该json对象最外层键值对的个数
		QJsonObject::size()	
	2.插入JSON对象
		obj2.insert("k1", QJsonValue("123"));
	3.删除JSON对象
		obj.remove("key1");
	4.查找json对象
		iterator find(const QString &key);
	6.判断对象中是否存在某个键值对
		bool contains(const QString &key) const

④嵌套查找json对象列表
   QJsonArray jsarry;
   QJsonObject obj,obj1, obj2, obj3, obj4;
   obj1.insert("k1", "11");
   obj2.insert("k2", "22");
   obj3.insert("k3", "33");
   obj3.insert("obj1", obj1);
   obj3.insert("obj2", obj2);
   jsarry.append(obj1);
   jsarry.append(obj2);
   jsarry.append(obj3);

   obj.insert("a1", jsarry);
   obj.insert("a2", obj1);
   obj.insert("a3", obj2);
   obj.insert("a4", obj3);
   // 嵌套查找json对象
   qDebug()<<obj.value("a4").toObject().value("obj2").toObject().value("k2").toString(); //"22"
   // 查找json数组
   QJsonArray arry = obj.value("a1").toArray();
    qDebug()<<arry.at(0).toObject().value("k1").toString(); //11
    qDebug()<<arry.at(1).toObject().value("k2").toString(); //22
    qDebug()<<arry.at(2).toObject().value("k3").toString(); //33


▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁	
【二】QJsonArray
①概述
	1.QJsonArray类封装了一个JSON数组。
	2.JSON数组是值列表。 可以通过从数组中插入和删除QJsonValue来操作列表。
	3.QJsonArray可以与QVariantList进行转换。 
	4.您可以使用标准C ++迭代器模式查询具有size（），insert（）和removeAt（）条目的条目数，并迭代其内容。
	5.QJsonArray是一个隐式共享类，只要它没有被修改，就会与创建它的文档共享数据。
	6.可以通过QJsonDocument将数组转换为基于文本的JSON。
②遍历JSON数组
   QJsonArray jsarry;
   jsarry.append(obj1);
   jsarry.append(obj2);
   for (int i=0; i<jsarry.size(); i++)
        QJsonValue val = jsarry.at(i);

▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁	
【三】QJsonDocument	// QJsonDocument类提供了一种读取和写入JSON文档的方法。
①概述
	1.可用将(UTF8格式的JSON串)和(Qt自己的二进制格式的JSON串), 构造为QJsonDocument
	2.QJsonDocument是一个包装完整的JSON文档类
	4.使用isArray（）和isObject（）查询文档是否包含数组或对象。 
	5.可以使用array（）或object（）检索文档中包含的数组或对象，然后进行读取或操作。
	6.还可以使用fromBinaryData（）或fromRawData（）从存储的二进制表示创建文档。	
②常用判断:
		bool isArray() const
		bool isObject() const
		bool isEmpty() const
		bool isNull() const
③将JSON文档转换为JSON数组, JSON对象
	array() 
	object()
④QJsonDocument转化为JSON串(打印出来)
	QJsonDocument::toJson()
⑤构造QJsonDocument	
	(1)设置QJsonDocument的内容
		QJsonDocument::setObject(obj);
		QJsonDocument::setArray(jsarry);
		
	(2)构造方法
		QJsonDocument(const QJsonObject &object)	// 使用JSON对象来构造QJsonDocument
		QJsonDocument(const QJsonArray &array)		// 使用JSON数组来构造QJsonDocument
		
	(3)静态函数
		// 将Qt的二进制数据构造为QJsonDocument, 默认检查QByteArray是否为json串
			QJsonDocument fromBinaryData(const QByteArray &data, DataValidation validation = Validate)
		// 将Qt的二进制数据构造为QJsonDocument, 
			QJsonDocument fromJson(const QByteArray &json, QJsonParseError *error = Q_NULLPTR)
		// 将字符串解析为QJsonDocument
			QJsonDocument fromRawData(const char *data, int size, DataValidation validation = Validate)
		// 将variant解析为QJsonDocument
			QJsonDocument fromVariant(const QVariant &variant)
			
			
▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃
							第22章  Qt事件
▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃
【一】QEvent		// 所有事件类的基类。(其中包含了事件的参数)
①概述
	1.Qt的主事件循环（QCoreApplication :: exec（））从事件队列中获取本机窗口系统事件，将它们转换为QEvents，并将转换后的事件发送到QObjects。
	2.通常，事件来自底层窗口系统（spontaneous（）返回true）
	3.手动发送使用QCoreApplication :: sendEvent（）和QCoreApplication :: postEvent（）手动发送事件（spontaneous（）返回false）。
	4.QObjects通过调用其QObject :: event（）函数来接收事件。该函数可以在子类中重新实现，以自定义事件处理并添加其他事件类型; QWidget :: event（）是一个值得注意的例子。
	5.默认情况下，事件被调度到事件处理程序，如QObject :: timerEvent（）和QWidget :: mouseMoveEvent（）。
		QObject :: installEventFilter（）允许对象拦截发往另一个对象的事件。
	6.基本QEvent仅包含事件类型参数和“accept”标志。 accept标志用accept（）设置，并用ignore（）清除。
		它默认设置，但不依赖于此，因为子类可以选择在构造函数中清除它。QEvent的子类包含描述特定事件的其他参数。
②enum QEvent::Type定义了所有事件的类型
③在事件循环中需要调用update来刷新窗口
	
▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁	
【二】QMouseEvent	// 包含鼠标事件描述的参数
①概述
	1.当鼠标在窗口内部按下或者释放时,或者鼠标光标在窗口内部移动时,会产生鼠标事件.
	2.当鼠标按下后,在窗口内部移动会产生鼠标移动事件。如果用户调用了QWidget::setMouseTracking(true)，在用户为按下鼠标时移动一会产生该事件
	3.鼠标事件包含一个特殊的接受标志，指示接收者是否想要该事件。 如果窗口小部件未处理鼠标事件，则应调用ignore（）。 
	4.鼠标事件沿父窗口小部件链向上传播，直到窗口小部件使用Accept（）接受它，或者事件过滤器使用它。
②位置
	1.pos(), x(), y()返回鼠标相对于接收事件窗口的位置
	2.如果事件移动了窗口，那么用globalPos()来获取全局位置
③启用、禁用窗口的鼠标和键盘事件
	QWidget::setEnabled()
④我们可以重新实现的窗口事件（QWidget定义为虚函数）
	QWidget::mousePressEvent() 
	QWidget::mouseReleaseEvent()
	QWidget::mouseDoubleClickEvent()
	QWidget::mouseMoveEvent()
▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁	
【三】QKeyEvent
①概述
	1.键盘事件包含一个特殊的接受标记, 指示接收器是否是否处理该按键事件.
	2.对于QEvent :: KeyPress和QEvent :: KeyRelease，默认情况下会设置此标志，因此在处理键事件时无需调用accept（）。
	3.对于QEvent :: ShortcutOverride，接收器需要显式接受事件以触发覆盖。
	4.在键事件上调用ignore（）会将其传播到父窗口小部件。 事件沿父窗口小部件链向上传播，直到窗口小部件接受它或事件过滤器使用它。
	5.QWidget :: setEnable（）函数可用于启用或禁用窗口小部件的鼠标和键盘事件。
②接口
	QString QKeyEvent::text() const
		返回按下的字符
	int QKeyEvent::key() const
		返回按下字符的asscii码
	int QKeyEvent::count() const
		如果键入的是数字, 返回数值, 如果是字符串就返回字符串的长度

▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁	
【三】QPaintEvent 	// 包含了一个绘画事件的事件参数
①概述
	1.该事件发送到需要自我更新的窗口小部件上
	2.启动一个窗口程序时, Qt会进行窗口绘制,这时会产生一个绘图事件; 我们可以用在这个事件处理里面绘制我们想要的线条。
	3.缩放窗口时, 窗口会进行重绘, 也会产生绘画事件
②QWidget的绘图事件API
	
▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁	
【三】QPainter	// 包含了一个绘画事件的事件参数
①概述
	1.QPainter可以对继承QPaintDevice类的任何对象进行绘制。
	2.它可以绘制从简单线条到复杂形状（如馅饼和和弦）的所有内容。 
	3.它还可以绘制对齐的文本和像素图。
	
②QPainter与QPaintDevice和QPaintEngine类一起构成了Qt绘画系统的基础。
	1.QPainter是用于执行绘图操作的类。
	2.QPaintDevice表示可以使用QPainter绘制的设备。
	3.QPaintEngine提供画家用于绘制到不同类型设备上的界面。

③QPainter可以设置的选项(前提是QPainter处于isActive()状态)
	1.字体设置
		font() 	通过	 fontInfo() 和 fontMetrics() 设置/获取字体和字体属性
	2.定义用于填充形状的颜色或图案
		brush()	 	
	3.定义用于绘制线条或边界的颜色或点画。
		pen() 	
	4.定义平铺画笔的原点，通常是小部件背景的原点。
		brushOrigin() 
	5.QPainter的坐标转换系统。	
		viewport(), window(), worldTransform() 
	6.告诉画家是否剪辑。
		hasClipping() 
	7.定义绘制文本时画家使用的布局方向。
		layoutDirection() 
	8.指示是否启用了世界转换。
		worldMatrixEnabled()  
	9.指示是否启用了视图转换。
		viewTransformEnabled()
	// 可以通过调用save（）函数随时保存QPainter的状态，该函数将所有可用设置保存在内部堆栈中。
	//	restore（）函数会弹回它们。
	
④引用
	(1)绘制文字
		void Widget::paintEvent(QPaintEvent *event)
		{
			QPainter painter;
			if (!painter.isActive())
				painter.begin(this);
			painter.setPen(Qt::red);
			painter.setFont(QFont("Arial", 60));
			painter.drawText(this->rect(), Qt::AlignCenter, "Qt");
		}
	(2)绘制直线
		painter.drawLine(QPoint(0,0), QPoint(this->rect().width(), this->rect().height()));
		
	(3)绘制圆绘制椭圆
		painter.drawEllipse(100, 100, 50,25);
		
	(4)绘制折线
		 QPolygon container;
		container.append(QPoint(20,20));
		container.append(QPoint(h,20));
		painter.drawPolyline(container, 2);

	(5)绘制弧线或者玹
		painter.setPen(Qt::blue);
		int start_angle = 0 * 16;   		// 0°
		int end_angle = 120 * 16;      // 120°
		painter.drawArc(this->rect(), start_angle, end_angle);
		
	(6)绘制凸多边形
		static const QPointF points[4] = {
			 QPointF(10.0, 80.0),
			 QPointF(20.0, 10.0),
			 QPointF(80.0, 30.0),
			 QPointF(90.0, 70.0) 
		 };
		painter.drawConvexPolygon(points, 4);
	(7)绘制图片
		QRectF target(10.0, 20.0, 80.0, 60.0);
		QRectF source(0.0, 0.0, 70.0, 40.0);
		QImage image("F:2.bmp");
		painter.drawImage(target, image, source);
	
▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁	
【四】2D绘图程序示例，关键代码（请看笔记项目）
	// .h
		#ifndef MAINWINDOW_H
		#define MAINWINDOW_H

		#include <QMainWindow>
		#include <QColorDialog>
		#include <form.h>
		#include <QPoint>

		typedef struct line {
			QVector<QPoint> vec;
			QColor color;
			int lineWidth;
		}line_t;
		namespace Ui {
		class MainWindow;
		}

		class MainWindow : public QMainWindow
		{
			Q_OBJECT

		public:
			explicit MainWindow(QWidget *parent = 0);
			~MainWindow();
			virtual void mouseReleaseEvent(QMouseEvent *event);
			virtual void mouseMoveEvent(QMouseEvent *event);
			virtual void paintEvent(QPaintEvent *event);

		public slots:
			void menuBar_slot(QAction *action);

		private:
			Ui::MainWindow *ui;
			Form *form;
			QColor cur_color;
			int cur_lineWidth;
			QVector<line_t> lines;
		};

		#endif // MAINWINDOW_H
	// .cpp
		#include "mainwindow.h"
		#include "ui_mainwindow.h"
		#include <QAction>
		#include <QDebug>
		#include <ui_form.h>
		#include <QMouseEvent>
		#include <QPainter>

		static QVector<QPoint> cur_vec;

		MainWindow::MainWindow(QWidget *parent) :
			QMainWindow(parent),
			ui(new Ui::MainWindow)
		{
			ui->setupUi(this);
			// Form中包含颜色设置对话框, 线宽设置拖动条
			form = new Form(this);
			// 点击MainWindow上的mennuBar时会产生triggered事件
			QObject::connect(ui->menuBar, &QMenuBar::triggered, this, &MainWindow::menuBar_slot);

			// 设置画笔的默认颜色和线宽
			cur_color.setRgb(0,0,0);
			cur_lineWidth = 5;
		}

		MainWindow::~MainWindow()
		{
			delete ui;
		}

		// 窗口尺寸变化或者调用QWidget::update()时,产生重绘事件
		void MainWindow::paintEvent(QPaintEvent *e)
		{
			// 创建一个绘画器
			QPainter painter(this);
			QPen pen = painter.pen();

			// 如果窗口描绘未被激活就激活
			if (!painter.isActive())
				painter.begin(this);


			// 绘出之前绘制的线段
			if (!lines.isEmpty()) {
				for (int i=0; i< lines.size(); i++) {
					line_t line = lines.at(i);
					pen.setColor(line.color);       // 设置画笔颜色
					pen.setWidth(line.lineWidth);   // 设置画笔颜色
					painter.setPen(pen);
					painter.drawPolyline(line.vec.begin(), line.vec.size());    // 绘制折线
				}
			}

			// 绘制当前描绘的线段
			pen.setColor(cur_color);
			pen.setWidth(cur_lineWidth);
			painter.setPen(pen);
			painter.drawPolyline(cur_vec.begin(), cur_vec.size());
		}

		// 按下鼠标后移动产生鼠标移动事件
		void MainWindow::mouseMoveEvent(QMouseEvent *e)
		{
			cur_vec.append(e->pos());

			// 让窗口产生重绘事件
			this->update();
		}

		// 松开移动的鼠标后产生鼠标松开事件
		void MainWindow::mouseReleaseEvent(QMouseEvent *e)
		{
			// 记录上一次描绘线段的点, 颜色, 线宽
			line_t line;
			line.color = cur_color;
			line.lineWidth = cur_lineWidth;
			line.vec = cur_vec;

			// 上一次描绘的线段放入容器中
			lines.append(line);

			// 清空当前描绘所用的点容器
			cur_vec.clear();
		}

		// 获取mennuBar上被点击的条目(槽)
		void MainWindow::menuBar_slot(QAction *action)
		{
			qDebug()<<action->text();

			// 设置颜色
			if (action->text() == "color"){
				// 记录设置的颜色信息
			   QColor tmp =  QColorDialog::getColor(Qt::black);
				if(tmp.isValid())
					cur_color = tmp;
				qDebug()<<"cur_color"<<cur_color;
			}
			// 设置线宽
			if (action->text() == "lineWidth") {
				if(!form->exec())   // form是设置线宽的对话框
					return;
				// 记录设置的线宽信息
				cur_lineWidth = form->ui->horizontalSlider->value();
				qDebug()<<cur_lineWidth;
			}
		}
		
▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁	
【五】QPaintEngine
▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁	
【六】QWidget处理的事件	// Qt使用QEvent向QWidget传递用户产生的事件
	(1)窗口事件
		窗口重绘事件: paintEvent（）
		窗口调整事件: resizeEvent（）
		窗口移动事件： moveEvent（）
		窗口关闭事件：closeEvent（）。
	(2)鼠标事件
		光标事件: 	 grabMouse（）
		鼠标按下事件 mousePressEvent（）
		释放鼠标事件 mouseReleaseEvent（）	// 在窗口内部按下后,在窗口外部释放的事件也能被捕捉
		双击事件		 mouseDoubleClickEvent（）
		鼠标移动事件 mouseMoveEvent（）		// 按住鼠标移动。但是如果调用了setMouseTracking（true），即使鼠标没按下，也会产生该事件。
		鼠标进入事件 enterEvent（）			// 鼠标进入窗口小部件
		鼠标离开事件 leaveEvent（）
	(3)滚轮事件
		wheelEvent（）// 只要用户在窗口小部件具有焦点时转动鼠标滚轮
		
	(4)键盘事件
		按键事件	   keyPressEvent（）	// 注意：当按下一个键足够长的时间，会重复产生keyPressEvent（）事件。
		键盘焦点事件   focusInEvent（）		//（假设您已调用setFocusPolicy（））。
		键盘焦点事件   focusInEvent（）		//（假设您已调用setFocusPolicy（））。
		按键释放事件： keyReleaseEvent（）
	
	(5)其他事件
		 QEvent::Type中定义了所有事件的类型, 需要我们重新实现event函数。
	
	说明： 这些事件在QWidget的默认处理方式大多数为不处理，如果我们想要处理这些事件，应该重新实现这些虚函数。
	
▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁	







▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃
							第23章  Qt引用和生成库（使用的时候创建一个测试库）
▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃
// https://wiki.qt.io/How_to_create_a_library_with_Qt_and_use_it_in_an_application
// 手册：Creating Shared Libraries
▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁	
【一】创建独立于Qt事件循环的共享库（库中使用了事件循环，但是用该库的程序不是Qt事件循环程序）
(1)步骤
	①创建要链接的共享库时，需要确保在创建库时正确导出将在库外部使用的符号。随后在链接库时导入。
	   这可以使用Q_DECL_EXPORT和Q_DECL_IMPORT完成，如以下示例所示：
			//(test.h)
				#include  <QtGui>
				#if defined TEST
					#define TEST_COMMON_DLLSPEC Q_DECL_EXPORT 
				#else 
					#define TEST_COMMON_DLLSPEC Q_DECL_IMPORT 
				#endif
				class  TEST_COMMON_DLLSPEC  Widget  ： public  QWidget 
				{ 
					Q_OBJECT 
					public ：
					Widget （）;
				};	
			// test.cpp
				#include  “test.h”
				#include  <QtGui>
				Widget :: Widget （） ： QWidget （） {}	
			// test.pro
				TEMPLATE = lib
				# Input
				SOURCES += test.cpp
				HEADERS += test.h
				DEFINES += TEST	
				DEFINES += QT_DEPRECATED_WARNINGS
				unix {
					target.path = /usr/lib
					INSTALLS += target
				}
	②在Windows中，MinGW将输出.a和.dll，MSVC2010将输出.lib和.dll。在linux中，MinGW将输出.so，.so.1，.so.1.0和.so.1.0.0 - .lib，.a和.so是导入库。
		它们有助于将代码链接到库，并且在构建文件时需要（.a文件不是所有时间）。
▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁	
【二】应用程序与共享库链接
(1)原理:
	1.include会去找我们包含的头文件
	2.编译会用到我们的*.lib lib*.a库(函数的定义)
	3.执行程序会去找dll库(函数的实现)
(2)使用方法(在Qt中使用库)
	1.为了在您的应用程序中使用共享库，您可以在代码中包含库的头文件并使用这些方法。
		通过链接到.lib文件进行编译。在运行时，这会加载具有实现的dll。			
	2.INCLUDEPATH指向库头文件路径
	3.LIBS指向lib或者.a库的路径和文件名
	4.另外: 要确保应用程序运行时能找到.dll(Qt项目->run->working directory设置为dll的路径)
	例子:	(也可以在项目上右键点击添加外部库)
		// loadTestLib.pro
			TEMPLATE = app
			TARGET =
			DEPENDPATH += . ../testLib
			INCLUDEPATH += ../testLib
			LIBS += -L../testLib/debug -ltestLib
			# Input
			SOURCES += main.cpp	
			#这段代码需要追加
			win32:CONFIG (release, debug|release): LIBS += -L$$PWD/build-MyLibrary/ -lmylibrary
			else:win32:CONFIG (debug, debug|release): LIBS += -L$$PWD/build-MyLibrary/ -lmylibrary
			else:unix: LIBS += -L$$PWD/build-MyLibrary/ -lMyLibrary
			INCLUDEPATH += $$PWD/build-MyLibrary
			DEPENDPATH += $$PWD/build-MyLibrary
			// 这里使用$$ PWD来指定通向包含.pro文件的目录的完整路径。
				请注意，对于Unix / Linux系统，库文件名区分大小写，但对于Windows，您必须全部保留小写。	
		// main.cpp	
		#include <QtGui>
		#include "test.h"
		int main(int argc, char *argv[])
		{
			QApplication a(argc, argv);
			Widget w;
			w.show();
			return a.exec();
		}			
(3)QT点击添加库
	内部库： 是Qt内部的库
	系统库： 系统自带的库
	外部库： 我们使用第三方库，一般选择这个
▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁	
【三】将Qt事件循环程序封装为window中C++和C#能够调用的静态库或者动态库（应用程序脱离Qt框架）
(1)vs中封装库
	0.在vs中使用QT VS TOOLS创建Qt库项目
	1.将需要的项目封装为一个功能类(如: Widget).
	2.将外部需要的接口放到头文件中, 开启一个C++线程来处理事件循环 //在创建QApplication之前不能使用任何Qt类(Qt中的任何类都需要事件循环),否则系统认为主线程不在主线程中创建
	3.删除xx_global.h, 并删除对应的宏定义.
	4.给库外部调用的函数需要声明为extern "C" __declspec(dllexport).
	5.项目在vs中创建
		1.将项目配置属性设置为"无公共语言运行时支持", 否则Qt的事件循环将不能产生.
		2.不要用Qtwinmigrate, 没卵用, 还是不能产生事件循环.
	6.示例:
		//dlllib.h
			#pragma once
			#define DLL extern "C" __declspec(dllexport)
			#include "hilink_profile.h"
			DLL bool call_get_hilink_dev_info(const char *sn, brg_dev_info_t *dev_info);
			DLL bool call_get_hilink_svc_info(const char *sn, brg_dev_svc_info_t *svc_info, unsigned int *svc_num);
			DLL bool call_get_hilink_dev_svc_state(const char *sn, const char *svc_id, const char *in, unsigned int in_len, char **out, unsigned int *out_len);
			DLL bool call_put_hilink_dev_svc_state(const char *sn, const char *svc_id, const char *payload, unsigned int len);
			DLL void set_buspro_ip(const char *ip);
			DLL void start_buspro();
			DLL void destroy_buspro();
		// dll.lib.cpp
			#include "dlllib.h"
			#include <thread>
			#include <objbuspro.h>
			#include <QCoreApplication>
			#include <iostream>
			#include <thirdparty/hilink/hilink_comm.h>
			#include "hilink_profile.h"
			#include <qt>
			using namespace std;
			char ipaddr[16];
			static ObjBuspro *tmp_buspro = NULL;
			void run()
			{
				int argc = 0;
				QCoreApplication a(argc, NULL);
				//ObjBuspro buspro(ipaddr);

				ObjBuspro buspro(ipaddr);
				tmp_buspro = &buspro;
				cout << "a.exec().............." << endl;
				a.exec();
				cout << "a.exec() return" << endl;
			}
			void set_buspro_ip(const char *ip)
			{
				QString tmp = QString::fromStdString(ip);
				memset(ipaddr, 0, sizeof(16));
				strcpy(ipaddr, tmp.toLatin1().data());
				cout << "ipaddr ip:" << ipaddr << endl;
			}
			void start_buspro()
			{
				cout << "Staticlib::Staticlib()" << endl;
				thread *th = new thread(run);
				th->detach();
				cout << "th->detach()" << endl;
			}
			void destroy_buspro()
			{
				tmp_buspro->release_buspro();
			}
			//-----------------------------------------------------------------------------------------
			bool call_get_hilink_dev_info(const char *sn, brg_dev_info_t *dev_info)
			{
				return get_hilink_dev_info(sn, dev_info);
			}
			bool call_get_hilink_svc_info(const char *sn, brg_dev_svc_info_t *svc_info, unsigned int *svc_num)
			{
				return get_hilink_svc_info(sn, svc_info, svc_num);
			}
			bool call_get_hilink_dev_svc_state(const char *sn, const char *svc_id, const char *in, unsigned int in_len, char **out, unsigned int *out_len)
			{
				return get_hilink_dev_svc_state(sn, svc_id, in, in_len, out, out_len);
			}
			bool call_put_hilink_dev_svc_state(const char *sn, const char *svc_id, const char *payload, unsigned int len)
			{
				return put_hilink_dev_svc_state(sn, svc_id, payload, len);
			}
	
(2)在windows C++中调用Qt库
	0."解决方案的配置"和"解决方案的平台"必须与创建库时使用的完全一致. // 比如: release x64
	1.将库的头文件包含到函数中.
	2.链接.lib库(静态库和动态库都是一样)到项目中.
	3.将生成库的.dll文件放到文件的执行路径.
	4.示例程序
		// usedll.cpp
		#include <iostream>
		int main()
		{
			std::cout << "Hello World!\n"; 
			set_buspro_ip("172.16.24.207");
			start_buspro();
			int a;
			std::cin >> a;
			destroy_buspro();
		}

(3)在windows C#中调用Qt库
	0."解决方案的配置"和"解决方案的平台"必须与创建库时使用的完全一致. // 比如: release x64
	1.不能在工程的"引用"中引用这个库, 否则会报错"添加组件错误".	// 因为C++的dll库不是一个COM组件, C#不能识别
	2.C#仅需要用到库.dll文件(必须是动态库), 将dll文件拷贝到执行路径.
	3.在代码中每使用一个函数都需要提前声明为外部库函数, 然后在程序中调用该函数.
	4.必须添加using System.Runtime.InteropServices;   //必须添加，否则DllImport报错
	5.示例程序
		//csp_test.cs
			using System;
			using System.Collections.Generic;
			using System.Linq;
			using System.Text;
			using System.Threading.Tasks;
			using System.Runtime.InteropServices;   //必须添加，不然DllImport报错
			
			namespace csp_test
			{
				class CPPDLL
				{
					[DllImport("dlllib.dll", CharSet = CharSet.Ansi)] //引入dll，并设置字符集
					public static extern void set_buspro_ip(string obj);

					[DllImport("dlllib.dll", CharSet = CharSet.Ansi)] //引入dll，并设置字符集
					public static extern void start_buspro();
				}
				class Program
				{
					CPPDLL.set_buspro_ip("172.16.24.207");
					CPPDLL.start_buspro();
					ReadLine();
				}
			}

▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁	
【四】将Qt事件循环程序封装为IOS object-c调用的库（应用程序脱离Qt框架）
	1.vmvare15中安装os虚拟机
		https://blog.csdn.net/galaxy_yyg/article/details/82891044	// 我拷贝的博文
	2.安装OS版VS， 将windows中的源码导入生成OS平台的库， 然后调用
▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁	
【五】	将Qt事件循环程序封装为Linux C++调用的库
	1.安装Qt for Linux
	2.生成库
	3.用Qt写一个测试程序(里面包含需要的模块)
	4.在命令行中执行make, 看Makefile做了声明
	5.复制Makefile的执行过程到我们的非Qt测试示例中
	6.编写非Qt测试示例源代码。
▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃
											第24章  Qt软件盘
▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃

【一】Qt5.9版本	// 使用自带的软件盘
		1.只需添加下面一句话就会在需要输入的地方弹出带英文输入的软键盘
			//qputenv("QT_IM_MODULE", QByteArray("qtvirtualkeyboard"));
			//QApplication a(argc, argv);
【二】Qt5.12版本 // 使用自带的软件盘
		https://doc.qt.io/qt-5/qtvirtualkeyboard-module.html
			QT += virtualkeyboard
			#include <QtVirtualKeyboard>
			qputenv("QT_IM_MODULE", QByteArray("qtvirtualkeyboard"));
			//QApplication a(argc, argv);


【三】Qt5.8及以下版本， 需要自己实现虚拟键盘
		思路：（例如输入1）
			1.先绑定到按键的槽函数
			2.在槽函数找那个产生按键1事件
			3.将按键1事件发送聚焦的窗口
			// 这样做的目的是对于不同的输入栏,  我们键入后能自动输入到正在输入的栏。
		代码：
			// 按键"1" 
			void Widget::on_pushButton_clicked()
			{
				char c =  ui->pushButton->text().data()->toLatin1();
				QKeyEvent *e = new QKeyEvent(QKeyEvent::KeyPress, c, Qt::NoModifier, ui->pushButton->text());
				QApplication::postEvent(QWidget::focusWidget(), e);
			}
▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃
							第25章  Qt自定义控件
▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃
①思路
	(1)制作自定义控件(如: rolltext)
		1.控件继承于QWidget.
		2.用QWidget::update()产生重绘事件.
		3.在重绘事件处理函数中绘制出需要的图形或者文字.
	(2)使用自定义控件
		1.将自定义控件的文件拷贝到测试工程目录,并加入工程.
		2.在窗口中拖入一个新的widget, 点击右键提升为(如: rolltext),  填入提升为的类名. 
		3.点击运行就可以看到新加入的widget变为了自定义控件
		
②示例
	(1)自定义控件
		// rolltext.h
			#include <QWidget>
			#include <QTimer>
			namespace Ui {
			class RollText;
			}

			class RollText : public QWidget
			{
				Q_OBJECT

			public:
				explicit RollText(QWidget *parent = nullptr);
				void set_text(QString str);
				void  paintEvent(QPaintEvent *event);
				~RollText();
			public slots:
				void time_out();

			private:
				QString text;
				QTimer *timer;
				int w;
				int i;
			};
		//  rolltext.cpp
			#include "rolltext.h"
			#include <QDebug>
			#include <QPainter>
			RollText::RollText(QWidget *parent) :
				QWidget(parent)
			{
				timer = new QTimer(this);
				QObject::connect(timer, &QTimer::timeout, this, &RollText::time_out);
				timer->start(10);
				i = 0;
			}

			void RollText::set_text(QString str)
			{
				this->text = str;
			}

			void RollText::paintEvent(QPaintEvent *event)
			{
				QPainter painter(this);
				painter.setFont(QFont("Arial", 30));
				QPen pen = painter.pen();
				pen.setColor(QColor(Qt::red));
				pen.setWidth(10);
				painter.setPen(pen);
				int text_width = painter.font().weight() * text.count();
				if (i == (this->width()/2 + text_width))		// 移动到了最左边
					i = -this->width()/2;								// 移动到最右边
				painter.drawText(QPoint((this->width()/2 - i++),this->height()/2), this->text);
			}
			void RollText::time_out()
			{
				this->update();
			}
	
	(2)测试程序
		Widget::Widget(QWidget *parent) :
			QWidget(parent),
			ui(new Ui::Widget)
		{
			ui->setupUi(this);
			ui->roll1->set_text("上面滚动");
			ui->roll2->set_text("下面滚动");
		}







▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃
						第26章  Qt大项目(信息显示平台)
▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃
①需求:
	1.查看天气
	2.查看pm2.5
	3.通过服务器发送紧急通知和公告
	4.播放广告
	5.底部滚动信息(通过服务器发送)
	6.终端通过服务器与服务器进行通信
②终端板块图
	--------------------------------------------------------------
	|	----------------						|-----------------------------	   |			
	|	|	天气(滚动)			|						|														 |	   |													
	|	----------------						|														 |	   |																																	
	|															|														 |	   |														
	|															|														 |	   |																										
	|	----------------						|														 |	   |																		
	|	|	环境(滚动)			|						|		广告/公益视频						 |	   |	 				
	|	----------------						|														 |	   |					
	|															|														 |	   |									
	|															|														 |	   |						
	|	----------------						|                                                        |	   |	 																	
	|	|	文字广告			   |						|----------------------------|	   |					
	|	|	/市民紧急通知  |							|			滚动信息(循环)					 |	   |		
	|	----------------						|----------------------------|	   |								
	|-------------------------------------------------------------|
	
	
▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃
						第26章  Qt多媒体播放器
▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃
【一】播放多媒体
	①概述
		1.QMediaPlayer类允许播放媒体源。
		2.QMediaPlayer类是高级媒体播放类。 它可用于播放歌曲，电影和网络电台等内容。
		3.要播放的内容被指定为QMediaContent对象，可以将其视为附加附加信息的主要或规范URL。
		4.当提供QMediaContent播放时或许可以开始播放。
		5.通常将QMediaPlayerList与其配合使用
	②获取当前播放的音频文件的总时长和播放了的时长
			// 播放进度改变(以毫秒为单位)
			 QObject::connect(player, &QMediaPlayer::positionChanged, this, &Widget::positionChanged);
			void Widget::positionChanged(qint64 position)
			{
				int total = player->duration() / 1000;  // 当前播放文件的总时长
				int cur = position / 1000;              // 当前播放的时长
			}
	③获取当前播放的文件名
			// 总时长改变(以毫秒为单位)    // 播放新文件是将产生该信号
			QObject::connect(player, &QMediaPlayer::durationChanged, this, &Widget::durationChanged);
			// 播放进度改变(毫秒为单位)

			// 播放列表中的文件
			void Widget::durationChanged(qint64 duration)
			{
				QString filename = get_filename(player->currentMedia().canonicalUrl().toString());
			}
	④向播放列表中加入新文件	// QMediaPlayer会自动顺序播放列表中的文件
			QMediaPlaylist music_list;    // 音乐播放列表
			QStringList list = QFileDialog::getOpenFileNames(); // 获取多个文件
			for (int i=0; i < list.size(); i++) {
				music_list.addMedia(QUrl(list.at(i)));      // 多个文件放入播放列表
			}
	⑤播放, 暂停, 停止
		[slot] void QMediaPlayer::play()		// 开始或者继续播放当前资源
		[slot] void QMediaPlayer::pause()		// 暂停当前播放的资源
		[slot] void QMediaPlayer::stop()		// 停止播放, 并重置播放器的位置到初始位置


▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁	
【二】视频组件(QVideoWidget与QMediaPlayer联合使用)
	①QVideoWidget	// 提供了用于播放QMediaObject对象的视频窗口
			1.将一个QVideoWidget附加到QMediaObject对象上去, 来允许在QVideoWidget上播放QMediaObject的图像或者视频

	③注意: 
		1.需要安装解码器: LAVFilters-0.65.exe
				否则报错: DirectShowPlayerService::doRender: Unresolved error code 0x80040266 ().
		2.必须设置QVideoWidget的窗口大小, 否则只有声音没有图像.
	②示例:
			// 窗口大小改变时, 重新设置QVideoWidget的窗口大小
			void Widget::paintEvent(QPaintEvent *e)
			{
				mwidget->resize(this->size());   // 必须设置, 否则显示不出图像
			}

			Widget::Widget(QWidget *parent) :
			{
				mwidget = new QVideoWidget(this);
				player = new QMediaPlayer(this);
				player->setVideoOutput(mwidget);
				player->setMedia(QUrl::fromLocalFile("D:/HDL_____/qt_test/Video/1.mp4"));
				player->setVolume(50);
				mwidget->show();
			}
			
▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃
						第26章  Qt视频采集和播放
▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃
概述
	QCamera类为系统摄像机设备提供接口。
	QCamera可配合QCameraViewfinder进行取景器显示(安卓上不适用)，
	QMediaRecorder进行视频录制，
	QCameraImageCapture进行图像拍摄。
	您可以使用QCameraInfo列出可用的相机并选择使用哪一个。
▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁	
【一】QCamera	 // 系统摄像头设备接口。
	①枚举系统摄像机,并打开其中一个
		QList<QCameraInfo> camInfos = QCameraInfo::availableCameras();
		for(int i=0; i<camInfos.size(); i++) {
			QCameraInfo info = camInfos.at(i);
			dump(info.deviceName());      			// 相机设备名
			dump(info.description());     			// 相机的描述
			if (info.position() == QCamera::FrontFace)      // 前摄像头
				dump(QString("QCamera::FrontFace"));
			else if (info.position() == QCamera::BackFace)  // 后摄像头
				dump(QString("QCamera::BackFace"));
		}
	②实例化QCamera
		camera = new QCamera(QCameraInfo);   // 前相机
	③相机捕获模式
		CaptureMode { 
			CaptureViewfinder,	// 取景器，用于显示摄像头的数据
			CaptureStillImage,	// 捕获图片
			CaptureVideo 
		}
	④查看相机支持的采集参数
		supportedViewfinderFrameRateRanges		// 支持的帧率
		supportedViewfinderPixelFormats			// 支持的像素格式
		supportedViewfinderResolutions			// 支持的分辨率
		supportedViewfinderSettings				// 支持的取景器列表
		
▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁	
QMediaRecorder	// 多媒体录音或录视频


▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁	
QAbstractVideoSurface	// 视频流显示基类
①概述:
	1.QAbstractVideoSurface类定义视频制作者用于与视频演示表面交互操作的标准接口。
	2.您可以将此接口子类化，以接收来自解码媒体或相机等源的视频帧，以执行您自己的处理。
	3.视频表面呈现连续相同格式的QVideoFrame实例流，其中每个帧的格式与开始演示时提供的流格式兼容。
	4.每个帧可以具有时间戳信息，表面可以使用该信息来决定何时显示该帧。
	5.表面可以呈现的像素格式列表由supportedPixelFormats（）函数给出，
		isFormatSupported（）函数将测试是否支持视频表面格式。
		如果不支持格式，nearestFormat（）函数可能能够建议类似的格式。
	6.start（）函数采用支持的格式并启用视频表面。
		一旦启动，曲面将开始显示它在present（）函数中接收的帧。	
②实现QAbstractVideoSurface的子类--实现虚函数
	1.需描述您支持的像素格式（以及nearestFormat（）函数）。
	2.您必须实现present（）函数以及start（）和stop（）函数。
	注意：您必须在实现中调用start（）和stop（）的基类实现。	



▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁	
QCameraImageCapture	// 记录媒体图像内容
示例:
	camera = new QCamera;
	viewfinder = new QCameraViewfinder();
	viewfinder->show();
	camera->setViewfinder(viewfinder);	// 安卓不适用
	imageCapture = new QCameraImageCapture(camera);
	imageCapture->set
	camera->setCaptureMode(QCamera::CaptureStillImage);
	camera->start();
	//on half pressed shutter button
	camera->searchAndLock();
	//on shutter button pressed
	imageCapture->capture();

  //on shutter button released
  camera->unlock();	

	
▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁	
QCameraViewFinder	// 提供一个取景器窗口, 安卓中不适用(但是也要设置, 否则相机初始化失败)
	取景器，用于设置摄像头的采集参数
示例:
	camera = new QCamera;
	viewfinder = new QCameraViewfinder();			// 分配取景器
	viewfinder->show();								// 显示取景器窗口
	camera->setViewfinder(viewfinder);				// 设置相机的取景器	
	imageCapture = new QCameraImageCapture(camera);	// 设置图像捕获器
	camera->setCaptureMode(QCamera::CaptureVideo);	// 设置捕获模式
	camera->start();	// 开始捕获	




▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁	
【三】QCameraViewfinderSettings 	// 提供了一组取景器的设置。
	①可设置选项
		MinimumFrameRate 	// 最大帧率
		MaximumFrameRate 	// 最小帧率
		Resolution 			// 分辨率
		PixelAspectRatio 	// 像素宽高比
		PixelFormat 		// 像素格式
		UserParameter		// 用户参数
	②设置相机的取景器示例	
		QCameraViewfinderSettings viewfinderSettings;
		viewfinderSettings.setResolution(640, 480);
		viewfinderSettings.setMinimumFrameRate(15.0);
		viewfinderSettings.setMaximumFrameRate(30.0);
		camera->setViewfinderSettings(viewfinderSettings);	
	③用户在设置取景器参数之前用该调用下面的函数来查看相机取景器支持的参数
		supportedViewfinderFrameRateRanges		// 支持的帧率
		supportedViewfinderPixelFormats			// 支持的像素格式
		supportedViewfinderResolutions			// 支持的分辨率
		supportedViewfinderSettings				// 支持的取景器列表
		
▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁	
QVideoFrame 
	一个QVideoFrame代表的就是相机的一帧数据。


			
▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃
						第26章  Qt音频采集和播放
▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃
[1]概念
	1.采样率:   一秒钟采样多少次
	2.通道数:	  音频通道个数(左通道,右通道)
	3.样本大小: 样本数据大小(典型为8,16bits)
		
	4.样本类型: 
		QAudioFormat::Unknown 		
		QAudioFormat::SignedInt 	// 有符号整数
		QAudioFormat::UnSignedInt 	// 无符号
		QAudioFormat::Float 		// flot类型样本
	5.字节序:
		小端
		大端
		6.同一时刻每个通道的已经采集到的样本称为"一帧"	
		
	6.Qt音频编码器
		1.目前Qt支持的是"audio/pcm": 
		2."audio/pcm"是将所有音频通道的样本交错在一起存放,
	7.nb_samples 	// 一帧音频一个通道的采样数量
--------------------------------------------------------------	
[2]	QAudioDeviceInfo	// 用于描述一个音频设备的信息
	①功能
		[1]查询可用的音频设备
		[2]构造与设备通信的类QAudioInput和QAudioOutput。
		[3]查询每个设备以获取其支持的格式
		[4]isFormatSupported(QAudioFormat *fmt)函数来判断设备信息是否支持fmt格式
	②获取系统默认音频输入设备的信息
		QAudioDeviceInfo info = QAudioDeviceInfo::defaultInputDevice();

	
▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁	
【三】QAudioInput	// 提供用于从音频输入设备读取音频数据的接口。
	  QAudioOutput
	  
▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁	
【四】音频采集和播放示例
	①widget.h
		namespace Ui {
		class Widget;
		}

		class Widget : public QWidget
		{
			Q_OBJECT

		public:
			explicit Widget(QWidget *parent = 0);
			void initInput();
			void initOutput();
			~Widget();
			void dump(QString str);
			void dump_fmt(QAudioFormat &inFmt);
			Ui::Widget *ui;

		public:
			QAudioFormat inFmt;
			QAudioInput *input;
			QIODevice *inIo;
			QAudioFormat outFmt;
			QAudioOutput *output;
			QIODevice *outIo;
		};

	②widget.cpp
		#include "widget.h"
		#include "ui_widget.h"
		//using namespace std;
		Ui::Widget *gui;
		static void dump2(QString str)
		{
			gui->textBrowser->append(str);
		}
		int audioTest(QIODevice *inIo, QIODevice *outIo)
		{
			char buf[4096] = {0};
			qint64 size = sizeof(buf);
			qint64 len = 0;
			while (1)
			{
				len = 0;
				while (len < size){
					len += inIo->read(buf + len, size - len);
				}
				//qDebug()<<QString("read: ") + QString::number(len);
				len = 0;
				while (len < size){
					len += outIo->write(buf + len, size - len);
				}
			}
			return 0;
		}

		Widget::Widget(QWidget *parent) :
			QWidget(parent),
			ui(new Ui::Widget)
		{
			ui->setupUi(this);
			gui = ui;

			this->initInput();
			this->initOutput();
			std::thread *th = new std::thread(audioTest, inIo, outIo);
			th->detach();
		}

		void Widget::initInput()
		{
			inFmt.setSampleRate(44100);
			inFmt.setChannelCount(2);
			inFmt.setSampleSize(16);
			inFmt.setSampleType(QAudioFormat::UnSignedInt);
			inFmt.setByteOrder(QAudioFormat::LittleEndian);
			inFmt.setCodec("audio/pcm");
			QAudioDeviceInfo info = QAudioDeviceInfo::defaultInputDevice();
			if (!info.isFormatSupported(inFmt)) {
				dump(QString("Default format not supported - trying to use nearest"));
				inFmt = info.nearestFormat(inFmt);
			}
			dump_fmt(inFmt);
			input = new QAudioInput(inFmt, this);
			inIo = input->start();
			if (!inIo) {
				dump("ERR: input->start()");
				exit(0);
			}
			if (!inIo->open(QIODevice::ReadWrite))  {
			   dump("ERR: open io");
			   exit(0);
			}
			dump("open input io ok");
		}

		void Widget::initOutput()
		{
			outFmt.setSampleRate(44100);
			outFmt.setChannelCount(2);
			outFmt.setSampleSize(16);
			outFmt.setSampleType(QAudioFormat::UnSignedInt);
			outFmt.setByteOrder(QAudioFormat::LittleEndian);
			outFmt.setCodec("audio/pcm");
			QAudioDeviceInfo info = QAudioDeviceInfo::defaultOutputDevice();
			if (!info.isFormatSupported(outFmt)) {
				dump(QString("Default format not supported - trying to use nearest"));
				outFmt = info.nearestFormat(outFmt);
			}
			dump_fmt(outFmt);
			output = new QAudioOutput(outFmt, this);
			outIo = output->start();
			if (!outIo) {
				dump("ERR: input->start()");
				exit(0);
			}
			if (!outIo->open(QIODevice::ReadWrite))  {
			   dump("ERR: open io");
			   exit(0);
			}
			dump("open output io ok");
			dump("------------------------------------------------");
		}

		Widget::~Widget()
		{
			delete ui;
		}
		void Widget::dump(QString str)
		{
			ui->textBrowser->append(str);
		}
		void Widget::dump_fmt(QAudioFormat &fmt)
		{
			//QAudioFormat::SampleType type = fmt->SampleType();
			dump("--------------------- dump_fmt ---------------------");
			dump(QString("sampleRate:   ") + QString::number(fmt.sampleRate()));
			dump(QString("channelCount: ") + QString::number(fmt.channelCount()));
			dump(QString("sampleSize:   ") + QString::number(fmt.sampleSize()));

			dump(QString("SampleType:   "));
			if (fmt.sampleType() == QAudioFormat::UnSignedInt)
			   dump("UnSignedInt:");
			else if ( fmt.sampleType() == QAudioFormat::Float)
			   dump("Float ");
			else if ( fmt.sampleType() == QAudioFormat::SignedInt)
			   dump("SignedInt");
			else
			   dump("Unknown");
			dump(QString("byteOrder:    ") + QString::number(fmt.byteOrder()));
		}



▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁	
【四】收音机组件
▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁	

▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃
					第26章  Qt数据库
▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃
【一】概述及常见问题
①基本说明
	1.Qt提供可以连接MySQL、Qracle、MS_SQL、SQLite、DB2等数据库的接口
	2.Qt自带数据库连接驱动, 在下面目录中:
		\QT\5.9.1_\Tools\QtCreator\bin\plugins\sqldrivers
②Qt连接到mySQL数据库
	[1]连接到本地数据库
		QSqlDatabase db = QSqlDatabase::addDatabase("QMYSQL");
		db.setHostName("localhost");
	[2]远程连接到远程数据库	
		1.打开MySQL Workbench->users and Privileges->将用户对应Limit to Hosts Matching更改为%。
③错误处理
	[1]QSqlDatabase: QMYSQL driver not loaded
		原因: Qt位数(32)与SQl(64)安装的位数不匹配
		解决办法:
			1.使用包含ming_gw64位编译器的Qt（需要配置Qt库的环境变量）
			2.或者, 现在32位的sql-cconnector(32位), 并包含到执行目录
▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁
【二】QSqlDatabase
①连接（addDatabase）
	QSqlDatabase db = QSqlDatabase::addDatabase("QMYSQL");
	1.QSqlDatabase类处理与数据库的连接。
	2.通过调用其中一个静态addDatabase（）函数创建连接（即QSqlDatabase的实例）
		1.可以在其中指定要使用的驱动程序或驱动程序类型（取决于数据库的类型）和连接名称。
		2.连接是由自己的名称知道的，而不是它所连接的数据库的名称。
		3.可以与一个数据库建立多个连接。
		4.如果在未指定连接名称的情况下调用任何静态成员函数，则将打开默认连接。
②克隆（cloneDatabase）
	克隆一个连接, 与原连接完全独立
③设置连接参数(必须在open之前设置)
	setHostName()
	//db.setHostName("localhost");		// 连接到本地数据库
	//db.setHostName("127.0.0.1");		// 连接到本地数据库
	//db.setHostName("172.16.24.169");	// 连接到远程数据库
	setPort(3306);						// 设置连接到数据库的TCP端口, MySQL默认为3306
	setDatabaseName()					// 设置要连接到的数据名称
	setUserName()						// 设置访问数据库的用户名称
	setPassword()						// 用户名对应的密码
④打开数据库(open)
	1.open之前必须设置好数据库的连接参数
	2.在打开连接之前，该连接不可用。
	
⑤数据库相关的方法
	方法							描述
	tables()					返回表的列表
	primaryIndex()				返回表的主索引
	record()					返回有关表的字段的元信息
	transaction()				开始一个transaction	
	commit()					保存并完成一个transaction
	rollback()					取消一个transaction
	hasFeature()				检查驱动是否支持transaction
	lastError()					返回最近一次的错误信息
	drivers()					返回可用SQL驱动程序的名称
	isDriverAvailable()			检查特定驱动程序是否可用
	registerSqlDriver()			registerSqlDriver（）
	
	注意：不推荐使用QSqlDatabase::exec（）。 请改用QSqlQuery::exec（）。
	注意：使用事务时，必须在创建查询之前启动事务。
	
▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃
						第26章  Qt OpenGL						
▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃
	Qt的所有界面都给予openGl绘制
	QOpenGLWidget(与界面交互)
	Program GLSL 定点和片元(与显卡GPU进行交互)	// 的语言
	材质Texture(如何写入ffmpeg数据)	

	void paintGL()				// 绘制
	void initializeGL()			// 材质初始化
	void resizeGL(int w, int h)	// 窗口变化时调用该函数	
	QOpenGLFunctions			// 直接获取opengl的函数
		
	-----------------	
	GLShaderProgram		// openGL是在显卡上跑的, GLShaderProgram用于与显卡之间的交互
	1.	编译运行shader
	2.addShaderFromSourceCode
	3.bindAttributeLocation设置传入的变量
	4.uniformLocation获取变量
	-----------------	
	着色器语言GLSL
	1.着色器语言GLSL 针对于OpenGL,给显卡使用的语言
		顶点着色器是针对么个顶点执行一次,用于确定顶点的位置;片元着色器是针对每个片元(可以理解为每个像素)执行一次,
		用于确定每个片元(像素)的颜色
		// 顶点: 三维坐标中的顶点
		// 片元: 针对于一个平面, 用于在空间上显示一幅图
	2.GLSL的基本语法与C基本相同
	3.完美的支持箱梁和矩阵的操作
	4.GLSL提供了大量的内置函数来提供丰富的扩展功能
	5.他是通过限定符操作来管理输入输出类型的
	-----------------	
	顶点着色器: 只能画三角形, 矩形需要另个三角形拼接
	-----------------	
	材质坐标信息都在第一象限




	-----------------	

	片元着色器
	1.在片元着色器阶段只有唯一的varying输出变量-及内建变量: gl_FragColor







▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃
						第26章  Qt on Android环境搭建					
▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃
【一】将Qt事件循环程序封装为android Java调用的库（应用程序脱离Qt框架）
	1.下载安装android studio开发工具: https://www.cnblogs.com/xiadewang/p/7820377.html
	我拷贝的博文：https://blog.csdn.net/fan_xingwang/article/details/78469680
	①概述
		1.首先，Android调用的库是.so库，所以QT必须安装QT for Android，否则无法生成对应的.so库。
			不要想着用linux系统也可以，因为它必须要生成具体的CPU架构的.so库。
	②QT生成so文件： 
		1.将QT for Android环境配置好
		2.那么在新建QT项目时，右上角应该会有Android的选项 
		3.我们选择新建Library->C++库，选择Android设备模板
	③在android studio中使用so动态库
		1.添加库
		2.声明调用方法
		2.编写jni调用文件
		3.调用方法	
▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁	
【二】Qt on android环境搭建
	①Qt5.9
		1.安装jdk101
		2.安卓android-sdk-windows, 并安装对于的平台SDK
		3.安装android-ndk-r12b
		4.安装apache-ant-1.9.7
	②Qt5.12
		1.安装jdk201
		2.安卓android-sdk-windows,并安装对于的平台SDK
		3.安装android-ndk-r18b
▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁	
【三】构建安卓程序
	①选择对应的编译器
	②添加库（注意）
		1.去掉LIBS前面的前缀
		2.选择对应安卓硬件的SDK
			1.项目->build->Build Android APK->Android build SDK
			2.比如: 安卓armv7-eabi选择android-25
		3.构建项目时，将依赖的安卓库添加到构建的包中
			1.项目->build->Build Android APK->Additional Libraries
			2.将引用的所有安卓库都添加到项目中
			3.注意: 库路径要与pro文件中指定的库的路径一致
	③Qt android 添加opencv库			
		https://blog.csdn.net/qq_38813056/article/details/97651089
	
	
#####################################################################################	
#####################################################################################	
(2)QCoreApplication::processEvents();的作用
	1.来由: 如果我们在某个槽函数中写while(1)时,界面肯定卡顿, 因为他阻塞了其他消息、事件等。
		比如： 
		void Widget::on_pushButton_clicked() 	
		{	int i;
			while(1) {
				qDebug()<<i++<<endl;	
				QThread::sleep(1);		// 导致界面卡死
			}
		}
	2.我们要在循环中, 反复调用QCoreApplication::processEvents();
		明确要求Qt在计算的某些时刻处理等待事件
		void Widget::on_pushButton_clicked()
		{	int i;
			while(1) {
				qDebug()<<i++<<endl;
				QCoreApplication::processEvents();
				QThread::sleep(1);		// 界面不会卡死, 挂起过程中,系统能捕捉信号
			}
		}
#####################################################################################	
(3)Qt for Android 适应手机屏幕
	1.将主界面配置为栅格布局
	2.布局之间使用弹簧连接
	3.其余默认设置
	4.主函数中使用: w.showMaximized();

#####################################################################################	
(4)窗口切换
①在主函数中使用对话框, 关闭对话框后回到主窗口
	1.添加一个设计师界面类Dialog
	2.在组函数中将widget的按钮和dialog的exec函数关联
	main.cpp
		#include "widget.h"
		#include "dialog.h"
		#include "ui_widget.h"
		MainWindow w;
		Dialog d;
		QObject::connect((w.get_ui())->bt, SIGNAL(clicked()), &d, SLOT(exec()) );
		w.show();
②满足某条件后, 从一个窗口widget跳到另外一个窗口widget2, 且关闭之前的窗口widget
	1.添加一个设计师界面类widget2
	2.在widget中添加信号函数声明signal()
	3.在主函数中将signal()和widget2的show关联
	4.在widget里面, 如果某种条件满足就发送信号signal()。
#####################################################################################	
(5)时间和日期
①QTime
	[1]功能:QTime类提供时钟时间功能。
	[2]注意:
		1.QTime使用24小时时钟格式;它没有AM / PM的概念。
		2.QTime对时区或夏令时（DST）一无所知。
		
	[3]获取当前时间
		// qDebug()<<QTime::currentTime().toString("hh:mm:ss");
		
	[4]QTime提供了一整套运算符来比较两个QTime对象。
		如果A早于B，则QTime A被认为小于QTime B.
		/*	 QTime t1(0,1,1);
			QTime t2(0,2,2);
			qDebug()<< (t1 < t2);	// ture */
			
	[5]提供给定时间的给定秒数或毫秒的时间。
		addSecs（）和addMSecs（）
		/* QTime t1(0,1,1);
			QTime t2 = t1.addSecs(5);	// 增加了6秒钟
			qDebug()<<t2.toString("hh:mm:ss");	// "00:01:06"
		*/ 
	[6]测量经过的时间跨度
		(1)void start() // 将调用者(QTimer对象), 设置为当前时间
		(2)int restart()// 将调用者(QTimer对象), 设置为当前时间, 且返回上一次电泳start()或者restart的时间
		(3)int elapsed() 	// 返回自上次调用start（）或restart（）以来经过的毫秒数。
			注意: 在最后一次调用start（）或重新启动后24小时，计数器将回零。
		例: 测量程序运行的时间:
			QTime t1;
			t1.start();				
			QThread::sleep(1);
			qDebug()<<t1.elapsed(); // 1001
	
	[7]将QTimer转换为字符串
		QTime t1(0,1,1)
		qDebug()<<t2.toString("hh:mm:ss");	// 显示: 小时:分钟:秒
		qDebug()<<t2.toString("mm:ss");		// 显示: 分钟:秒,
		........
▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁
②QData
	1.QDate类提供日期函数。在公历中，QDate对象包含日历日期，即年，月和日数。它可以从系统时钟读取当前日期。
	2.它提供了比较日期和操作日期的功能。例如，可以在日期中添加和减去天，月和年。
	3.通常通过明确给出年，月和日数来创建QDate对象。
		请注意，QDate按原样解释两位数年份
	4.QDate也可以使用静态函数currentDate（）构造，它创建一个包含系统时钟日期的QDate对象。
	5.也可以使用setDate（）设置显式日期。
	6.fromString（）函数返回给定字符串的QDate和用于解释字符串中日期的日期格式。
	7.year（），month（）和day（）函数提供对年，月和日数的访问。
		此外，还提供了dayOfWeek（）和dayOfYear（）函数。
		toString（），shortDayName（），longDayName（），shortMonthName（）和longMonthName（）函数以文本格式提供相同的信息。
	8.QDate提供了一整套运算符来比较两个QDate对象，其中较小的表示较早，较大表示较晚。
	9.您可以使用addDays（）将日期增加（或减少）给定的天数。
	10.您可以使用addMonths（）和addYears（）。 daysTo（）函数返回两个日期之间的天数。
	11.daysInMonth（）和daysInYear（）函数分别返回此日期的月份和年份中的天数。
	12.isLeapYear（）函数指示日期是否处于闰年。
▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁
③QDateTime // 包含(QDate和QTime两部分)
(1)获取自1970-01-01T00：00：00 Universal Coordinated Time以来经过的秒数。
	[static] qint64 QDateTime::currentSecsSinceEpoch()
(2)获取自1970-01-01T00：00：00 Universal Coordinated Time以来经过的毫秒数。
	[static] qint64 QDateTime::currentMSecsSinceEpoch()
	

#####################################################################################	
(8)Qt的源码目录
①qtbase->src  	// 核心源码, 里面分很多模块
	1.corelib->arch里面表示支持哪些设备	
②查看QT的测试文件
	在源码中搜索tst_classname 文件
③QT模块测试
	F:\资料光盘\systems\qt-everywhere-opensource-src-5.6.0\qtbase\examples
	

###############################################################################################################################	
QTextCodec(编码转换)
(1)概述
	1.Qt使用Unicode来存储，绘制和操作字符串。
	2.Qt提供了一组QTextCodec类，以帮助将非Unicode格式转换为Unicode和从Unicode转换。
	3.查看window的编码方式: 
		在命令行中输入chcp, 如果返回936就表示时GBK编码
(2)编码转换
	①本地编码转换为Unicode
		QByteArray encodedString = "...";
		QTextCodec *codec = QTextCodec::codecForName("GB18030");	// 创建编码器, GB18030: GBK(window上的编码)
		QString string = codec->toUnicode(encodedString);		// 用编码器进行转换
	②Unicode转换为本地编码
	  QString string = "...";
	  QTextCodec *codec = QTextCodec::codecForName("GB18030");
	  QByteArray encodedString = codec->fromUnicode(string);
###############################################################################################################################	
给APP添加图标
	①添加运行图标
		1.添加资源文件
			1.添加资源文件->添加前缀pic->添加图片
		2.在man函数中
			 QApplication a(argc, argv);
			a.setWindowIcon(QIcon(":/pic/111.jpg"));
	②添加exe文件的图标
		// 看Qtcreater快速入门(打包)
###############################################################################################################################	
APP程序打包:	// 目的: 让没有安装Qt的电脑也能运行程序
①window程序打包(看我发布的博客)
	一、找到SerialPort.exe的路径，并复制该路径。
	二、按下win+Q（win10）打开Windows搜索框，输入qt，就很容易找到qt 5.12.0 for desktop，然后打开。
	三、进入需要打包软件的路径
	四、输入windeployqt app_.exe
		1.点击app_.exe如果程序还是缺少库, 就把相应编译器目录下面的库拷贝过去
	五、使用免费打包软件Engima Virtual Box。
		
②Linux程序打包		// 看书: Qt5开发实战17章
③Android程序打包    // 看书: Qt5开发实战17章

###############################################################################################################################	
为生成的库添加依赖库
	一、找到SerialPort.库的路径，并复制该路径。
	二、按下win+Q（win10）打开Windows搜索框，输入qt，就很容易找到qt 5.12.0 for desktop，然后打开。
	三、进入需要打包软件的路径
	四、输入windeployqt lib*.库

###############################################################################################################################	
Qt程序移植到开发板笔记.doc (粤嵌)	
###############################################################################################################################	
Qt工程中引用C源文件和头文件
(1)概述
	1.在引用c文件的函数中用extern "C" {}声明C头文件, 且.h文件中不需要做任何修改
	注意:
		1.c文件中不能包含C++头文件, 和引用c++函数。
		2.如果.c文件中要引用C++头文件或者c++函数, 则需将.c函数改为cpp文件, 且.h文件中不能在extern "c" {}中声明cpp文件中的函数
	
(2)示例
	main.c
	extern "C" {
		#include <json/cJSON.h>
		#include <json/hilink_cJSON.h>
	}
		
		

###############################################################################################################################	

						Qt项目笔记
###############################################################################################################################	
							
							
###############################################################################################################################	

做的计算器
###############################################################################################################################	
做QQ登录界面:







		
		
		
		
	