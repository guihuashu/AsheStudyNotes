基础:
	1.如果想返回引用, 那么被返回的类不能是本函数的局部变量(函数退出后, 这个局部变量就销毁了)
	2.将const对象1, 拷贝为对象2, 此时对象2不是const变量
	3.类名(): 会调用这个类的构造函数, 去实例化一个对象, 但是这个对象没有名字
				用处: throw 类名();		// 这会抛出一个类对象
	4.局部变量保存在栈里面
	5.delete一个指针后, 该指针所指向的内存被释放, 但是这个指针的地址不变
难点:
	1.只含有成员函数.构造函数.析构函数.的类对象占一个字节 (里面只含有this指针)
		函数放在代码段中不消耗内存
	2.就算不定义对象也可以调用类中的静态函数( 因为调用静态函数不需要this指针;)
		但是没有对象时,不能直接调用类中的成员函数
	3.函数指针要占用内存, 因为函数指针也是个变量


程序架构:
	1.类的声明放在.h文件中
	2.类中函数的实现放在同名的.cpp文件中
	3.当定义的多个类时, 若发现有共同函数和数据成员时, 就将这些共同的函数抽象到一个基类中
	4.为了实现多态要将基类中的函数声明为虚函数(创建对象时建立虚函数表和本类信息.继承信息)
	5.为了让基类不能定义对象, 将基类中的函数声明为纯虚函数(仅向下提供框架, 向上提供统一接口);
		1.纯虚函数只需要在基类中声明, 不需要在基类中实现
		2.有纯虚函数的类不能有构造函数和析构函数, 因为抽象类不能实例化对象
	6.要让所有的析构函数为虚函数, 为了(一个基类类型数组里面有多个子类指针, 然后去销毁基类指针时)
		能够实现析构函数的多态
	7.一个完整程序分为两部分: 类编程 应用编程
		1.将类编程编译成动态库
			Human: main.o libHuman.so
				g++ -o $@ $< -L./ -lhuman		// 将libHuman.so编译进去
			libHuman.so : Eng.o Chin.o Human.o
				g++ -shared -o $@ $^
			%.o : %.cpp
				g++ -fPIC -c -o $@ $<
			说明:
			-L:指定库目录
			-fPIC:  编译时将库用作位置无关码库进行使用
			shared: 链接为动态库
		2.程序运行时: 在前面加上 LD_LIBRARY_PATH=./ ./APP		// 告诉APP库在哪儿
		3.带来的好处: 
			1.我修改库时, 只需要重新编译库, APP就可直接执行
				make libHuman.so
			2.修改应用程序后执行make时, 只会重新编译app部分, 
				因为libHuman.so从时间上不会更新, 也就不会重新编译
		4.为了修改子类的头文件文件后,程序不崩溃, 引入抽象类界面
		//(因为app中包含了子类头文件, 编译app是是用的修改前的子类头文件, 很可能造成内存越界)
	8.当使用抽象类界面后, 应用成通过基类中声明的函数去动态创建子类对象;
	  然而这个动态分配的子类对象实时基类的引用(因为这个函数在基类中声明);
	  为了引用层去销毁这个子类对象时, 子类对象的析构函数能够被调用,
	  所以: 需要将基类的析构函数设置为虚函数(子类的析构函数自动变成虚函数)
		
###########################################################################
①访问控制:
	private: 	只供类内部的函数使用(默认)
	protected:
	public:		类外面的代码也可以使用
	1.外部函数不能直接访问类中的私有成员
	2.如果要想在外部程序中访问类中的私有成员, 必须通过类中的函数来间接访问(因为类中的函数可以操作私有成员)
	3.可以在类的成员函数中使用this来表示当前对象指针(this->name = name)
②程序结构
	1.定义类时, 在类里面声明成员函数(func();), 在类外面实现成员函数(class_name::func)
	2.程序结构
		实现类的定义: class_name.h	 	 // 定义类定量,声明成员函数(这是给main函数看的, 他不关心成员函数的实现)
					  class_name.cpp	 // 类成员函数的实现实现
		对类的引用:   main.cpp
③命名空间:(解决名字冲突的问题), 类似于c语言的static作用域
	0.基础:
		1.把一些全局实体分别放在各个命名空间中, 从而与其他全局实体分割开来
		2.命名空间可以嵌套定义
	1.为什么要使用命名空间?
		比如: A在person.cpp中定义了函数print_verson() (非成员函数)
			  B在dog.cpp中也定义了函数print_verson()  (非成员函数)
			  现在我要在main中调用dog.cpp中的print_verson()函数, 怎么办? 只有使用命名空间
	2.使用命名空间成员的方法
		1.命名空间名::成员名
		2.使用命名空间别名
			namespace TV = Television	// TV与Television等价
		3.using 命名空间名::成员名
		4.using namespace 命名空间名
	3.命名空间的声明和使用(例如QT的头文件)
		// 声明一个UI空间里面有一个cls类
		namespace UI{
			class cls;
		}
		class ui_cls{
		public:
			int i;
			void test()
			{    cout<<"test\n";}
		};
		// 在UI空间里面实现前面定义的cls类
		namespace UI {
			class cls : public ui_cls{};
		}
		int main(int argc, char *argv[])
		{
			// 使用UI空间里面的cls类定义一个对象
			UI::cls s;
			s.test();   // test
		}
	
#########################################################################################
函数的默认参数
	1.传入参数时:调用函数使用传入的参数。 不传入参数时: 调用函数使用默认参数
	2.默认参数 必须从后到前连着写, 因为传入的参数是按顺序传入的
	3.可以是连续的多个默认参数
	void func(int c = 5)
	{
		cout<<"c="<<c<<endl;
	}
	int main(int argc, char **argv)
	{
		func();		// 5
		func(3);	// 3
	}
#########################################################################################
函数重载(函数名相同)
	1.参数类型不同
	2.参数数量不同
	3.参数顺序不同(至少有两个参数的类型不同)
#########################################################################################
引用
(1)左值引用
	1.引用和要绑定的对象严格匹配
		int a=5;
		int &b = a;
		int &b = 111;		// 非法
		double &b = a;		// 非法
	2.const应用允许引用时类型不一致。
		1.当赋值的对象和被引用对象的类型不一致时，系统会生成一个临时变量来赋值。
		2.由于真正引用的是临时对象，所以定义的引用不能修改临时变量的值，
			所以为必须应用对象为const类型。
		double val = 3.14；
		const int& r1 = val；
		实质是：
			//double val = 3.14；
			//const int temp = val；
			//const int& r1 = temp;
	3.const引用的值不是临时变量时, 引用的值会被修改。
		int a=5;
		const int &c = a;
		a = 3;
		cout<<c<<endl;	// 3
	4.const引用的值是临时变量时, 引用的值不会被修改。
		int a=5;
		const double &d = a;	// const double tmp = a=5;	const double &d=tmp;//5 
		a=3;
		cout<<d<<endl;	// 5
(2)右值引用
	1.右值引用只能引用不同类型的对象或者数值
		int a=5;
		int c = 2;
		int &&b=a;			// 这是不合法的
		double &&b=a;		// 合法
		double &&b=a + 3;	// 合法
		double &&b=a + c;	// 合法	
		int &&i = 111;		// 合法
	2.右值引用的值不会被改变
		int a=5;
		double &&b=a;
		a=3;
		cout<<b<<endl;	// 5
	3.右值引用可引用两个不同类型数据的操作
		int a=5;
		char c = 2;
		double &&b=a + c;
		a=3;
		c = 3;
		cout<<b<<endl;		// 7


#########################################################################################
构造函数
	0.构造函数没有返回值, 并且也不能用void来修饰
	1.构造函数是一个跟类名相同的函数
	2.构造函数可以被重载(用于初始化不同的对象)
	3.构造函数用于在定义对象时对对象进行初始化 <==> 调用对象中的构造函数
	4.定义对象时若想调用无参的构造函数
		要使用:		Person person;
		不能使用:	Person person();	// 因为这是一个函数的声明(int func(void);)
	5.构造函数的形参可以设置默认值; 但是如果一旦设置默认值的构造函数,就不能同时存在比他少一个参数的构造函数
		比如:  class Person
				public:
					int a;
					int c;
					Person(int a, int c = 5);
					Person(int a)	// 这是错误的
				main
					Person p1(5);	// 因为:上面的两个构造函数都可以调用, 出错
	6.	person *p1 = new Person;
		person *p1 = new Person();	// 这两个函数等价, 都会调用无参的构造函数
	7. 如果不存在构造函数, 系统默认提供一个空函数
⑥析构函数
	0.析构函数最多一个, 也可以没有
	1.析构函数名称为: ~类名
	2.析构函数没有参数, 没有返回值, 也不能用void进行修饰
	3.在实例化的对象被销毁前的一瞬间, 系统自动调用析构函数
	4.后创建的对象先销毁
	5.虽然程序退出时会释放new动态分配的内存, 但是不会调用对象的析构函数
		所以: 用new动态分配的对象, 必须使用delete释放时才会调用他的析构函数,
	6.如果不存在析构函数, 系统默认提供一个空函数	
⑦拷贝构造函数
	1.拷贝一个对象时, 不会调用对象的构造函数, 而是调用函数的拷贝构造函数
	2."浅拷贝": 我们没有实现拷贝构造函数, 拷贝时调用了系统的默认拷贝构造函数
		1.仅对类的类中的空间进行复制
		2.对于类中动态分配的空间在堆中,不属于类的空间, 所以拷贝时仅拷贝指针, 
			两个的对象指针指向堆中的同一块内存
		1.直接拷贝变量
		2.如果类
	3."深拷贝"
		1.不仅拷贝对象本身的空间, 还要拷贝对象成员指向的堆空间

	2.为什么需要自己的拷贝函数(而不使用默认的?)
		Person p2(p1)会进行值拷贝
		对于数值, 将开辟一块内存来存储拷贝的数值
		对于字符串, 将开辟一个字节, 指向p1中的字符串"str"
		比如: 
			  p1.name指向"str"
			  Person p2(p1)后: 	p2.name也指向了"str"
		==>由上分析可知: 当释放对象p1时会释放"str"
					     当释放对象p2时会再次释放"str"
					     ==>这就造成了同一块内存释放了两次, 所以需要我们自己的默认拷贝函数
		3.拷贝函数的参数为: 对象的引用
		4.我们必须在拷贝构造函数中对指针变量重新分配
		5.拷贝构造函数的参数为(const Person &p)
			1.为什么要加const?
				比如: const Person p1;
					  Person p2(p1), 
					  如果没有参数中没有const, 那么传入拷贝构造函数的参数是const p1, 无法将const转变为可读可写
	3.什么时候调用拷贝构造函数
		A a;
		1. A c(a);
		2. A c = a;		// 等价于1.
		3. A *c = new A(a);
		4. 注意: 先定义, 再等于将不会调用拷贝构造函数, 因为这仅仅是赋值
			A c;
			c = a;
			
			
			
				  
⑧对象的构造.销毁顺序
	1.构造顺序
		1.全局对象在main函数执行前构造
		2.遇见哪个对象就构造哪个, 但是static对象只会被创建一次
	2.销毁顺序: 
		1. 子函数退出时销毁局部对象
		2. main函数中的局部对象
		3. 子函数中的static对象
		4. main函数中的static对象
		5. 全局对象
	3.对于含有对象成员的对象:
		1.先创建对象成员, 再实例化对象(只有先构成部分才能组合整体)
		2.先调用对象的析构函数, 再调用对象成员的析构函数(先要瓦解整体才能销毁部分)
		
⑨用参数列表对数据成员初始化 (给变量分配空间时直接赋值)
	// 而构造函数里面的内容是在对象被创建后才会执行
	class Person {
		int a;
		int b;
	public:
		Person(int a, int b) : a(a), b(b)
		{}
	}
	class T {
		int e;
		int f;
	public:
		Person(int e, int f) : e(e), f(f)
		{}
	};
	class Student : public Person{
		T t;
		int c;
		int d;
	public:
		Student(int a,int b,int c,int d,int e, int f) : Person(a,b),t(e,f),c(c),d(d)
		{}
	}
	int main {
		Student s1;
	}
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
类的对象大小 = 	非静态成员大小和 + 虚表指针(4字节)
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
(10)静态成员(static)
1.静态成员占用的是数据段的内存, 局部类对象的空间在栈中, 所以静态成员不占用类空间
	class P{
     static int a;	// 在数据段
	};
	main()
	{	P p;	// 在栈中
		cout<<sizeof(p)<<endl;	// 1
	}
2.静态成员在内外面初始化
	class P{
     static int a;	// 这个只是声明, 并没有在数据段分配空间, 直接引用会报错
	};
	int P::a = 100;
3.静态成员的空间时在类对象创建之前创建的, 所以可以不通过对象直接调用公有静态成员
	main()
	{cout<<sizeof(P::a)<<endl;}
4.也可以通过对象来访问静态成员, 这次修改对本类的其他对象是可见的(但是这个静态成员并不属于这个类)
    class P {
	public:
		static int a;
	};
	int main()
	{	P p;
		P p1;
		p.a = 3;
		p1.a = 5;
		cout<<p.a<<endl;	// 5
		cout<<p1.a<<endl;	// 5
	}
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
(11)静态成员函数
	1.静态成员函数先于类对象创建, 所以静态成员函数中不包含this指针，
	2.所以静态成员函数不能访问类中的非静态成员， 但是可以访问静态成员
	3.可通过类名和对象来访问静态成员函数
		1.类名::static_func();
		2.对象::static_func(); // 注意: 但这并不意味着静态成员函数属于这个对象, 只是借用了对象的类型而已
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
单实例模型：
	class Data
	{
	public:
		static Data *sharedData()
		{
			if(!instace)
				instace = new Data();
			return instace;
		}
	private:
		Data() {};
		Data(Data &d) {};
		static Data *instace;
	}
	Data* Data::instace = NULL
	应用:
		1.使整个应用只能创建一个对象
		2.对象间的数据传递(设计一个单实例的数据类)


xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
(12)友元函数(尽量避免使用)
	1.被声明为该类的友元函数可以直接访问该类的所有成员
	2.	1.将外部函数声明为友元函数
			public:
			friend int ex_func(int a);
		2.将其他类的成员函数声明为该类的友元函数
			public:
			friend int 类名::cin_func(int a); (这个函数的实现必须在该类的后面)
	3.友元函数里面没有this指针
(12.2)友元类
	1.在类A中声明类B为其友元类。
		那么类B中的所有函数都是类A的友元函数
	2.特点:
		1.友元是单向的
		2.友元关系不能传递
			
	
(13)双目运算符重载: 
	1.成员函数重载
		左值是函数调用者, 右值是函数参数
		class complex{
			complex operter+(complex &c2) ()
			{	// 构造一个c3然后返回
			}
		}
		complex c1(11, 11);
		complex c2(22, 22);
		complex c3 = c1 + c2;	// 实质是c1.opertor+(c2): 调用c1.opertor函数,参数为c2
	2.友元函数重载
		1.有原函数里面没有this指针, 所以需要把两个参数都传递进去
		2.左值为参数1,右值为参数2
		class complex{
			friend complex operter+(complex &c1,complex &c2)
		}
		complex operter+(complex &c1,complex &c2) 
		{	// 构造一个c3然后返回
		}
		complex c1(11, 11);
		complex c2(22, 22);
		complex c3 = c1 + c2;	// 实质是opertor+(c1, c2)

		0.cout的名称是ostream, <<的重载有两个参数(ostream &, 自定义)
	3.重载<<
		1.分析: 如果想在类里面实现cout, 那肯定是这样的(因为左值必须是一个对象)
			class complex{
				ostream& operter<<(ostream &out) ()
				{	out<<this->i<<this->j<<endl;
				}
			}
			c3<<cout; // 这显然不符合我们的使用习惯, 所以我们只能使用友元函数来重载运算符<<
		2.友元函数来重载运算符<<
			class complex{
				friend ostream operter<<(complex &c) ()
			}
			ostream& complex::operter<<(ostream &out, complex &c)
			{	out<<c.i<<c.j;
				return out;
			}
			cout<<c3<<endl;
	4.重载>>, 跟重载<<一样, 只能使用友元函数来重载
			class complex{
				friend istream operter<<(complex &c) ()
			}
			istream& complex::operter<<(istream &in, complex &c)
			{	in>>c.i>>c.j;
				return in;
			}
			cout<<c3<<endl;
	5.重载[]
		class A{
			int arry[10];
			int &operator[](int i)
			{	return (this->arry)[i];
			}
		}
		A a;
		a[0] = 100;
		

(15)const成员函数
	const对象的成员函数必须在函数名尾部声明const关键字, 才能被调用 (表明此函数没有修改操作)
##########################################################################################################
(16)继承访问控制
	1.派生类不能直接访问基类的私有成员(儿子不能直接去拿私房钱)
	2.派生类可以调用基类的公有函数来设置基类的私有成员(可以向父亲索取私房钱)
	3.派生类可以访问基类的protect成员, 外界不能访问基类的protect成员(儿子和外人的区别)
	
(17)using调整继承访问控制:
	派生类可见的部分(protact private), 派生类可以修改他的权限. 
	class Son {
	private:
		using Father::room_key	(儿子将家里的钥匙私藏起来)
	protect:
		using Father::room_key  (儿子将父亲房间的钥匙传给孙子)
	public:
		using Father::room_key	(儿子将父亲的房间钥匙公之于众)
		
(18) 继承与派生的概念
	1.派生类继承了基类的所有数据成员和成员函数(书)
	2.可以在派生内中声明一个与基类同名的成员, 来覆写基类成员
		但是, 可以在基类中显式的引用被覆写的成员: father::be_overide_func()
	3.派生类不能从基类中继承构造函数和析构函数
	4.基类的私有数据成员也继承到了派生类中, 但是他在派生类中不可见
	5.不同的继承方式只会影响, 从基类中继承来的成员属性
	6.如果不指名继承方式, 那么默认是私有继承
	
(19)基类成员在派生类中的访问控制属性
		-----------------------------------------------------------------------------
		|基类访问属性:(→)|	public					protected		private														|
		|继承类型(↓)	  		|																														|
		|---------------------------------------------------------------------------|
		|public		  	 			|	public					protected		隔离(但是继承到了派生类中,只能通过继承的父类成员函数访问)| 
		|protected	  	  		|	protected   			protected		隔离(但是继承到了派生类中,只能通过继承的父类成员函数访问)| 
		|private	  	  			|   private 				private				隔离(但是继承到了派生类中,只能通过继承的父类成员函数访问)| 
		-----------------------------------------------------------------------------
(20)派生类的内存分布
		基类			   		  派生类
	public:							print("s") // 隔离, 继承于父类	
		print("p")				public:
									print() 	// 覆写基类的成员函数
   1.可以在派生类中显式的调用基类的成员函数
		基类::print()
   2.当形参为基类, 传入的是派生类。这是被调函数使用的是派生类中的基类部分
		void func(基类 &p)	{ p.print(); }
		int main()
			派生类 s;
			s.print();	// 打印"s", 调用的是派生类中的复写函数
			func(s);	// 打印"p", 传入的是派生类中的基类部分
(21)直接多重继承(尽量避免)
	1.被继承的不同两个基类含有同名成员时, 派生类具有二义性
	2.要想使用派生类中的同名成员, 必须加上基类对象名
		safa_bed.safa::widgh = 5;
	3.多重继承派生类的构造函数
		派生类构造函数名(参数): 基类1构造函数名(参数) , 基类2构造函数名(参数).....
		{派生类中新增数据成员初始化}
(22)虚基类(虚继承)
	0.当进行类A虚继承于B， 当创建类A的对象时a,会在a对象的B基类部分中建立一个虚表(占4字节)。
	1.虚基类是在声明派生类时, 指定继承方式中声明的(因为一个基类可以作为虚基类被继承, 也可以作为普通基类被继承)
	2.当虚基类通过多条派生路径,最后被一个派生类继承时, 最后的派生类只继承该基类一次(基类成员只保留一次)
	3.比如虚基类的声明初始化
		class A {int i};
		class B : virtual public A{};	// b继承于a
		class C : virtual public A{};	// c也继承于a
		class D : public A, publicB{};	// 但是只会实例化一个对象a

(23)多重继承的构造顺序
	1.先基类后派生类
	2.先虚拟基类后一般基类
	3.派生类中先构造对象成员, 最后构造完整的派生类
	4.注意: 虚拟基类的构造函数只执行一次
############################################################################################
(24)多态的概念的引入
	1. class Human{				
		void eat() {"手"}	};
	   class Chines : pub Human{				
		void eat() {"筷子"}	};
	   class Japan : pub Human{				
		void eat() {"刀"}	};	
	   void test(Human &h)			/* 传入的是基类的部分 */
		{	h.eat(); }	
	   int main; {
		Human h;
		Chines c;
		Japan j
		test(h);		// "手"
		test(c);		// "手"	
		test(j);}		// "手"
		==> 这显然不符合多态的特性, 传入的都是基类的部分, 编译器无法分辨是哪一个派生类
(25)虚函数
	1.定义虚函数:再函数前加vartual关键字
	2.若类中有虚函数, 当实例化对象时,会在对象的最前面添加一个虚函数表, 里面记录着各个虚函数的地址。
	1.为什么要使用虚函数?
		实现多态性
	2.虚函数的作用:
		允许派生类中定义与基类同名的函数, 并且可以通过基类指针或引用来访问派生类中的同名函数
	3.由虚函数实现的"动态多态性": 同一类族中的不同类对象, 对同一函数调用做出不同的响应
	4.在基类中用vitual声明成员函数为虚函数, 这样就可以在派生类中重新定义此函数, 赋予新功能
	5.c++规定: 当基类中的某个成员函数被声明为虚函数后, 其派生类中的同名函数都自动成为虚函数
	6.c++规定: 当基类的析构函数声明为虚构函数时, 其派生类中的析构函数自动成为虚函数	
	7.当基类的函数不是虚函数, 但是在继承的子类中将覆写函数定义为virtual函数时,不能实现多态
	8.返回值, 函数名, 参数全一样时可以设置为虚函数; 
		例外: 当返回值是当前对象(或者基类或者派生类)的指针或者引用的时候可以设置为虚函数
		前提是: 编译能通过
		class Human{
			virtual Human& ret() {cout<<"Human: ret"<<endl;}
		class Chines : public Human{	
			Human& ret() {cout<<"Chines: ret"<<endl;} 	// 等价于下面一句,多态
		class Japan : public Human{
			Human& ret() {cout<<"Japan: ret"<<endl;}		// 等价于下面一句,多态
		==> 因为派生类的引用返回, 实际上是返回的基类引用和指针
		
	8.注意事项:
		1.被调函数的形参为基类的指针和引用时才会有多态现象, 当传入值时没有多态。为什么?	
			答: 形参为基类时: 传入的是对象中的基类部分, 调用的虚函数永远都是基类中的虚函数
		2.类里面的函数才能声明为虚函数
		3.静态函数不能是虚函数
		4.内联函数不能是虚函数
		5.构造函数不能是虚函数(创建对象时马上就会调用,不需要多态)
		6.析构函数一般都声明为虚函数(当用基类指针表示派生类对象时, 释放这个指针不会调用派生类的析构函数, 只会调用基类的虚构函数)
		7.重载函数不能为虚函数(多态是相同的调用方法, 重载是不同的调用方法(参数不同))
######################################################################################################
虚函数表:	( 剖析多态的实现过程 )
(1).当类P中有虚函数时, 实例化对象p时会在p对象的最前面创建一个虚函数表。（表中记录着虚函数的地址）
	1.若P中有多个虚函数， 那么在虚函数表会同时记录多个虚函数的地址
		class P{
			int i;
			public:
				virtual void show() {};
				virtual void show2() {};
		};
		int main(int argc, char *argv[])
		{   P p;
		   p.show();	// 设置为断点
		   return 0;
		}
	2.调试显示: 
	 p	@0x29fe20	P
		[vptr]	_vptr.P	 						// 虚函数表
			[0]	0x402e54 <P::show()>	void*	// 记录着第一个虚函数的地址
			[1]	0x402e60 <P::show2()>	void*	// 记录着第二个虚函数的地址
		i	-2	int								// 这是是有变量
(2)若P为基类,且P中有存在虚函数f；P1继承于P。实例化一个对象:P1 p1
	1.组成p1的第一部分为P对象, 在P对象的最前面有一个虚函数表: 记录着虚函数的地址和所属类信息
	2.如果是虚继承, 会在虚表中记录虚继承信息
	3.若在派生类P1中没有覆写基类P中虚函数f:
		那么此时虚函数表中记录的是基类P中的虚函数f
	4.虚表中同名的函数有且仅有一个
	5.若在派生类P1中覆写了基类P中虚函数f:
		1.那么此时虚函数表中记录的函数f是P1中的虚函数函数f
		2.由于派生类虚函数表记录在基类部分的最前面, 所以将派生类的基类指针或引用指赋值给基类后,也能找到虚函数表
			又因为对象中的虚函数执行完全是根据虚函数表中的记录情况来执行的, 所以能实现多态
		3.程序例证:
			class P
			{   virtual void show() {cout<<"show_P"<<endl;}
				virtual void show2() {cout<<"show2"<<endl;}
			};
			class P1 : public P
			{   virtual void show() {cout<<"show_P1"<<endl;}
			};
			int main(int argc, char *argv[])
			{
				P1 p1;              // 定义一个派生类对象p1
				P &p = p1;          // P1的基类部分赋给p
				P *pp = (P *)&p1;   // P1的基类部分付给PP

				// p1的虚函数表存放在基类对象的最前部分, 所以就算将派生类赋给基类, 也然能找到虚函数表
				p1.show();          // 覆写后虚函数表中记录的是派生类的show函数
				p.show();           // 覆写后虚函数表中记录的是派生类的show函数
				p1.show2();         // 未覆写,虚函数表中记录的是基类的show2函数
				p.show2();          // 未覆写,虚函数表中记录的是基类的show2函数
				pp->show();         // 覆写后虚函数表中记录的是派生类的show函数
				pp->show2();        // 未覆写,虚函数表中记录的是基类的show2函数
			}		
			1.虚表的存储结构	
				p1	<无法访问>	P1 &						// 派生类对象
					[P]	<无法访问>	P						// 包含基类对象	
						[vptr]	_vptr.P	 					// 基类对象部分的最前面有虚函数表
							[0]	0x402ef8 <P1::show()>		// 被覆写的虚函数在表中是派生类的函数
							[1]	0x402ec4 <P::show2()>		// 未被覆写的虚函数在表中是基类的函数
				p	<无法访问>	P1						// 被赋值的基类对象				
					[P]	<无法访问>	P
						[vptr]	_vptr.P	 
							[0]	0x402ef8 <P1::show()>	
							[1]	0x402ec4 <P::show2()>	
				pp	<无法访问>	P1						// 被赋值的基类对象指针
					[P]	<无法访问>	P
						[vptr]	_vptr.P	 
							[0]	0x402ef8 <P1::show()>	
							[1]	0x402ec4 <P::show2()>	
			
			2.执行结果
				show_P1
				show_P1
				show2
				show2
				show_P1
				show2
			

	
######################################################################################################
		
(26)编译机制	
	1.静态联编: 编译时就确定了具体要调用的函数			// 非虚函数
	2.动态联编: 程序运行时才能确定具体要调用哪个函数		// 虚函数
	3.动态联编是怎么实现的?
		1.若类中有虚函数, 在创建对象时, 会建立虚函数表, 虚函数表中还含有本类信息和继承信息;
			对象中有个指针指向指向虚函数表中的虚函数和类信息。
		2.使用虚拟继承时也会构造虚函数表
		2.在动态转换和多态时， 会根据这个指针去找到他的类信息和虚函数
######################################################################################################
(27)类型转换
1.隐式类型转换(由编译器实现)：
	1.int i = 100.1			// i = 100
	2.int *p = "abcd"		// 指针转换为int型, 通过指针p可以访问到4个字节
2.显式类型转换
	1.int i  = (int)100.1			// i = 100
	2.int *p = (int *)"abcd"		// 指针转换为int型, 通过指针p可以访问到4个字节
3.C++的类型转换
	1.强制类型转换(相当于c语言中的强制类型转换)
		reinterpret_cast<int *>(str)
	2.去掉str的const和volatile属性
		const_cast<char *>(str)			// 类型转换函数其实是模板函数
	3.动态类型转换(在实现多态的调用函数中, 将基类引用转换为派生类)
		1.多态_FUNC(基类的指针) {
			Chinese *c;
			c = dynamic_cast<Chinese *>(&基类)	
		或者c = dynamic_cast<Chinese&>(基类)	// 不推荐,转换失败后,c不存在, 程序崩溃
		  }
		2.动态转换的作用:
			在实现的多态函数中, 对形参(基类)动态转换为派生类, 来分辨当前形参的派生类类型
		3.能动态转换的原因
			1.若类中有虚函数, 在创建对象时, 会建立虚函数表, 虚函数表中还含有本类信息和继承信息;
				对象中有个指针指向指向虚函数表中的虚函数和类信息。
			2.在动态转换和多态时， 会根据这个指针去找到他的类信息和虚函数
		4.动态类型转换只能用在含有虚函数的多态函数中(没有多态要动态转换干什么?)
		5.动态类型转换能从二级派生类转换为一级派生类， 等...（因为虚函数表中含有本类信息和继承信息）
		6.动态类型转换中经常使用指针, 而不使用引用
			因为: 使用指针时,我们可以判断指针来判断是否转换成功
				  使用引用时,如果转换失败,则定义的引用变量相当于没有初始化, 就会报错 (比如将中国人转换为英国人)
		8.非继承关系的对象将不能进行动态转换 
		9.不能进行上行转换: 将派生类转换为基类
		10.可以进行多级上行转换
5.静态类型转换(基类和派生类之间的转换)
	1.
	classb	b= static_cast<classp *>(&objp);	// 上行转换, 安全
		转换为基类后, 调用虚函数时, 调用的是派生类的虚函数(保存了多态性)
	classp	p= static_cast<classb *>(&objb);	// 下行转换, 不安全(没有动态类型转换, 不符合逻辑)
		转换为派生类后, 调用虚函数时, 调用的是基类的虚函数(没有多态性)
	2.是在程序进行编译时进行转换的, 不能用于多态 (多态的类类型是在程序运行时确定的)  
	3.非继承关系的对象将不能进行静态转换 
6.上行转换: 对象将派生类对象转换为基类对象
  下行转换: 将基类对象转换为派生类
######################################################################################################
(28)抽象类
	1.引入:
		做一个"各个国家的人"的调查: 饮食.穿衣,开车...
		1.基类里面不想写出那些函数, 因为我不会定义基类对象, 所以基类里面空函数我都不想写
	2.库
		virtual func = 0
	3.一个类里面含有纯虚函数后, 这个类就变成了抽象类
	4.抽象类不能实例化对象
	5.如果子类没有覆写完所有的纯虚函数, 则子类还是抽象类
	6.作用: 向下提供框架, 向上提供统一的接口
	7.子类在实现纯虚函数的过程中任然不能直接使用基类的私有成员
(29)抽象类界面
	1.为什么要用抽象类界面: 
		为了修改子类的头文件和子类的cpp文件后,程序不崩溃, 引入抽象类
		//(因为app中包含了子类头文件, 编译app是是用的修改前的子类头文件, 很可能造成内存越界)
	2.抽象类界面: 1.让APP只基类头文件
				  2.在基类头文件中声明创建子类的函数
				  3.在子类中实现创建子类的函数
					1.用new创建对象(如果定义对象, 该对象是一个局部变量)
					2.返回基类引用
				  4.app调用基类中声明的函数来动态分配子类对象, 用完后要delete
	3.引入抽象类后的不同
		没有抽象类:
			应用部分是根据老的子类头文件编译的, 实例化对象时, 对象的类型为
			老子类头文件文件中的类型
		有了抽象类:
			应用部分只包含基类头文件, 我们实例化对象时, 是根据老基类头文件中的
			函数去调用子类中的函数来动态分配的; 就算你修该了子类头文件,
			也不会影响到应用部分, 因为应用部分是通过调用基类头文件中的函数
			来动态分配的
##############################################################################################			
(30)函数模板(可重载)
	注意:编译时所有模板的类型必须确定下来，否则报错
	1.引入:
		比如:我们写一个mix函数
		1. int& max(int &a, int &b)			// 比较整数
			  return (a>b ? a : b)	
		   float& max(float &a, float &b)	// 比较浮点
			  return (a>b ? a : b)	
		   char& max(char &a, char &b)		// 比较字符
			  return (a>b ? a : b)	
			.........
		难道我们有一千种变量类型, 难不成我要重载一千次?
		更关键的是: 这些函数的函数体一样, 只有参数返回值不一样, 显然重载一千次不合理
	2.格式		  
		template<typename T>	
	    T& max(T &a, T &b)		// 比较字符
		{	cout<<__PRETTY_FUNCTION__<<endl;	// 查看编译器生成的当前模板函数的类型
			return (a>b ? a : b);	}
			
		main ()
		{	int ia=1, ib=2;
			float fa=1.1, fb=2.1;
			max(ia, ib);
			max(fa, fb);	}
		// 注意:一个模板类型只适用于一个函数
	3.内部机制
		1.模板函数只是编译指令, 一般放在头文件中
		2.编译程序时: 编译器会根据传入的参数来"推导"出模板函数的参数, 然后生成具体的模板函数
			比如: max(ia, ib)调用时, 编译器会生成如下模板函数
					int& max(int &a, int &b)		// 比较字符
						{  return (a>b ? a : b); }	
			这个过程称为模板的实例化 
		3.调用模板函数过程中: 传入了多少种类型, 编译器就会实例化多少个模板函数
		4.在模板函数中: 可以输出宏 __PRETTY_FUNCTION__, 来查看编译器生成的当前模板函数的类型
	4.编译器推导模板函数的过程
		1.苛刻的匹配类型
			1.传入的参数类型必须和模板里面的参数完全匹配
				并且: 模板函数里面的所有参数和返回值的类型页必须相同
			2.如果不能直接匹配, 则进行"有限的类型转换"
			3.如果还不匹配,则推导失败
		2.有限的类型转换
			只支持两种隐式类型转换, 其他的隐式转换都不支持
				1.const转换(传入可读可写, 模板函数形参为const, 返回值也必须为const)
					==> 缩小变量的权限(反过来则不行)
				2.传入数组时:
					1.模板函数形参为引用时: 传入的两个数组的长度必须相同
						参数被推导为const数组
						//因为模板函数func(char[a], char[a+n]), 编译器无法推导出模板函数的类型
					2.模板函数形参为指针时:  传入的两个数组的长度可以不相同
						形参被推导为指针
						//因为模板函数func(const char*a, const char*b), 编译器能推导出模板函数的类型
				3.当模板函数的形参为函数时
					不管传入的是函数还是函数指针都可以 (因为:函数会隐式的转换为函数指针)
		3.参数类型为值时:
			忽略实参的const, volatile等属性: 因为传值时, 会生成一个临时变量, 此变量可读可写
	5.可以定义2个模板
		template <typename T1, typename T2>
		T1 sub(T1 &a, T2 &b)
		{ return a-b;}
	6.如果定义了多个模板类型, 那么函数运行时必须确定模板的类型
		template <typename T1, typename T2, typename T3>	
		T1 sub(T1 &a, T2 &b)	// 这里会出错, 因为T3没有确定类型
		{ return a-b;}
	７．如果模板函数中的某些函数存在，优先使用存在的这些函数
			如果想调用模板函数，max<double>(a,b)
	
##############################################################################################			
(30)类模板(大量应用于容器类中)
	1.声明
		template<typename T>
		class AAA {
			T t;
		public:
			void test(T &t);
			void print();
		}
		template<typename T>	// 指出下面用到的T是一个模板类型
		void AAA<T>::test(T &t)
			{this->t = t;}
		template<typename T>	// 指出下面用到的T是一个模板类型
		void AAA<T>::print()
			{cout<<t<<endl;}
	2.实例化模板类
		AAA<int> a;
		a.test(5);
		a.print();
	3.订做(重载类模板中的某一种类型)
		template<>
		class AAA<int> {
			T t;
		public:
			void init(T &t);	// 任意写
			void abcd();		// 任意写
		}
		void AAA<int>::init(T &t)
			{this->t = t;}
		void AAA<int>::abcd()
			{cout<<"abcd()"<<endl;}
	4.模板类中可以有多个模板
		使用时: AAA<int, char> a;
	5.一般模板函数写在类里面。 若要在类外面实现，则必须要在同一文件实现， 否则报错
##############################################################################################			
(31)异常
	1.引入: 当非常深的子函数出错的话, 需要逐级判断返回值, 才能确定错误在哪儿, 这无疑增加了代码量, 和操作复杂性
		c语言的解决办法是: 实现长跳转: A:setjmp	C:longjmp
	2.c++使用异常来处理上述问题
		"函数A捕捉函数C发出的异常"
		1. A捕捉异常
		2. C抛出异常
		3. A做出异常处理
	3.格式
		throw 表达式;
		try {被检查的句子}
		catch(异常处理类型[变量名])
			{异常处理}
	4.说明
		1.如果运行try中的代码过程中抛出了任何对象或指针, 那么立即停止try中的运行(不自信)
			1.抛出引用可以
			2.抛出指针不可以
			为什么?
		2.抛出的异常可以是任何类型
		3.可以在catch中分辨抛出的类型来进行相应的处理
	5.注意:
	3.注意:
		1.抛出异常后, 会立即退出抛出异常所在的函数)
		2.如果被抛出的对象是个局部变量
			1.能抛出对象和对象的引用: 抛出引用时, 会复制一份对象然后再抛出
			2.不能抛出对象的指针:	  不会复制一份再抛出, 对象已经被销毁
		1.抛出对象int float char double之间不能进行隐式类型转换
		2.抛出的子类对象可以隐式转换为基类对象
		2.可以使用catch命令来进行多次捕捉
		3.使用catch (...) {} 来捕捉剩下的所有异常		//(除去已经捕捉的类型)
		4.当捕捉到抛出的一个对象后, 立即停止后面的捕捉。
			比如: 我抛出子类对象, 既捕捉基类对象, 又捕捉子类对象时, 只有其中一个能捕获到这个异常
				  谁在前, 谁就能捕获到
		5.在抛出异常的函数后面加上throw (类型1, 类型2), 来限定抛出异常的类型
		  //抛出限定的类型外的任何类型都会调用
			1.系统提供的默认异常处理函数(可自己提供) 
			2.程序异常终止函数(可自己提供)
			void func() throw(int, char)
			{	int a; char b; float c;
				throw a;
				throw b;
				throw b;
			}
		6.可以修改系统的默认异常处理函数
			set_unexpected (my_unexpected_func);
			作用: 用来处理声明之外的异常
				
		7.可以修改系统默认的程序异常终止函数
			set_terminate(my_set_terminate);
			作用: 1.用来处理声明之外的异常
				  2.处理catch分支未捕捉到的异常
				  
###########################################################################################
(32)智能指针
	1.引入:
		1.子函数中: 动态分配一个类指针p,程序退出时不会去自动销毁这块内存,这造成了内存泄漏
		2.存在着机制: B b = new A();
	2.思路:
		1.将动态分配的内存指针p,封装在类B的私有成员中
		2.使用B b = new A(); 将new A()创建的指针传入b的构造函数
		3.在B的构造函数里面对指针P进行赋值
		4.在B的析构函数里面delete指针P
		==> 函数退出时局部变量B的析构函数被调用, 又间接的调用的A的析构函数来销毁p
		这样就从源头上防止了内存泄漏
	3.注意:
		1.智能指针类的拷贝函数的形参要加入const, 不然会报错
	4.要在智能指针里面使用引用计数
	5.如果我们想通过对象b去访问p中的成员怎么办? (B不是继承于A)
		1.我们需要在类B中重载运算符->,让他返回类A的指针, 这样就:b->等价于p->
		2.可以重载*号和&符号, 让重载函数返回基本对象的指针或者引用
	6. 1.应该将智能指针里面的原对象设置为模板, 这个这个智能指针可以用在任何对象上
	   2.所有跟智能指针相关的函数都要声明为类模板
	   3.在实例化智能指针的函数中, 指明实例化的模板类型
	7.总结
		1.以后少用"Person *"
		2.用智能模板指针: "sp<person>"来替代"Person *"
###########################################################################################
(33)引用计数:
	1.为什么要引用计数?
		使用智能指针时:
		1.main中定义一个智能指针other
		2.main中调用func函数, 传入智能指针other
		3.在func函数中将other拷贝为s, 调用s中原始指针的成员函数
		==>分析:
		func函数退出时, 销毁拷贝的对象, 掉用他的析构函数, 会delete掉原始指针
		这就造成了智能指针里面的源对象被过早的销毁, 不合理
	2.使用引用计数
		在智能指针的基对象里面		
			1.添加私有成员count
			2.构造函数里:count = 0;
		在智能指针对应类里面:
			1.拷贝构造函数里: count++;
			2.析构函数里:
				if (count == 0)		销毁源对象
				else				count--	
	3.目的: 销毁拷贝的智能指针时, 不会销毁源智能指针里面的源对象.
	4.扩展: 一般将引用计数独立为一个类, 然后智能指针的原对象去继承他	
###########################################################################################
extern “C”的作用
	1.被extern "C"限定的函数或变量是extern类型的
	2.被extern "C"修饰的变量和函数是按照C语言方式进行编译和链接的：这点很重要！！！！
	3.示例
		extern "C" {
			#include "lua.h"
		}	
	
	
###########################################################################################
动态分配内存和撤销(new)和delete
###########################################################################################
标准模板类库：www.cplusplus.com
STL提供了一组表示: 容器、迭代器、函数对象、和算法的模板
	1.STL容器是同值的，及存储的值的类型必须相同。
	2.算法是完成特定的任务（比如：排序、查找）
	3.迭代器能够用来遍历容器里面的对象（与数组指针类似）
	4.函数对象是类似于函数的对象，可以是类对象或函数指针。
	5.STL使能够构造各种容器（包括数组、队列、和链表）和执行各种操作（搜索、排序）
###########################################################################################
迭代器
(一)定义和初始化
	1.每种容器都定义了自己的迭代器类型，如vector:		
		vector<int>::iterator    iter;    //定义一个名为iter的变量
	2.每种容器都定义了一对名为begin和end的函数，用于返回迭代器。下面对迭代器进行初始化操作：	
		vector<int>    ivec;
		vector<int>::iterator    iter1=ivec.bengin();//将迭代器iter1初始化为指向ivec容器的第一个元素
		vector<int>::iterator   iter2=ivec.end();    //将迭代器iter2初始化为指向ivec容器的最后一个元素的下一个位置	
		1.注意end并不指向容器的任何元素，而是指向容器的最后元素的下一位置，称为超出末端迭代器。
		2.如果vector为空，则begin返回的迭代器和end返回的迭代器相同。
		3.一旦向上面这样定义和初始化，就相当于把该迭代器和容器进行了某种关联，就像把一个指针初始化为指向某一空间地址一样。	
(二)常用操作		
	(1)运算符操作
		*iter                //对iter进行解引用，返回迭代器iter指向的元素的引用
		iter->men            //对iter进行解引用，获取指定元素中名为men的成员。等效于(*iter).men
		++iter               //给iter加1，使其指向容器的下一个元素
		iter++
		--iter               //给iter减1，使其指向容器的前一个元素
		iter--
		iter1==iter2         //比较两个迭代器是否相等，当它们指向同一个容器的同一个元素或者都指向同一个容器的超出末端的下一个位置时，它们相等 
		iter1!=iter2        
	(2)使用迭代器遍历容器
		vector<int>::iterator iter;
		for(iter=ivec.begin(); iter!=ivec.end(); ++iter)
			*iter=0;
	(3)在C++定义的容器类型中，只有vector和queue容器提供迭代器算数运算和除!=和==之外的关系运算：
		iter+n     			//在迭代器上加（减）整数n，将产生指向容器中钱前面（后面）第n个元素的迭代器。新计算出来的迭代器必须指向容器中的元素或超出容器末端的下一个元素
		iter-n
		iter1+=iter2        //将iter1加上或减去iter2的运算结果赋给iter1。两个迭代器必须指向容器中的元素或超出容器末端的下一个元素
		iter1-=iter2
		iter1-iter2         //两个迭代器的减法，得出两个迭代器的距离。两个迭代器必须指向容器中的元素或超出容器末端的下一个元素
		>,>=,<,<=       	//元素靠后的迭代器大于靠前的迭代器。两个迭代器必须指向容器中的元素或超出容器末端的下一个元素	
		 注意两个迭代器相减得出两个迭代器对象的距离，该距离名为difference_type的signed类型的值，该类型类似于size_type类型，也是有vector定义的。
		可以迭代器算术操作来移动迭代器直接指向某个元素：
			vector<int>::iterator    mid=v.begin()+v.size()/2;   //初始化mid迭代器，使其指向v中最靠近正中间的元素
	(4)如果迭代器指向容器对象.end(链表头), 那么*迭代器表示容器中成员的个数(除开链表头)
	
(三)迭代器const_iterator	
	　1.每种容器还定义了一种名为const_iterator的类型。该类型的迭代器只能读取容器中的元素，不能用于改变其值。
	之前的例子中，普通的迭代器可以对容器中的元素进行解引用并修改，而const_iterator类型的迭代器只能用于读不能进行重写。
	  2.例如可以进行如下操作：
		for(vector<int>::const_iterator iter=ivec.begin();iter!=ivec.end();++iter)
			 cout<<*iter<<endl;       //合法，读取容器中元素值
		for(vector<int>::const_iterator iter=ivec.begin();iter!=ivec.end();++iter)
			*iter=0;        //不合法，不能进行写操作
	
###########################################################################################
容器：<vector>	
	1.vector是一个动态分配的数组，可以使用指针来访问他们。
	2.可以使用[]运算符来表示vector容器里面的元素。
	3.实例化容器
	  vector<int> first;                                // int型的空数组(没有分配堆空间)
	  vector<int> second(4);                      	    // 分配4个int的数组,都为0
	  vector<int> second(4,100);                       // 分配4个int, 每个值都为0
	  vector<int> third (second.begin(),second.end());  // iterating through second
	  vector<int> fourth (third);                       // a copy of third	
	  for(i=0; i<rating.size(); i++)
        rating[i]=i;
	4.例:
		vector<int> rating(4,111);
		rating[1] = 555;
		cout<<sizeof(rating)<<endl;		// 12
		cout<<*((&rating[0])+1)<<endl;	// 555
###########################################################################################
容器：<list>
1.list容器的实质是一个双向链表, 可进行双向迭代。
2.list容器的缺点是不能像vector容器一样通过下标来访问容器内的对象。
3.实例化容器
	list<int> first;                                // empty list of ints
	list<int> l{1,2,3};								// 将1,2,3分别插入链表
	list<int> second(4,100);                        // four ints with value 100
	list<int> third(second.begin(), second.end());  // iterating through second
	list<int> fourth (third);                       // a copy of third	
4.list容器的用法
	1、begin()和end()
		1.begin()得到一个指向容器起始位置的iterator，
		2.可以调用list容器的end()函数来得到list末端下一位置
	2.push_back()和push_front()
		使用list的成员函数push_back和push_front插入一个元素到list中。
		其中push_back()是从list的末端插入，而push_front()是从list的头部插入。
	3.empty() 
		判断list是否为空
	4.resize()
		1.调用resize(n)将list的长度改为只容纳n个元素，超出的元素将被删除。
		2.如果n比list原来的长度长，那么默认超出的部分元素置为0。
		3.也可以用resize(n, m)的方式将超出的部分赋值为m。
	5.clear()
		清空list中的所有元素
	6.front()和back()
		1.通过front()可以获得list容器中的头部元素，通过back()可以获得list容器的最后一个元素。
		2.注意：当list元素为空时，这时候调用front()和back()不会报错。
	7.pop_back()和pop_front()	
		使用pop_back()可以删掉尾部第一个元素，pop_front()可以删掉头部第一个元素。
			注意：list必须不为空，如果当list为空的时候调用pop_back()和pop_front()会使程序崩掉。
	8.assign()		
		1.assign(n, val):将a中的n个元素替换为val
		2.a.assign(b.begin(), b.end())	// 将a链表设置为b链表
	9.swap()		
		交换两个链表。a.swap(b)和swap(a, b)，都可以完成a链表和b链表的交换。
	10.reverse()	
		可以实现list的逆置
	11.merge()
		a.merge(b) 调用结束后b变为空，a中元素包含原来a和b的元素。
	12.insert()
		在指定位置插入一个或多个元素
	13.erase()
		删除一个元素或一个区域的元素
	14.remove()函数
		从list中删除元素
		list<int>a{6,7,8,9,7,10};
		a.remove(7);
	


	
###########################################################################################
容器：<map>
①知识点:
	1.map内部是一颗红黑树
	2.如果在map中插入相同的建值会覆盖上一个条目
	3.map容器默认使用键值的升序来排列, 可以重载()符号来自定义排序
	4.map容器添加元素可通过两种方式实现：
		1.通过insert成员函数实现。
		2.通过下标操作符获取元素，然后给获取的元素赋值。 map对象的访问可通过下标和迭代器两种方式实现
		3.map的下标是键，返回的是特定键所关联的值。
		4.使用迭代器访问，iter->first指向元素的键，iter->second指向键对应的值。 使用下标访问map容器与使用下标访问vector的行为截然不同：用下标访问map中不存在的元素将导致在map容器中添加一个新的元素，这个元素的键即为该下标值，键所对应的值为
②创建map对象	
	map<int,char>mp;//定义map容器
③插入
	mp[1]='a';
	mp[1]='b';//key不允许重复,再次插入相当于修改value的值 
	mp[2]='a'; 
    //insert()方式插入
④删除
	mp.erase('b');
⑤元素的遍历
	map<int,char>::iterator it=mp.begin();
	while(it!=mp.end())
	{	cout<<"key:"<<it->first<<" "; 
		cout<<"value:"<<it->second<<endl;;
		it++;
	}
⑥元素的查找
	//搜索键值为1的元素 
	/*若该键值存在，则返回该键值所在的
	  迭代器位置，不存在则返回end()迭代器位置 
	it=mp.find(1);
⑦API
	begin() 		// 返回指向 map 头部的迭代器
	clear(） 		// 删除所有元素
	count() 		// 返回指定元素出现的次数
	empty() 		// 如果 map 为空则返回 true
	end() 			// 返回指向 map 末尾的迭代器
	erase() 		// 删除一个元素
	find() 			// 查找一个元素
	insert() 		// 插入元素
	key_comp() 		// 返回比较元素 key 的函数
	lower_bound() 	// 返回键值>=给定元素的第一个位置
	max_size() 		// 返回可以容纳的最大元素个数
	rbegin() 		// 返回一个指向 map 尾部的逆向迭代器
	rend() 			// 返回一个指向 map 头部的逆向迭代器
	size() 			// 返回 map 中元素的个数
	swap() 			// 交换两个 map
	upper_bound()   // 返回键值>给定元素的第一个位置


###########################################################################################
容器：<set>
	1.set容器的实质是一个二叉红黑数
	2.容器里面的对象具有const特性, 不能修改对象的值(因为里面仅存储了键值)
	3.容器里面的对象必须是唯一的。
	4.对象自动按首字母排序
	5.map和set的插入删除效率比用其他序列容器高
		对于关联容器来说，不需要做内存拷贝和内存移动。
	6.为何每次insert之后，以前保存的iterator不会失效
	7.iterator这里就相当于指向节点的指针，内存没有变，指向内存的指针怎么会失效呢(当然被删除的那个元素本身已经失效了)
	8.API
		begin()     　　 ,返回set容器第一个元素的迭代器
		end() 　　　　 ,返回一个指向当前set末尾元素的下一位置的迭代器.
		clear()   　　     ,删除set容器中的所有的元素
		empty() 　　　,判断set容器是否为空
		max_size() 　 ,返回set容器可能包含的元素最大个数
		size() 　　　　 ,返回当前set容器中的元素个数
		rbegin()　　　　 ,返回的值和end()相同
		rend()　　　　 ,返回的值和begin()相同
	9.示例set<int> s;
		 s.insert(1);
		 s.insert(2);
		 s.insert(3);
		 s.insert(1);	// 覆盖之前键值为1的条目

	

###########################################################################################
explicit关键字:
	1.explicit关键字只能用于修饰只有一个参数的类构造函数, 它的作用是表明该构造函数是显示的, 而非隐式的，
	2.跟它相对应的另一个关键字是implicit, 意思是隐藏的,类构造函数默认情况下即声明为implicit(隐式)。
	3. explicit关键字的作用：禁止隐式调用类内的单参数构造函数
		（1）该关键字只能用来修饰类内部的构造函数
		（2）禁止隐式调用拷贝构造函数
		（3）禁止类对象之间的隐式转换
	4.示例
		class cls{
		public:
			cls(int i) { cout<<i<<endl; }
		};
		class cls2{
		public:
			explicit cls2(int i) { cout<<i<<endl; }
		};
		int main(int argc, char *argv[])
		{
			cls c1 = 12;		// 可以, 将12隐式的转换为cls类型
			cls2 c2 = 12;		// 编译报错, 不能隐式的将12转换为cls2类型, 因为声明了explicit关键字, 所以只能显示转换.
		}	
	
###########################################################################################
动态分配和释放内存（new，delete）
		分配			释放
	new int;			delete(首地址)		// 堆中分配4字节, 返回首地址
	new int(100)		delete(首地址)		// 堆中分配4字节, 返回首地址, 这段空间的初值为100
	new int[10]			delete [](首地址)	// 分配一个存储int变量的数组(size = 10 x 4), 返回首地址
	new int [5][4]		for()	delete [](首地址) // 分配一个5x4的二维int数组, 返回首地址
	new class_a(arg)	delete(首地址)		// 分配一个类对象class_a, 构造函数的参数为arg					
###########################################################################################
函数后面加const
	1.作用: const在函数的后面，表示该函数不能修改类里面的成员变量
	2.注意:
		1.构造函数后面不能加const。（因为构造函数是要初始化成员的， 所以报错）
		2.如果函数后加了const， 函数内部改变了变量的值，就会引起编译错误。
		
###########################################################################################
override 关键字
	1.在函数比较多的情况下可以提示读者某个函数重写了基类虚函数
	2.强制编译器检查某个函数是否重写基类虚函数，如果没有则报错。
比如:
	class a
	{
	public:
		virtual void func() {};
	};		
	class c : public a{
		virtual void func() override;
	};	
	int main()
	{    c c1;		// 报错,func虚函数未重写 
		return 0;
	}
###########################################################################################
c++函数递归	
	递归何时退出:
		1.参数的值满足函数里面的退出条件
		2.递归调用时,递归函数返回了与参数不同的类型。
			比如： 
			inline void QStandardItemModel::insertRow(int arow, QStandardItem *aitem)
			{	// 创建一个容器对象, 调用append()将aitem放入容器
				insertRow(arow, QList<QStandardItem*>() << aitem);  // 这是调用重载函数, 而不是递归调用
			}	

	int Factorial(int n) {
		if (n == 1)
			return 1;
		return n * Factorial(n - 1);
	}
	int main()
	{
		Factorial(4);
	}
	过程:
		Factorial(4) = 4 * Factorial(3);
		Factorial(3) = 3 * Factorial(2);
		Factorial(2) = 2 * Factorial(1);
		Factorial(1) = 1;
		==> Factorial(4) = 4 * 3 * 2 * 1
###########################################################################################
循环中变量的生命周期:
	循环中变量的声明周期只在单次循环内部, 单次循环结束后栈中变量空间被释放。
	// 所以下列语句合法
	for (int i = 0; i < 4; i++)
	{   int j = i;
		cout<<j<<endl;	
	}
###########################################################################################
&类名::非静态成员函数名
1.目的: 返回函数的地址
2.理解注意
	1.类的大小包括非静态数据成员而不包括成员函数。
	2.☆☆成员函数在类外单独存放，并且同类型的所有对象共用一份成员函数（节省了空间）。
		对象一 		对象二 		对象三
		---------------------------
		数据		数据	 	数据
		---------------------------
			公共代码区(成员函数)
		---------------------------
		1.这时就引出了一个问题，由对象调用成员函数时，如何得知成员函数内所使用的数据成员属于哪一个类呢？ 
		   这时就引入了this指针。	// 非静态成员函数的第一个隐含形参，称为this指针。**
	3.this指针的特性
		a.)this指针的类型：类类型 *const; 
		b.)this指针并不是对象的一部分，不会影响对象的大小； 
		c.)this指针是非静态成员函数的第一个隐含指针形参，是编译器自己处理的，我们不能在成员函数的形参中添加this指针的参数定义，也不能在调用时显示传递对象的地址给this指针; 
	4.this指针的两种传参方式： 
		1.)通过ecx寄存器传参（寄存器相当于全局变量）―-当成员函数的参数固定时（这时遵循__thiscall调用约定）； 
		2.)通过压栈传参―-当成员函数的参数为可变时（这时遵循__cdecl调用约定）。

	5.例
		class Cls {
		public:
			void train() {}
			void train2() {}
		};
		int main(int argc, char *argv[])
		{
			Cls c1, c2;
			printf("%p\n", &Cls::train);	// 00407e94
			printf("%p\n", &c1.train);		// 00407e94
			printf("%p\n", &c2.train);		// 00407e94
		}	
###########################################################################################
C++多线程(标准库)
// http://www.cplusplus.com/reference/
	// thread example
	#include <iostream>       // std::cout
	#include <thread>         // std::thread
	void foo() 
	{
	  // do stuff...
	}
	void bar(int x)
	{
	  // do stuff...
	}
	int main() 
	{
	  std::thread first(foo);     // spawn new thread that calls foo()
	  std::thread second(bar,0);  // spawn new thread that calls bar(0)
	  std::cout << "main, foo and bar now execute concurrently...\n";
	  // synchronize threads:
	  first.detach();  	// 设置为分离状态              
	  second.detach();  // 设置为分离状态             
	  std::cout << "foo and bar completed.\n";
	  return 0;
	}

###########################################################################################
C++多进程






