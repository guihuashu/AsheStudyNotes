《漫画算法》
逻辑结构：数据对象中各元素的关系
	集合结构：数据元素中间没有关系，但从属于一个集合
	线性结构：数据元素之间呈一对一关系
	树型结构：元素之间呈一对多的关系
	图形结构：多对多的关系
	
物理结构：数据的逻辑结构在计算机中的存储形式
	顺序存储存储：将数据元素存放在地址连续的存储单元里，
		数据间的逻辑关系和物理关系是一致的，如数组。
	链式存储存储：
		数据元素存放在任意存储单元里，存储单元可以连续也可以不连续。
######################################################################################################
				一、 算法效率的度量方法
######################################################################################################
(1)对效率影响较大的因素：
	 1.算法采用的策略，方案
	 2.编译产生的代码质量
	 3.问题的输入规模
	 4.机器执行指令的速度
------------------------------------------------------------------------------------------------------	  
(2)常见算法的时间复杂度	: 
	[1]O(1): <常数阶>
		printf
		printf
		...
	[2]O(n): <线性阶>
		for (i=1; i<n; i++){}
	[3]O(n^2)：<平方阶>
		1.for (i=1; i<n; i++){
			for (j=1; j<n; j++)
		  }
		2.for (i=1; i<n; i++){
			for (j=i; j<n; j++)
		  } // 复杂度= n + n + n-1+...+1= (n+1)n/2 = O(n^2)
	[4]O(n^3): <立方阶>
		for
		 for
		  for
	[5]对数阶<O(logn)>
		i=1;n=100
		while (i<n){
			i *= 2;
		} // 2^x=n ==》x=log(2)n
	[6]O(nlogn)：nlogn阶
		for (i=1;i<n;i++){
			while(j<n){
				j*=2;
			}
		}
	[7]n!	
		func(i){
			if(--i != 0){
				func(i)
			}
		}
		int main(){
			func(n);			
		}
		
	[7]2^n
	[9]n^n
------------------------------------------------------------------------------------------------------	  
(3)分析算法的时间复杂度（大O阶）的方法
	1.用1取代运行时间中的所有加法常数
	2.在修改后的运行次数函数中，只保留最高阶项
	3.如果最高阶项存在且不是1，则去除与这个项相乘的常数。
	4.得到的最后结果就是大O阶
------------------------------------------------------------------------------------------------------	  
(4)空间复杂度
	// 写代码时，完全可以用空间来换时间。
	1.通常用“时间复杂度”来指运行时间的需求
	2.通常用空间复杂度指空间需求。
######################################################################################################
							二、 线性表
######################################################################################################
定义：由零个或多个数据元素组成的有限序列。
数据类型分类：
	原子类型：不可以再分解的类型（如：整形，浮点型）。
	结构类型：由若干个类型组合而成的类型（如：结构体）。
抽象数据类型：
		指一个数学模型及定义在该模型上的一组操作
------------------------------------------------------------------------------------------------------	  
(1)线性表的顺序存储结构（数组）：[a1,a2,a3...] 
	[1]插入算法的思路
		1.如果插入位置不合理，抛出异常
		2.如果线性表长度大于等于数组长度，则抛出异常或动态增加数组容量
		3.重左后一个元素开始向前遍历到低i个位置，分别将它们都后移一个位置；
		4.将要插入的元素填入位置i处；
		5.线性表长度+1
	[2]删除操作
		1.如果删除位置不合理，抛出异常；
		2.取出删除元素
		3.从删除元素位置开始遍历到最后一个元素位置，分别将它们都向前移动一个位置。
		4.表长-1
	[3]线性表插入和删除操作的时间复杂度
		1.最好的情况：O(1)
			插入和删除的位置是第一个元素，不需要移动其他元素的位置。
		2.最坏的情况：O(n)
			插入和删除的位置是最后一个元素，
	[4]线性表顺序存储结构的优缺点
		1.存数据或者读数据时，不管在哪个位置，时间复杂度都是O(1).
		2.插入或删除时，时间复杂度都是O(n)
		3.比较适合存储元素个数比较稳定，不经常插入和删除元素的应用。
		4.以块为单位申请空间，容易产生存储空间“碎片”(块内存间的小内存 )。
------------------------------------------------------------------------------------------------------	  			
（2）单链表
// 线性表的链式存储结构（概念）：
// 1.存储数据元信息的域称为“数据域”		
// 2.存储指针信息（链信息）的空间称为“指针域”
// 3.指针域和指针信息组成的元素称为节点（Node）（存储映像）
// 4.链表每个节点中只包含一个指针域的称为单链表
属性：	
	1.单链表有头有尾，最后一个节点的指针指向NULL
	2.头结点的数据域一般不存储任何信息
	[1]
▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄	
							三、 栈
▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄	
【一】栈的链式存储结构
	（1）说明
		1.不需要头结点（栈的每一项都要存放数据）
		2.头指针设置为栈顶（插入删除操作都在栈顶）
		
▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂	  
【二】栈的应用-递归
	（1）递归的定义
		把一个直接调用自己或者或者通过一系列调用语句间接调用自己自己的函数，称之为递归函数
	（2）例子：
			函数f(n)如下，打印出f（1）到f（40）。
					0 (n=0)
			f(n)=	1 (n=1)
					f(n-1)+(n-2) (n>2)
			// 代码
			int Fib(int n)
			{
				if (n<2){
					n==0 ? 0 : 1;
				}
				return Fib(n-1) + Fib(n-2)
			}
			int main()
			{
				for(int i=0; i<=40; i++)
					printf("%d\n",Fib(i));
			}	
▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂	  
【三】栈的应用-四则表达式求值
	（1）定义
		中缀表达式：平常的数学表达式，符号在数字中间。
		后缀表达式： 运算符在表达式的后面
	（2）中缀表达式转后缀表达式
		1.从左到右遍历中缀表达式中每个数字和符号
		2.若是数字就直接作为后缀表达式的一部分
		3.若是符号
			1.符号为”）“，将栈中的符号出栈，到”（“为止
			2.符号为运算符
				1）符号优先级 > 栈顶符号优先级
					该符号入栈
				2）	符号优先级 ≤ 栈顶符号优先级
					栈中的所有大于或等于该符号优先级的符号出栈，然后将该符号入栈
	（3）后缀表达式计算结果
		1.从左到右遍历没和数字和符号
		2.是数字就进栈
		  是符号就将栈顶的两个数字取出，进行运算，计算结果出栈，一直到最终获得结果。
		  
######################################################################################################
							四、 队列
######################################################################################################
▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂	  
【一】队列的定义
	1.队列是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。
	2.队列是一种先进先出的线性表简称FIFO，简称FIFO（First In First Out）
	3.允许插入的一端称为队尾，允许删除的一端称为对头。
▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂	  
【二】队列的顺序存储结构---循环队列（循环缓冲区FIFO）
	// 非循环的结构每次删除后都要移动所有元素（不合理）
（1）定义
	1.数组的长度固定（QueueSize），使用两个下标数字（front和rear来模拟循环队列）
	2.front为队列头的下标，rear为队尾的下一个位置的下标
	2.最开始从数组的后面插，前面取。数组插满之后就重头开始插。
	3.rear > front时，说明循环队列还没有开始循环插入；反之，说明已经循环插入了。
	4.当数组中还有一个空闲位置时，认为循环队列满了。
		1.(rear+1)%QueueSize = front 时，队列满了	（未开始循环）
									// 0 1 2 3 4 
									   f . . . r  	
		2..(rear+1)%QueueSize = front 时，队列满了（已经循环了）
									// 0 1 2 3 4 
									   . . r f .	
		==》(rear+1)%QueueSize = front 时，队列满了。
	5.队列的长度
		未循环时：rear-front
		循环时：  （QueueSize - front）+rear = rear-front+QueueSize // 包括两部分：front及后面的，rear前面的
	    ==》队列的长度= （rear-front+QueueSize）%QueueSize
	6.front或者rear往后移一个位置，或者是转到数组开头位置
		front = （front+1）%QueueSize
		rear = （rear+1）%QueueSize
	7.队列为空的条件
		front = rear；
（2）操作
	1.尾部插入
		队列满时返回
		在rear位置插入新元素，rear向后移或者调转到开头
	2.头部取出
		队列空时返回
		取出front位置的元素，front向后移或者调转到开头
（2）特点
	1.时间复杂度为O（1）	
	2.队列长度固定
▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂	  
【三】队列的链式存储结构---单链表
（1）定义
	1.使用有头结点的单链表来模拟
	2.使用head和rear指针来模拟队列
	3.head为队列头的前一个节点，rear为队尾节点
（2）队尾插入操作
	在rear后面插入元素
（3）删除队头元素
	删除fhead的下一个元素
	如果删除前只有一个元素，那么在删除后要让rear指向头结点	
（4）特点
	1.时间复杂度为O（1）	
	2.队列长度不固定
▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄	
							四、 串（字符串）
▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄	
【一】定义
	1.串（String）是由0个或多个字符组成的有限序列，又名叫字符串。
	2.串中的字符数目n称为串的长度。
	3.0个字符的串称为空串。
	4.空格串：由一个或多个“空格”字符组成的串
	5.子串与主串：串中任意个数的连续字符组成的子序列称为主串的子串。
▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂	  
【二】串的比较
（1）相等
	两个串的长度以及它们各个对应位置的字符都相等时，才算是相等。
（2）不相等，判断大小。
	s=a1a2...an, t=b1b2...bm
	1.n<m且ai=bi时，认为t>s
		比如s= ab, t=abc
	2.两个串的前面部分相同，但是s的不相同部分的第一个字符小于t对应位置的字符，说明s<t。
		s="happen",t="happy", e<y，所以s<t
▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂	  
【三】KMP模式匹配算法

▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄	
							五、 树
▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄	
【一】树的定义
（1）概念
	1.树是n（n≥0）个节点的有限集。
	2.n=0时称为空树
	3.在任意一颗非空树中
		1.有且仅有一个特定的称为（Root）的节点。
		2.当n>1时，其余节点可分为m（m>0）个互不相交的有限集T1、T2...TM,其中每一个集合本身又是一棵树，
		     称为根的子树（SubTree）
（2）节点的分类
	// 度：节点拥有的子树个数
	1.叶（leaf）节点/终端节点：度为0。
	2.分支节点/非终端节点：度不为0。
	3.内部节点：除根节点外的分支节点，称为内部节点。
	4.树的度：  树内各节点的度的最大值。
	5.节点的子树的根称为该节点的孩子（Child），该节点称为孩子的双亲。
	6.同一个双亲的孩子之间互相称为兄弟（sibling）。
	7.节点的祖先是从根到该节点所经分支的所有节点
	8.以某节点为根的所有子树中的任一节点都称为该节点的子孙
（3）树的深度
	1.节点的层次从根开始定义，根为第一层，根的孩子为第二层，以此类推。
	2.双亲在同一层的节点互为堂兄弟。
	3.树中节点的最大层次称为树的深度或高度。
	4.如果将树中节点的各子树看成从左自右是由次序的，不能互换的，则称该树为有序树，否则称为无序树。
	5.森林是m棵互不相交的树的集合。对树中的每个节点而言，其子树的集合即为森林。
▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂	  
【二】树的抽象数据类型
	// 树是由一个根节点和若干棵子树构成。树中节点具有相同数据类型及层次关系。
	InitTree（*T）:构造空树T。
	DestroyTree（*T）：销毁树T
	CreateTree（*T，definition）：按definition中给出树的定义来构造树
	ClearTree（*T）：若树T存在，则将树T清空为空树
	TreeEmpty（T）：若T为空树返回tree，否则返回false。
	TreeDepth（T）：返回T的深度。
	Root（T）：返回T的根节点
	Value（T，cur_e）:cur_e是树T中一个节点，返回此结点的值。
	Assign（T，cur_e,value）:给树的cur_e结点赋值为value
	Parent（T，cur_e）:若cur_e是非根节点，则返回它的双亲节点，否则返回空。
	LeftChild（T，cur_e）若cur_e是非叶节点，则返回它的左孩子，否则返回空。
	RightSibling（T，cur_e）:若cur_e有右兄弟，则返回它的右兄弟，否则返回空。
	InsertChild（*T，*p,i,c）:其中p指向树T的某个节点，i为所指节点p的度加上1，
	                          非空树c与T不相交，操作结果为插入c为树T中p指节点的i棵子树。
	DeleteChild（*T，*p，i）：其中p指向树T的某个节点，i为所指节点p的度，操作结果为删除T中p所指节点的第i棵子树。						  
▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂	  
【三】树的存储结构
（1）双亲表示法
	1.使用数组来存放树中的每一个结点
	2.每个结点中附加一个指示器来指示其双亲节点的数组下标
	3.根结点中的双亲指示下标为-1。
	4.特点
		1.寻找双亲节点的时间复杂度为O（1）。
		2.寻找子节点的时间复杂度为O（n），因为需要遍历整个树。
	
	/* 树的双亲表示法的结点结构定义代码 */
	#define int TElemType;
	typedef struct PTNode{
		TElemType data;		// 结点数据
		int parent;      	// 该结点的双亲在数组下标中的位置，根结点的parent为0。
	}PTNode;
	/* 树结构 */
	typedef struct {
		PTNode nodes[MAX_TREE_SIZE]; // 节点数组
		int r，n；			// r为根结点的数组下标，n为节点的个数
	}PTree;

（2）孩子表示法
	1.把每个结点的孩子结点排列起来，以单链表做存储结构。则n各节点有n个孩子链表
	2.叶结点的孩子链表为空
	3.使用一位数组来存储所有结点
	4.数组元素的数据结构：节点数据域、子节点链表的头指针。
	5.孩子链表中元素的数据结构：该节点在数组中的下标，下一个子结点的指针域。
	
	/* 孩子结点结构 */
	typedef struct child{
		int child; 			 // 该孩子节点在数组中的下标。
		struct child *next； // 下一个孩子结点
	}*ChildPtr;
	
	/* 数组元素结构 */
	typedef struct {
		ElemType data;
		ChildPtr firstchild;
	}CTBox;
	
	/* 树结构 */
	typedef struct {
		CTBox nodes[MAX_TREE_SIZE]; // 结点数组
		int r,n;					// 根的位置和结点数
	}CTree;
	
（3）孩子兄弟表示法
	1.任意一棵树，它的节点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的。
	2.设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟(右边紧挨着的一个节点)。
	
	/* 树的孩子兄弟表示法结构定义 */
	typedef struct CSNode{
		ElemType data；
		struct CSNode *firstchild, *rightsib;
	}CSNode,*CSTree
▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂	  
【四】二叉树的定义
（1）定义
	1.二叉树是n（n≥0）个节点的有限集合。
	2.这个集合可以为空集（空二叉树），也可以由一个根节点和该根节点的两颗互不相交的左子树和右子树组成。
（2）二叉树的特点	
	1.每个节点最多有两颗子树（节点的度≤2）
	2.左子树和右子树是由顺序的，次序不能颠倒。
	3.即使树中某节点只有一颗子树，也要区分他是左子树还是右子树。
（3）二叉树的五种基本形态
	1.空二叉树
	2.只有一个根节点
	3.根节点只有左子树
	4.根节点只有右子树
	5.根节点既有左子树又有右子树
（4）特殊二叉树
	[1]斜树
		1.左斜树：所有节点都只有左子树的二叉树
		2.右斜树：所有节点都只有右子树的二叉树
		3.特点：
			1.树的每一层都只有一个节点。
			2.节点的个数与二叉树的深度相同。
		
	[2]满二叉树
		1.定义：一棵树中的所有分支节点都存在左子树和右子树，并且所有叶节点都在同一层上。
		2.特点：
			1.所有叶节点智能出现在最下一层。
			2.非叶节点的所有节点的度均为2。
			3.与同样深度的其它二叉树相比，满二叉树的节点个数和叶结点个数是最多的。
	[3]完全二叉树
		1.定义：对一颗具有n个节点的二叉树按层序编号，如果编号为i（1≤i≤n）的结点与同样深度的满二叉树
		      中标号为i的结点在二叉树中位置完全相同，则这棵树称为完全二叉树。
		2.特点：
			1.叶子结点只能出现在最下面两层
			2.最下层的叶子一定集中在左部连续位置。
			3.倒数第二层若有叶子结点，一定都在右部连续位置。
			4.若果结点度为1，则该节点只有左孩子，即不存在只有右子树的情况。
			5.同样结点数的二叉树，完全二叉树的深度最小。
▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂	  
【五】二叉树的性质
（0）二叉树性质0：二叉树中n个节点间的连线一定为n-1条。 
	// 除根节点外，每增加一个节点就需要一条线来连接新增节点。
（1）二叉树性质1：在二叉树的第i层上最多有2^(i-1)个结点（i≥1）	
（2）二叉树性质2：深度为k的二叉树最多有2^k -1 个节点。
（3）二叉树性质3：对任意一颗二叉树T，如果其终端结点数为n0,度为2的节点数为n2, 则有n0=n2+1
	// n0+n1+n2-1 = n1+2n2  (连线个数建立等式)
（4）性质4：具有n各节点的完全二叉树的深度为┕log2(n)┙+1  (┕x┙)表示不大于x的整数
	// 深度为k的满二叉树的总结点数n=2^k -1 ==>满二叉树二叉树的深度k=log2(n+1)
	   与满二叉树深度相同的一颗完全二叉树的节点数为n，深度为k，但是利用上式求得的深度为（k-1 < m < k）。
		所以计算公式为：(k-1)点几取整，然后+1。
（5）二叉树的性质5
	如果对一颗有n各节点的完全二叉树（其深度为└log2(n)┘+1）的节点按层序编号（从上到下，从左到右），
    对任一节点i（1≤i≤n）有：
		[1]如果i=1,则节点i是二叉树的根，无双亲；如果i>1，则其双亲节点是└i/2┘。
		[2]如果2i>n，则节点i无左孩子；否则i的左孩子为2i。
		[3]如果2i+1>n，则节点i无右孩子；否则i的右孩子为2i+1。
▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂	  
【五】二叉树的存储结构
（1）二叉树顺序存储结构
	存储方式：
		1.使用一维数组来存储二叉树中的结点。
		2.按完全二叉树的方式进行编号，把不存在的节点设置为“^”。
（2）二叉链表
		1.由于二叉树每个节点最多有两个孩子，所以将二叉树结构设计为一个数据域和两个指针域。
		2.“二叉树的儿茶链表结点结构定义”
			typedef struct BiTNode {	/* 节点结构 */
				ElemType data;	/* 节点数据 */
				struct BiTNode *lchild, *rchild;	/* 左右孩子节点指针 */
			}BiTNode,*BiTree;
▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂	  
【五】遍历二叉树
（1）前序遍历
	若二叉树为空，则空操作返回。否则先访问根节点，然后前序遍历左子树，再前序遍历右子树。
（2）中序遍历
	若树为空，则空操作返回。否则从根节点开始（注意不是先访问根节点），中序遍历根结点的左子树，然后访问根节点，
	最后中序遍历右子树。 
（3）后序遍历
（4）层序遍历
	
ABDGH CEIF	
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		








	
	